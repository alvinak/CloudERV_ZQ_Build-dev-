/* soapC.cpp
   Generated by gSOAP 2.8.17r from ImageViewerAutomation.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.17r 2014-05-11 18:10:47 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_ns3__char:
		return soap_in_ns3__char(soap, NULL, NULL, "ns3:char");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns3__guid__:
		return soap_in_ns3__guid__(soap, NULL, NULL, "ns3:guid");
	case SOAP_TYPE_ns3__guid:
		return soap_in_ns3__guid(soap, NULL, NULL, "ns3:guid");
	case SOAP_TYPE_ns3__duration__:
		return soap_in_ns3__duration__(soap, NULL, NULL, "ns3:duration");
	case SOAP_TYPE_ns3__duration:
		return soap_in_ns3__duration(soap, NULL, NULL, "ns3:duration");
	case SOAP_TYPE_ns3__char__:
		return soap_in_ns3__char__(soap, NULL, NULL, "ns3:char");
	case SOAP_TYPE_ns6__StudyOfflineFault:
		return soap_in_ns6__StudyOfflineFault(soap, NULL, NULL, "ns6:StudyOfflineFault");
	case SOAP_TYPE_ns6__StudyInUseFault:
		return soap_in_ns6__StudyInUseFault(soap, NULL, NULL, "ns6:StudyInUseFault");
	case SOAP_TYPE_ns6__StudyNotFoundFault:
		return soap_in_ns6__StudyNotFoundFault(soap, NULL, NULL, "ns6:StudyNotFoundFault");
	case SOAP_TYPE_ns6__StudyNearlineFault:
		return soap_in_ns6__StudyNearlineFault(soap, NULL, NULL, "ns6:StudyNearlineFault");
	case SOAP_TYPE_ns5__ArrayOfImageIdentifier:
		return soap_in_ns5__ArrayOfImageIdentifier(soap, NULL, NULL, "ns5:ArrayOfImageIdentifier");
	case SOAP_TYPE_ns5__ImageIdentifier:
		return soap_in_ns5__ImageIdentifier(soap, NULL, NULL, "ns5:ImageIdentifier");
	case SOAP_TYPE_ns5__ArrayOfSeriesIdentifier:
		return soap_in_ns5__ArrayOfSeriesIdentifier(soap, NULL, NULL, "ns5:ArrayOfSeriesIdentifier");
	case SOAP_TYPE_ns5__SeriesIdentifier:
		return soap_in_ns5__SeriesIdentifier(soap, NULL, NULL, "ns5:SeriesIdentifier");
	case SOAP_TYPE_ns5__DataValidationFault:
		return soap_in_ns5__DataValidationFault(soap, NULL, NULL, "ns5:DataValidationFault");
	case SOAP_TYPE_ns5__QueryFailedFault:
		return soap_in_ns5__QueryFailedFault(soap, NULL, NULL, "ns5:QueryFailedFault");
	case SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier:
		return soap_in_ns5__ArrayOfStudyRootStudyIdentifier(soap, NULL, NULL, "ns5:ArrayOfStudyRootStudyIdentifier");
	case SOAP_TYPE_ns5__Identifier:
		return soap_in_ns5__Identifier(soap, NULL, NULL, "ns5:Identifier");
	case SOAP_TYPE_ns5__StudyIdentifier:
		return soap_in_ns5__StudyIdentifier(soap, NULL, NULL, "ns5:StudyIdentifier");
	case SOAP_TYPE_ns5__StudyRootStudyIdentifier:
		return soap_in_ns5__StudyRootStudyIdentifier(soap, NULL, NULL, "ns5:StudyRootStudyIdentifier");
	case SOAP_TYPE_ns4__ArrayOfstring:
		return soap_in_ns4__ArrayOfstring(soap, NULL, NULL, "ns4:ArrayOfstring");
	case SOAP_TYPE_ns2__CloseViewerRequest:
		return soap_in_ns2__CloseViewerRequest(soap, NULL, NULL, "ns2:CloseViewerRequest");
	case SOAP_TYPE_ns2__ActivateViewerRequest:
		return soap_in_ns2__ActivateViewerRequest(soap, NULL, NULL, "ns2:ActivateViewerRequest");
	case SOAP_TYPE_ns2__OpenStudiesFault:
		return soap_in_ns2__OpenStudiesFault(soap, NULL, NULL, "ns2:OpenStudiesFault");
	case SOAP_TYPE_ns2__OpenStudiesResult:
		return soap_in_ns2__OpenStudiesResult(soap, NULL, NULL, "ns2:OpenStudiesResult");
	case SOAP_TYPE_ns2__OpenStudyInfo:
		return soap_in_ns2__OpenStudyInfo(soap, NULL, NULL, "ns2:OpenStudyInfo");
	case SOAP_TYPE_ns2__ArrayOfOpenStudyInfo:
		return soap_in_ns2__ArrayOfOpenStudyInfo(soap, NULL, NULL, "ns2:ArrayOfOpenStudyInfo");
	case SOAP_TYPE_ns2__OpenStudiesRequest:
		return soap_in_ns2__OpenStudiesRequest(soap, NULL, NULL, "ns2:OpenStudiesRequest");
	case SOAP_TYPE_ns2__ViewerNotFoundFault:
		return soap_in_ns2__ViewerNotFoundFault(soap, NULL, NULL, "ns2:ViewerNotFoundFault");
	case SOAP_TYPE_ns2__GetViewerInfoResult:
		return soap_in_ns2__GetViewerInfoResult(soap, NULL, NULL, "ns2:GetViewerInfoResult");
	case SOAP_TYPE_ns2__GetViewerInfoRequest:
		return soap_in_ns2__GetViewerInfoRequest(soap, NULL, NULL, "ns2:GetViewerInfoRequest");
	case SOAP_TYPE_ns2__NoActiveViewersFault:
		return soap_in_ns2__NoActiveViewersFault(soap, NULL, NULL, "ns2:NoActiveViewersFault");
	case SOAP_TYPE_ns2__GetActiveViewersResult:
		return soap_in_ns2__GetActiveViewersResult(soap, NULL, NULL, "ns2:GetActiveViewersResult");
	case SOAP_TYPE_ns2__NoViewersFault:
		return soap_in_ns2__NoViewersFault(soap, NULL, NULL, "ns2:NoViewersFault");
	case SOAP_TYPE_ns2__ArrayOfViewer:
		return soap_in_ns2__ArrayOfViewer(soap, NULL, NULL, "ns2:ArrayOfViewer");
	case SOAP_TYPE_ns2__GetViewersResult:
		return soap_in_ns2__GetViewersResult(soap, NULL, NULL, "ns2:GetViewersResult");
	case SOAP_TYPE_ns2__GetViewersRequest:
		return soap_in_ns2__GetViewersRequest(soap, NULL, NULL, "ns2:GetViewersRequest");
	case SOAP_TYPE_ns2__OpenFilesFault:
		return soap_in_ns2__OpenFilesFault(soap, NULL, NULL, "ns2:OpenFilesFault");
	case SOAP_TYPE_ns2__Viewer:
		return soap_in_ns2__Viewer(soap, NULL, NULL, "ns2:Viewer");
	case SOAP_TYPE_ns2__OpenFilesResult:
		return soap_in_ns2__OpenFilesResult(soap, NULL, NULL, "ns2:OpenFilesResult");
	case SOAP_TYPE_ns2__OpenFilesRequest:
		return soap_in_ns2__OpenFilesRequest(soap, NULL, NULL, "ns2:OpenFilesRequest");
	case SOAP_TYPE_xsd__unsignedShort:
		return soap_in_xsd__unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedByte_:
		return soap_in_xsd__unsignedByte_(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__short:
		return soap_in_xsd__short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__float:
		return soap_in_xsd__float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__duration_:
		return soap_in_xsd__duration_(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, NULL, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__decimal_:
		return soap_in_xsd__decimal_(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__byte_:
		return soap_in_xsd__byte_(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return soap_in_xsd__base64Binary_(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI_:
		return soap_in_xsd__anyURI_(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName_:
		return soap_in_xsd__QName_(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__IDREF_:
		return soap_in_xsd__IDREF_(soap, NULL, NULL, "xsd:IDREF");
	case SOAP_TYPE_xsd__IDREF:
		return soap_in_xsd__IDREF(soap, NULL, NULL, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID_:
		return soap_in_xsd__ID_(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns5__ImageQueryResponse:
		return soap_in_PointerTo_ns5__ImageQueryResponse(soap, NULL, NULL, "ns5:ImageQueryResponse");
	case SOAP_TYPE_PointerTo_ns5__ImageQuery:
		return soap_in_PointerTo_ns5__ImageQuery(soap, NULL, NULL, "ns5:ImageQuery");
	case SOAP_TYPE_PointerTo_ns5__SeriesQueryResponse:
		return soap_in_PointerTo_ns5__SeriesQueryResponse(soap, NULL, NULL, "ns5:SeriesQueryResponse");
	case SOAP_TYPE_PointerTo_ns5__SeriesQuery:
		return soap_in_PointerTo_ns5__SeriesQuery(soap, NULL, NULL, "ns5:SeriesQuery");
	case SOAP_TYPE_PointerTo_ns5__StudyQueryResponse:
		return soap_in_PointerTo_ns5__StudyQueryResponse(soap, NULL, NULL, "ns5:StudyQueryResponse");
	case SOAP_TYPE_PointerTo_ns5__StudyQuery:
		return soap_in_PointerTo_ns5__StudyQuery(soap, NULL, NULL, "ns5:StudyQuery");
	case SOAP_TYPE_PointerTo_ns2__CloseViewerResponse:
		return soap_in_PointerTo_ns2__CloseViewerResponse(soap, NULL, NULL, "ns2:CloseViewerResponse");
	case SOAP_TYPE_PointerTo_ns2__CloseViewer:
		return soap_in_PointerTo_ns2__CloseViewer(soap, NULL, NULL, "ns2:CloseViewer");
	case SOAP_TYPE_PointerTo_ns2__ActivateViewerResponse:
		return soap_in_PointerTo_ns2__ActivateViewerResponse(soap, NULL, NULL, "ns2:ActivateViewerResponse");
	case SOAP_TYPE_PointerTo_ns2__ActivateViewer:
		return soap_in_PointerTo_ns2__ActivateViewer(soap, NULL, NULL, "ns2:ActivateViewer");
	case SOAP_TYPE_PointerTo_ns2__OpenStudiesResponse:
		return soap_in_PointerTo_ns2__OpenStudiesResponse(soap, NULL, NULL, "ns2:OpenStudiesResponse");
	case SOAP_TYPE_PointerTo_ns2__OpenStudies:
		return soap_in_PointerTo_ns2__OpenStudies(soap, NULL, NULL, "ns2:OpenStudies");
	case SOAP_TYPE_PointerTo_ns2__GetViewerInfoResponse:
		return soap_in_PointerTo_ns2__GetViewerInfoResponse(soap, NULL, NULL, "ns2:GetViewerInfoResponse");
	case SOAP_TYPE_PointerTo_ns2__GetViewerInfo:
		return soap_in_PointerTo_ns2__GetViewerInfo(soap, NULL, NULL, "ns2:GetViewerInfo");
	case SOAP_TYPE_PointerTo_ns2__GetActiveViewersResponse:
		return soap_in_PointerTo_ns2__GetActiveViewersResponse(soap, NULL, NULL, "ns2:GetActiveViewersResponse");
	case SOAP_TYPE_PointerTo_ns2__GetActiveViewers:
		return soap_in_PointerTo_ns2__GetActiveViewers(soap, NULL, NULL, "ns2:GetActiveViewers");
	case SOAP_TYPE_PointerTo_ns2__GetViewersResponse:
		return soap_in_PointerTo_ns2__GetViewersResponse(soap, NULL, NULL, "ns2:GetViewersResponse");
	case SOAP_TYPE_PointerTo_ns2__GetViewers:
		return soap_in_PointerTo_ns2__GetViewers(soap, NULL, NULL, "ns2:GetViewers");
	case SOAP_TYPE_PointerTo_ns2__OpenFilesResponse:
		return soap_in_PointerTo_ns2__OpenFilesResponse(soap, NULL, NULL, "ns2:OpenFilesResponse");
	case SOAP_TYPE_PointerTo_ns2__OpenFiles:
		return soap_in_PointerTo_ns2__OpenFiles(soap, NULL, NULL, "ns2:OpenFiles");
	case SOAP_TYPE_PointerTons6__StudyOfflineFault:
		return soap_in_PointerTons6__StudyOfflineFault(soap, NULL, NULL, "ns6:StudyOfflineFault");
	case SOAP_TYPE_PointerTons6__StudyNotFoundFault:
		return soap_in_PointerTons6__StudyNotFoundFault(soap, NULL, NULL, "ns6:StudyNotFoundFault");
	case SOAP_TYPE_PointerTons6__StudyNearlineFault:
		return soap_in_PointerTons6__StudyNearlineFault(soap, NULL, NULL, "ns6:StudyNearlineFault");
	case SOAP_TYPE_PointerTons6__StudyInUseFault:
		return soap_in_PointerTons6__StudyInUseFault(soap, NULL, NULL, "ns6:StudyInUseFault");
	case SOAP_TYPE_PointerTons2__OpenStudiesFault:
		return soap_in_PointerTons2__OpenStudiesFault(soap, NULL, NULL, "ns2:OpenStudiesFault");
	case SOAP_TYPE_PointerTons2__OpenFilesFault:
		return soap_in_PointerTons2__OpenFilesFault(soap, NULL, NULL, "ns2:OpenFilesFault");
	case SOAP_TYPE_PointerTons2__NoViewersFault:
		return soap_in_PointerTons2__NoViewersFault(soap, NULL, NULL, "ns2:NoViewersFault");
	case SOAP_TYPE_PointerTons2__NoActiveViewersFault:
		return soap_in_PointerTons2__NoActiveViewersFault(soap, NULL, NULL, "ns2:NoActiveViewersFault");
	case SOAP_TYPE_PointerTons2__ViewerNotFoundFault:
		return soap_in_PointerTons2__ViewerNotFoundFault(soap, NULL, NULL, "ns2:ViewerNotFoundFault");
	case SOAP_TYPE_PointerTons5__QueryFailedFault:
		return soap_in_PointerTons5__QueryFailedFault(soap, NULL, NULL, "ns5:QueryFailedFault");
	case SOAP_TYPE_PointerTons5__DataValidationFault:
		return soap_in_PointerTons5__DataValidationFault(soap, NULL, NULL, "ns5:DataValidationFault");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTons5__ArrayOfImageIdentifier:
		return soap_in_PointerTons5__ArrayOfImageIdentifier(soap, NULL, NULL, "ns5:ArrayOfImageIdentifier");
	case SOAP_TYPE_PointerTons5__ArrayOfSeriesIdentifier:
		return soap_in_PointerTons5__ArrayOfSeriesIdentifier(soap, NULL, NULL, "ns5:ArrayOfSeriesIdentifier");
	case SOAP_TYPE_PointerTons5__ArrayOfStudyRootStudyIdentifier:
		return soap_in_PointerTons5__ArrayOfStudyRootStudyIdentifier(soap, NULL, NULL, "ns5:ArrayOfStudyRootStudyIdentifier");
	case SOAP_TYPE_PointerTons5__ImageIdentifier:
		return soap_in_PointerTons5__ImageIdentifier(soap, NULL, NULL, "ns5:ImageIdentifier");
	case SOAP_TYPE_PointerTons5__SeriesIdentifier:
		return soap_in_PointerTons5__SeriesIdentifier(soap, NULL, NULL, "ns5:SeriesIdentifier");
	case SOAP_TYPE_PointerTons2__CloseViewerRequest:
		return soap_in_PointerTons2__CloseViewerRequest(soap, NULL, NULL, "ns2:CloseViewerRequest");
	case SOAP_TYPE_PointerTons2__ActivateViewerRequest:
		return soap_in_PointerTons2__ActivateViewerRequest(soap, NULL, NULL, "ns2:ActivateViewerRequest");
	case SOAP_TYPE_PointerTons2__OpenStudiesResult:
		return soap_in_PointerTons2__OpenStudiesResult(soap, NULL, NULL, "ns2:OpenStudiesResult");
	case SOAP_TYPE_PointerTons2__OpenStudiesRequest:
		return soap_in_PointerTons2__OpenStudiesRequest(soap, NULL, NULL, "ns2:OpenStudiesRequest");
	case SOAP_TYPE_PointerTons2__GetViewerInfoResult:
		return soap_in_PointerTons2__GetViewerInfoResult(soap, NULL, NULL, "ns2:GetViewerInfoResult");
	case SOAP_TYPE_PointerTons2__GetViewerInfoRequest:
		return soap_in_PointerTons2__GetViewerInfoRequest(soap, NULL, NULL, "ns2:GetViewerInfoRequest");
	case SOAP_TYPE_PointerTons2__GetActiveViewersResult:
		return soap_in_PointerTons2__GetActiveViewersResult(soap, NULL, NULL, "ns2:GetActiveViewersResult");
	case SOAP_TYPE_PointerTons2__GetViewersResult:
		return soap_in_PointerTons2__GetViewersResult(soap, NULL, NULL, "ns2:GetViewersResult");
	case SOAP_TYPE_PointerTons2__GetViewersRequest:
		return soap_in_PointerTons2__GetViewersRequest(soap, NULL, NULL, "ns2:GetViewersRequest");
	case SOAP_TYPE_PointerTons2__OpenFilesResult:
		return soap_in_PointerTons2__OpenFilesResult(soap, NULL, NULL, "ns2:OpenFilesResult");
	case SOAP_TYPE_PointerTons2__OpenFilesRequest:
		return soap_in_PointerTons2__OpenFilesRequest(soap, NULL, NULL, "ns2:OpenFilesRequest");
	case SOAP_TYPE_PointerTons2__OpenStudyInfo:
		return soap_in_PointerTons2__OpenStudyInfo(soap, NULL, NULL, "ns2:OpenStudyInfo");
	case SOAP_TYPE_PointerTons2__ArrayOfOpenStudyInfo:
		return soap_in_PointerTons2__ArrayOfOpenStudyInfo(soap, NULL, NULL, "ns2:ArrayOfOpenStudyInfo");
	case SOAP_TYPE_PointerTons2__ArrayOfViewer:
		return soap_in_PointerTons2__ArrayOfViewer(soap, NULL, NULL, "ns2:ArrayOfViewer");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons5__StudyRootStudyIdentifier:
		return soap_in_PointerTons5__StudyRootStudyIdentifier(soap, NULL, NULL, "ns5:StudyRootStudyIdentifier");
	case SOAP_TYPE_PointerTons2__Viewer:
		return soap_in_PointerTons2__Viewer(soap, NULL, NULL, "ns2:Viewer");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTons4__ArrayOfstring:
		return soap_in_PointerTons4__ArrayOfstring(soap, NULL, NULL, "ns4:ArrayOfstring");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:guid"))
		{	*type = SOAP_TYPE_ns3__guid__;
			return soap_in_ns3__guid__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:guid"))
		{	*type = SOAP_TYPE_ns3__guid;
			return soap_in_ns3__guid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:duration"))
		{	*type = SOAP_TYPE_ns3__duration__;
			return soap_in_ns3__duration__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:duration"))
		{	*type = SOAP_TYPE_ns3__duration;
			return soap_in_ns3__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:char"))
		{	*type = SOAP_TYPE_ns3__char__;
			return soap_in_ns3__char__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StudyOfflineFault"))
		{	*type = SOAP_TYPE_ns6__StudyOfflineFault;
			return soap_in_ns6__StudyOfflineFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StudyInUseFault"))
		{	*type = SOAP_TYPE_ns6__StudyInUseFault;
			return soap_in_ns6__StudyInUseFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StudyNotFoundFault"))
		{	*type = SOAP_TYPE_ns6__StudyNotFoundFault;
			return soap_in_ns6__StudyNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StudyNearlineFault"))
		{	*type = SOAP_TYPE_ns6__StudyNearlineFault;
			return soap_in_ns6__StudyNearlineFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfImageIdentifier"))
		{	*type = SOAP_TYPE_ns5__ArrayOfImageIdentifier;
			return soap_in_ns5__ArrayOfImageIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ImageIdentifier"))
		{	*type = SOAP_TYPE_ns5__ImageIdentifier;
			return soap_in_ns5__ImageIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfSeriesIdentifier"))
		{	*type = SOAP_TYPE_ns5__ArrayOfSeriesIdentifier;
			return soap_in_ns5__ArrayOfSeriesIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SeriesIdentifier"))
		{	*type = SOAP_TYPE_ns5__SeriesIdentifier;
			return soap_in_ns5__SeriesIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:DataValidationFault"))
		{	*type = SOAP_TYPE_ns5__DataValidationFault;
			return soap_in_ns5__DataValidationFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:QueryFailedFault"))
		{	*type = SOAP_TYPE_ns5__QueryFailedFault;
			return soap_in_ns5__QueryFailedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfStudyRootStudyIdentifier"))
		{	*type = SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier;
			return soap_in_ns5__ArrayOfStudyRootStudyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Identifier"))
		{	*type = SOAP_TYPE_ns5__Identifier;
			return soap_in_ns5__Identifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:StudyIdentifier"))
		{	*type = SOAP_TYPE_ns5__StudyIdentifier;
			return soap_in_ns5__StudyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:StudyRootStudyIdentifier"))
		{	*type = SOAP_TYPE_ns5__StudyRootStudyIdentifier;
			return soap_in_ns5__StudyRootStudyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfstring"))
		{	*type = SOAP_TYPE_ns4__ArrayOfstring;
			return soap_in_ns4__ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CloseViewerRequest"))
		{	*type = SOAP_TYPE_ns2__CloseViewerRequest;
			return soap_in_ns2__CloseViewerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ActivateViewerRequest"))
		{	*type = SOAP_TYPE_ns2__ActivateViewerRequest;
			return soap_in_ns2__ActivateViewerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudiesFault"))
		{	*type = SOAP_TYPE_ns2__OpenStudiesFault;
			return soap_in_ns2__OpenStudiesFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudiesResult"))
		{	*type = SOAP_TYPE_ns2__OpenStudiesResult;
			return soap_in_ns2__OpenStudiesResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudyInfo"))
		{	*type = SOAP_TYPE_ns2__OpenStudyInfo;
			return soap_in_ns2__OpenStudyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArrayOfOpenStudyInfo"))
		{	*type = SOAP_TYPE_ns2__ArrayOfOpenStudyInfo;
			return soap_in_ns2__ArrayOfOpenStudyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudiesRequest"))
		{	*type = SOAP_TYPE_ns2__OpenStudiesRequest;
			return soap_in_ns2__OpenStudiesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ViewerNotFoundFault"))
		{	*type = SOAP_TYPE_ns2__ViewerNotFoundFault;
			return soap_in_ns2__ViewerNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewerInfoResult"))
		{	*type = SOAP_TYPE_ns2__GetViewerInfoResult;
			return soap_in_ns2__GetViewerInfoResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewerInfoRequest"))
		{	*type = SOAP_TYPE_ns2__GetViewerInfoRequest;
			return soap_in_ns2__GetViewerInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NoActiveViewersFault"))
		{	*type = SOAP_TYPE_ns2__NoActiveViewersFault;
			return soap_in_ns2__NoActiveViewersFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetActiveViewersResult"))
		{	*type = SOAP_TYPE_ns2__GetActiveViewersResult;
			return soap_in_ns2__GetActiveViewersResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NoViewersFault"))
		{	*type = SOAP_TYPE_ns2__NoViewersFault;
			return soap_in_ns2__NoViewersFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArrayOfViewer"))
		{	*type = SOAP_TYPE_ns2__ArrayOfViewer;
			return soap_in_ns2__ArrayOfViewer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewersResult"))
		{	*type = SOAP_TYPE_ns2__GetViewersResult;
			return soap_in_ns2__GetViewersResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewersRequest"))
		{	*type = SOAP_TYPE_ns2__GetViewersRequest;
			return soap_in_ns2__GetViewersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenFilesFault"))
		{	*type = SOAP_TYPE_ns2__OpenFilesFault;
			return soap_in_ns2__OpenFilesFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Viewer"))
		{	*type = SOAP_TYPE_ns2__Viewer;
			return soap_in_ns2__Viewer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenFilesResult"))
		{	*type = SOAP_TYPE_ns2__OpenFilesResult;
			return soap_in_ns2__OpenFilesResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenFilesRequest"))
		{	*type = SOAP_TYPE_ns2__OpenFilesRequest;
			return soap_in_ns2__OpenFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_xsd__unsignedShort;
			return soap_in_xsd__unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte_;
			return soap_in_xsd__unsignedByte_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_xsd__short;
			return soap_in_xsd__short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float;
			return soap_in_xsd__float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration_;
			return soap_in_xsd__duration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal_;
			return soap_in_xsd__decimal_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte_;
			return soap_in_xsd__byte_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary_;
			return soap_in_xsd__base64Binary_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI_;
			return soap_in_xsd__anyURI_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName_;
			return soap_in_xsd__QName_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:IDREF"))
		{	*type = SOAP_TYPE_xsd__IDREF_;
			return soap_in_xsd__IDREF_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:IDREF"))
		{	*type = SOAP_TYPE_xsd__IDREF;
			return soap_in_xsd__IDREF(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID_;
			return soap_in_xsd__ID_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:char"))
		{	*type = SOAP_TYPE_ns3__char;
			return soap_in_ns3__char(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns3:byte"))
		{	*type = SOAP_TYPE__ns3__byte;
			return soap_in__ns3__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:short"))
		{	*type = SOAP_TYPE__ns3__short;
			return soap_in__ns3__short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:char"))
		{	*type = SOAP_TYPE__ns3__char;
			return soap_in__ns3__char(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:int"))
		{	*type = SOAP_TYPE__ns3__int;
			return soap_in__ns3__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:long"))
		{	*type = SOAP_TYPE__ns3__long;
			return soap_in__ns3__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:float"))
		{	*type = SOAP_TYPE__ns3__float;
			return soap_in__ns3__float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:double"))
		{	*type = SOAP_TYPE__ns3__double;
			return soap_in__ns3__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:unsignedByte"))
		{	*type = SOAP_TYPE__ns3__unsignedByte;
			return soap_in__ns3__unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:unsignedShort"))
		{	*type = SOAP_TYPE__ns3__unsignedShort;
			return soap_in__ns3__unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:unsignedInt"))
		{	*type = SOAP_TYPE__ns3__unsignedInt;
			return soap_in__ns3__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:unsignedLong"))
		{	*type = SOAP_TYPE__ns3__unsignedLong;
			return soap_in__ns3__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:dateTime"))
		{	*type = SOAP_TYPE__ns3__dateTime;
			return soap_in__ns3__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:boolean"))
		{	*type = SOAP_TYPE__ns3__boolean;
			return soap_in__ns3__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StudyOfflineFault"))
		{	*type = SOAP_TYPE__ns6__StudyOfflineFault;
			return soap_in__ns6__StudyOfflineFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StudyInUseFault"))
		{	*type = SOAP_TYPE__ns6__StudyInUseFault;
			return soap_in__ns6__StudyInUseFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StudyNotFoundFault"))
		{	*type = SOAP_TYPE__ns6__StudyNotFoundFault;
			return soap_in__ns6__StudyNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:StudyNearlineFault"))
		{	*type = SOAP_TYPE__ns6__StudyNearlineFault;
			return soap_in__ns6__StudyNearlineFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfImageIdentifier"))
		{	*type = SOAP_TYPE__ns5__ArrayOfImageIdentifier;
			return soap_in__ns5__ArrayOfImageIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ImageIdentifier"))
		{	*type = SOAP_TYPE__ns5__ImageIdentifier;
			return soap_in__ns5__ImageIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfSeriesIdentifier"))
		{	*type = SOAP_TYPE__ns5__ArrayOfSeriesIdentifier;
			return soap_in__ns5__ArrayOfSeriesIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SeriesIdentifier"))
		{	*type = SOAP_TYPE__ns5__SeriesIdentifier;
			return soap_in__ns5__SeriesIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:DataValidationFault"))
		{	*type = SOAP_TYPE__ns5__DataValidationFault;
			return soap_in__ns5__DataValidationFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:QueryFailedFault"))
		{	*type = SOAP_TYPE__ns5__QueryFailedFault;
			return soap_in__ns5__QueryFailedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ArrayOfStudyRootStudyIdentifier"))
		{	*type = SOAP_TYPE__ns5__ArrayOfStudyRootStudyIdentifier;
			return soap_in__ns5__ArrayOfStudyRootStudyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Identifier"))
		{	*type = SOAP_TYPE__ns5__Identifier;
			return soap_in__ns5__Identifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:StudyIdentifier"))
		{	*type = SOAP_TYPE__ns5__StudyIdentifier;
			return soap_in__ns5__StudyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:StudyRootStudyIdentifier"))
		{	*type = SOAP_TYPE__ns5__StudyRootStudyIdentifier;
			return soap_in__ns5__StudyRootStudyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ArrayOfstring"))
		{	*type = SOAP_TYPE__ns4__ArrayOfstring;
			return soap_in__ns4__ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Ref"))
		{	*type = SOAP_TYPE__ns3__Ref;
			return soap_in__ns3__Ref(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:Id"))
		{	*type = SOAP_TYPE__ns3__Id;
			return soap_in__ns3__Id(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:FactoryType"))
		{	*type = SOAP_TYPE__ns3__FactoryType;
			return soap_in__ns3__FactoryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:guid"))
		{	*type = SOAP_TYPE__ns3__guid;
			return soap_in__ns3__guid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:duration"))
		{	*type = SOAP_TYPE__ns3__duration;
			return soap_in__ns3__duration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:string"))
		{	*type = SOAP_TYPE__ns3__string;
			return soap_in__ns3__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:QName"))
		{	*type = SOAP_TYPE__ns3__QName;
			return soap_in__ns3__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:decimal"))
		{	*type = SOAP_TYPE__ns3__decimal;
			return soap_in__ns3__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:base64Binary"))
		{	*type = SOAP_TYPE__ns3__base64Binary;
			return soap_in__ns3__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:anyURI"))
		{	*type = SOAP_TYPE__ns3__anyURI;
			return soap_in__ns3__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:anyType"))
		{	*type = SOAP_TYPE__ns3__anyType;
			return soap_in__ns3__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CloseViewerRequest"))
		{	*type = SOAP_TYPE__ns2__CloseViewerRequest;
			return soap_in__ns2__CloseViewerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ActivateViewerRequest"))
		{	*type = SOAP_TYPE__ns2__ActivateViewerRequest;
			return soap_in__ns2__ActivateViewerRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudiesFault"))
		{	*type = SOAP_TYPE__ns2__OpenStudiesFault;
			return soap_in__ns2__OpenStudiesFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudiesResult"))
		{	*type = SOAP_TYPE__ns2__OpenStudiesResult;
			return soap_in__ns2__OpenStudiesResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudyInfo"))
		{	*type = SOAP_TYPE__ns2__OpenStudyInfo;
			return soap_in__ns2__OpenStudyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArrayOfOpenStudyInfo"))
		{	*type = SOAP_TYPE__ns2__ArrayOfOpenStudyInfo;
			return soap_in__ns2__ArrayOfOpenStudyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudiesRequest"))
		{	*type = SOAP_TYPE__ns2__OpenStudiesRequest;
			return soap_in__ns2__OpenStudiesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ViewerNotFoundFault"))
		{	*type = SOAP_TYPE__ns2__ViewerNotFoundFault;
			return soap_in__ns2__ViewerNotFoundFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewerInfoResult"))
		{	*type = SOAP_TYPE__ns2__GetViewerInfoResult;
			return soap_in__ns2__GetViewerInfoResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewerInfoRequest"))
		{	*type = SOAP_TYPE__ns2__GetViewerInfoRequest;
			return soap_in__ns2__GetViewerInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NoActiveViewersFault"))
		{	*type = SOAP_TYPE__ns2__NoActiveViewersFault;
			return soap_in__ns2__NoActiveViewersFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetActiveViewersResult"))
		{	*type = SOAP_TYPE__ns2__GetActiveViewersResult;
			return soap_in__ns2__GetActiveViewersResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NoViewersFault"))
		{	*type = SOAP_TYPE__ns2__NoViewersFault;
			return soap_in__ns2__NoViewersFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ArrayOfViewer"))
		{	*type = SOAP_TYPE__ns2__ArrayOfViewer;
			return soap_in__ns2__ArrayOfViewer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewersResult"))
		{	*type = SOAP_TYPE__ns2__GetViewersResult;
			return soap_in__ns2__GetViewersResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewersRequest"))
		{	*type = SOAP_TYPE__ns2__GetViewersRequest;
			return soap_in__ns2__GetViewersRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenFilesFault"))
		{	*type = SOAP_TYPE__ns2__OpenFilesFault;
			return soap_in__ns2__OpenFilesFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Viewer"))
		{	*type = SOAP_TYPE__ns2__Viewer;
			return soap_in__ns2__Viewer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenFilesResult"))
		{	*type = SOAP_TYPE__ns2__OpenFilesResult;
			return soap_in__ns2__OpenFilesResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenFilesRequest"))
		{	*type = SOAP_TYPE__ns2__OpenFilesRequest;
			return soap_in__ns2__OpenFilesRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ImageQueryResponse"))
		{	*type = SOAP_TYPE__ns5__ImageQueryResponse;
			return soap_in__ns5__ImageQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ImageQuery"))
		{	*type = SOAP_TYPE__ns5__ImageQuery;
			return soap_in__ns5__ImageQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SeriesQueryResponse"))
		{	*type = SOAP_TYPE__ns5__SeriesQueryResponse;
			return soap_in__ns5__SeriesQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:SeriesQuery"))
		{	*type = SOAP_TYPE__ns5__SeriesQuery;
			return soap_in__ns5__SeriesQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:StudyQueryResponse"))
		{	*type = SOAP_TYPE__ns5__StudyQueryResponse;
			return soap_in__ns5__StudyQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:StudyQuery"))
		{	*type = SOAP_TYPE__ns5__StudyQuery;
			return soap_in__ns5__StudyQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CloseViewerResponse"))
		{	*type = SOAP_TYPE__ns2__CloseViewerResponse;
			return soap_in__ns2__CloseViewerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CloseViewer"))
		{	*type = SOAP_TYPE__ns2__CloseViewer;
			return soap_in__ns2__CloseViewer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ActivateViewerResponse"))
		{	*type = SOAP_TYPE__ns2__ActivateViewerResponse;
			return soap_in__ns2__ActivateViewerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ActivateViewer"))
		{	*type = SOAP_TYPE__ns2__ActivateViewer;
			return soap_in__ns2__ActivateViewer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudiesResponse"))
		{	*type = SOAP_TYPE__ns2__OpenStudiesResponse;
			return soap_in__ns2__OpenStudiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenStudies"))
		{	*type = SOAP_TYPE__ns2__OpenStudies;
			return soap_in__ns2__OpenStudies(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewerInfoResponse"))
		{	*type = SOAP_TYPE__ns2__GetViewerInfoResponse;
			return soap_in__ns2__GetViewerInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewerInfo"))
		{	*type = SOAP_TYPE__ns2__GetViewerInfo;
			return soap_in__ns2__GetViewerInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetActiveViewersResponse"))
		{	*type = SOAP_TYPE__ns2__GetActiveViewersResponse;
			return soap_in__ns2__GetActiveViewersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetActiveViewers"))
		{	*type = SOAP_TYPE__ns2__GetActiveViewers;
			return soap_in__ns2__GetActiveViewers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewersResponse"))
		{	*type = SOAP_TYPE__ns2__GetViewersResponse;
			return soap_in__ns2__GetViewersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:GetViewers"))
		{	*type = SOAP_TYPE__ns2__GetViewers;
			return soap_in__ns2__GetViewers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenFilesResponse"))
		{	*type = SOAP_TYPE__ns2__OpenFilesResponse;
			return soap_in__ns2__OpenFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:OpenFiles"))
		{	*type = SOAP_TYPE__ns2__OpenFiles;
			return soap_in__ns2__OpenFiles(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE__ns3__byte:
		return soap_out__ns3__byte(soap, "ns3:byte", id, (const char *)ptr, NULL);
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE__ns3__short:
		return soap_out__ns3__short(soap, "ns3:short", id, (const short *)ptr, NULL);
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE__ns3__char:
		return soap_out__ns3__char(soap, "ns3:char", id, (const int *)ptr, NULL);
	case SOAP_TYPE__ns3__int:
		return soap_out__ns3__int(soap, "ns3:int", id, (const int *)ptr, NULL);
	case SOAP_TYPE_ns3__char:
		return soap_out_ns3__char(soap, tag, id, (const int *)ptr, "ns3:char");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__ns3__long:
		return soap_out__ns3__long(soap, "ns3:long", id, (const LONG64 *)ptr, NULL);
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE__ns3__float:
		return soap_out__ns3__float(soap, "ns3:float", id, (const float *)ptr, NULL);
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE__ns3__double:
		return soap_out__ns3__double(soap, "ns3:double", id, (const double *)ptr, NULL);
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE__ns3__unsignedByte:
		return soap_out__ns3__unsignedByte(soap, "ns3:unsignedByte", id, (const unsigned char *)ptr, NULL);
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_out_xsd__unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__ns3__unsignedShort:
		return soap_out__ns3__unsignedShort(soap, "ns3:unsignedShort", id, (const unsigned short *)ptr, NULL);
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE__ns3__unsignedInt:
		return soap_out__ns3__unsignedInt(soap, "ns3:unsignedInt", id, (const unsigned int *)ptr, NULL);
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__ns3__unsignedLong:
		return soap_out__ns3__unsignedLong(soap, "ns3:unsignedLong", id, (const ULONG64 *)ptr, NULL);
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE__ns3__dateTime:
		return soap_out__ns3__dateTime(soap, "ns3:dateTime", id, (const time_t *)ptr, NULL);
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE__ns3__boolean:
		return soap_out__ns3__boolean(soap, "ns3:boolean", id, (const bool *)ptr, NULL);
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns6__StudyOfflineFault:
		return soap_out__ns6__StudyOfflineFault(soap, "ns6:StudyOfflineFault", id, (const ns6__StudyOfflineFault *)ptr, NULL);
	case SOAP_TYPE__ns6__StudyInUseFault:
		return soap_out__ns6__StudyInUseFault(soap, "ns6:StudyInUseFault", id, (const ns6__StudyInUseFault *)ptr, NULL);
	case SOAP_TYPE__ns6__StudyNotFoundFault:
		return soap_out__ns6__StudyNotFoundFault(soap, "ns6:StudyNotFoundFault", id, (const ns6__StudyNotFoundFault *)ptr, NULL);
	case SOAP_TYPE__ns6__StudyNearlineFault:
		return soap_out__ns6__StudyNearlineFault(soap, "ns6:StudyNearlineFault", id, (const ns6__StudyNearlineFault *)ptr, NULL);
	case SOAP_TYPE__ns5__ArrayOfImageIdentifier:
		return soap_out__ns5__ArrayOfImageIdentifier(soap, "ns5:ArrayOfImageIdentifier", id, (const ns5__ArrayOfImageIdentifier *)ptr, NULL);
	case SOAP_TYPE__ns5__ImageIdentifier:
		return soap_out__ns5__ImageIdentifier(soap, "ns5:ImageIdentifier", id, (const ns5__ImageIdentifier *)ptr, NULL);
	case SOAP_TYPE__ns5__ArrayOfSeriesIdentifier:
		return soap_out__ns5__ArrayOfSeriesIdentifier(soap, "ns5:ArrayOfSeriesIdentifier", id, (const ns5__ArrayOfSeriesIdentifier *)ptr, NULL);
	case SOAP_TYPE__ns5__SeriesIdentifier:
		return soap_out__ns5__SeriesIdentifier(soap, "ns5:SeriesIdentifier", id, (const ns5__SeriesIdentifier *)ptr, NULL);
	case SOAP_TYPE__ns5__DataValidationFault:
		return soap_out__ns5__DataValidationFault(soap, "ns5:DataValidationFault", id, (const ns5__DataValidationFault *)ptr, NULL);
	case SOAP_TYPE__ns5__QueryFailedFault:
		return soap_out__ns5__QueryFailedFault(soap, "ns5:QueryFailedFault", id, (const ns5__QueryFailedFault *)ptr, NULL);
	case SOAP_TYPE__ns5__ArrayOfStudyRootStudyIdentifier:
		return soap_out__ns5__ArrayOfStudyRootStudyIdentifier(soap, "ns5:ArrayOfStudyRootStudyIdentifier", id, (const ns5__ArrayOfStudyRootStudyIdentifier *)ptr, NULL);
	case SOAP_TYPE__ns5__Identifier:
		return soap_out__ns5__Identifier(soap, "ns5:Identifier", id, (const ns5__Identifier *)ptr, NULL);
	case SOAP_TYPE__ns5__StudyIdentifier:
		return soap_out__ns5__StudyIdentifier(soap, "ns5:StudyIdentifier", id, (const ns5__StudyIdentifier *)ptr, NULL);
	case SOAP_TYPE__ns5__StudyRootStudyIdentifier:
		return soap_out__ns5__StudyRootStudyIdentifier(soap, "ns5:StudyRootStudyIdentifier", id, (const ns5__StudyRootStudyIdentifier *)ptr, NULL);
	case SOAP_TYPE__ns4__ArrayOfstring:
		return soap_out__ns4__ArrayOfstring(soap, "ns4:ArrayOfstring", id, (const ns4__ArrayOfstring *)ptr, NULL);
	case SOAP_TYPE__ns3__Ref:
		return soap_out__ns3__Ref(soap, "ns3:Ref", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__Id:
		return soap_out__ns3__Id(soap, "ns3:Id", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__FactoryType:
		return soap_out__ns3__FactoryType(soap, "ns3:FactoryType", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__guid:
		return soap_out__ns3__guid(soap, "ns3:guid", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__duration:
		return soap_out__ns3__duration(soap, "ns3:duration", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__string:
		return soap_out__ns3__string(soap, "ns3:string", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__QName:
		return soap_out__ns3__QName(soap, "ns3:QName", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__decimal:
		return soap_out__ns3__decimal(soap, "ns3:decimal", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__base64Binary:
		return soap_out__ns3__base64Binary(soap, "ns3:base64Binary", id, (const xsd__base64Binary *)ptr, NULL);
	case SOAP_TYPE__ns3__anyURI:
		return soap_out__ns3__anyURI(soap, "ns3:anyURI", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE__ns3__anyType:
		return soap_out__ns3__anyType(soap, "ns3:anyType", id, (const xsd__anyType *)ptr, NULL);
	case SOAP_TYPE__ns2__CloseViewerRequest:
		return soap_out__ns2__CloseViewerRequest(soap, "ns2:CloseViewerRequest", id, (const ns2__CloseViewerRequest *)ptr, NULL);
	case SOAP_TYPE__ns2__ActivateViewerRequest:
		return soap_out__ns2__ActivateViewerRequest(soap, "ns2:ActivateViewerRequest", id, (const ns2__ActivateViewerRequest *)ptr, NULL);
	case SOAP_TYPE__ns2__OpenStudiesFault:
		return soap_out__ns2__OpenStudiesFault(soap, "ns2:OpenStudiesFault", id, (const ns2__OpenStudiesFault *)ptr, NULL);
	case SOAP_TYPE__ns2__OpenStudiesResult:
		return soap_out__ns2__OpenStudiesResult(soap, "ns2:OpenStudiesResult", id, (const ns2__OpenStudiesResult *)ptr, NULL);
	case SOAP_TYPE__ns2__OpenStudyInfo:
		return soap_out__ns2__OpenStudyInfo(soap, "ns2:OpenStudyInfo", id, (const ns2__OpenStudyInfo *)ptr, NULL);
	case SOAP_TYPE__ns2__ArrayOfOpenStudyInfo:
		return soap_out__ns2__ArrayOfOpenStudyInfo(soap, "ns2:ArrayOfOpenStudyInfo", id, (const ns2__ArrayOfOpenStudyInfo *)ptr, NULL);
	case SOAP_TYPE__ns2__OpenStudiesRequest:
		return soap_out__ns2__OpenStudiesRequest(soap, "ns2:OpenStudiesRequest", id, (const ns2__OpenStudiesRequest *)ptr, NULL);
	case SOAP_TYPE__ns2__ViewerNotFoundFault:
		return soap_out__ns2__ViewerNotFoundFault(soap, "ns2:ViewerNotFoundFault", id, (const ns2__ViewerNotFoundFault *)ptr, NULL);
	case SOAP_TYPE__ns2__GetViewerInfoResult:
		return soap_out__ns2__GetViewerInfoResult(soap, "ns2:GetViewerInfoResult", id, (const ns2__GetViewerInfoResult *)ptr, NULL);
	case SOAP_TYPE__ns2__GetViewerInfoRequest:
		return soap_out__ns2__GetViewerInfoRequest(soap, "ns2:GetViewerInfoRequest", id, (const ns2__GetViewerInfoRequest *)ptr, NULL);
	case SOAP_TYPE__ns2__NoActiveViewersFault:
		return soap_out__ns2__NoActiveViewersFault(soap, "ns2:NoActiveViewersFault", id, (const ns2__NoActiveViewersFault *)ptr, NULL);
	case SOAP_TYPE__ns2__GetActiveViewersResult:
		return soap_out__ns2__GetActiveViewersResult(soap, "ns2:GetActiveViewersResult", id, (const ns2__GetActiveViewersResult *)ptr, NULL);
	case SOAP_TYPE__ns2__NoViewersFault:
		return soap_out__ns2__NoViewersFault(soap, "ns2:NoViewersFault", id, (const ns2__NoViewersFault *)ptr, NULL);
	case SOAP_TYPE__ns2__ArrayOfViewer:
		return soap_out__ns2__ArrayOfViewer(soap, "ns2:ArrayOfViewer", id, (const ns2__ArrayOfViewer *)ptr, NULL);
	case SOAP_TYPE__ns2__GetViewersResult:
		return soap_out__ns2__GetViewersResult(soap, "ns2:GetViewersResult", id, (const ns2__GetViewersResult *)ptr, NULL);
	case SOAP_TYPE__ns2__GetViewersRequest:
		return soap_out__ns2__GetViewersRequest(soap, "ns2:GetViewersRequest", id, (const ns2__GetViewersRequest *)ptr, NULL);
	case SOAP_TYPE__ns2__OpenFilesFault:
		return soap_out__ns2__OpenFilesFault(soap, "ns2:OpenFilesFault", id, (const ns2__OpenFilesFault *)ptr, NULL);
	case SOAP_TYPE__ns2__Viewer:
		return soap_out__ns2__Viewer(soap, "ns2:Viewer", id, (const ns2__Viewer *)ptr, NULL);
	case SOAP_TYPE__ns2__OpenFilesResult:
		return soap_out__ns2__OpenFilesResult(soap, "ns2:OpenFilesResult", id, (const ns2__OpenFilesResult *)ptr, NULL);
	case SOAP_TYPE__ns2__OpenFilesRequest:
		return soap_out__ns2__OpenFilesRequest(soap, "ns2:OpenFilesRequest", id, (const ns2__OpenFilesRequest *)ptr, NULL);
	case SOAP_TYPE_ns3__guid__:
		return ((ns3__guid__ *)ptr)->soap_out(soap, tag, id, "ns3:guid");
	case SOAP_TYPE_ns3__guid:
		return soap_out_ns3__guid(soap, tag, id, (const std::string *)ptr, "ns3:guid");
	case SOAP_TYPE_ns3__duration__:
		return ((ns3__duration__ *)ptr)->soap_out(soap, tag, id, "ns3:duration");
	case SOAP_TYPE_ns3__duration:
		return soap_out_ns3__duration(soap, tag, id, (const std::string *)ptr, "ns3:duration");
	case SOAP_TYPE_ns3__char__:
		return ((ns3__char__ *)ptr)->soap_out(soap, tag, id, "ns3:char");
	case SOAP_TYPE_ns6__StudyOfflineFault:
		return ((ns6__StudyOfflineFault *)ptr)->soap_out(soap, tag, id, "ns6:StudyOfflineFault");
	case SOAP_TYPE_ns6__StudyInUseFault:
		return ((ns6__StudyInUseFault *)ptr)->soap_out(soap, tag, id, "ns6:StudyInUseFault");
	case SOAP_TYPE_ns6__StudyNotFoundFault:
		return ((ns6__StudyNotFoundFault *)ptr)->soap_out(soap, tag, id, "ns6:StudyNotFoundFault");
	case SOAP_TYPE_ns6__StudyNearlineFault:
		return ((ns6__StudyNearlineFault *)ptr)->soap_out(soap, tag, id, "ns6:StudyNearlineFault");
	case SOAP_TYPE__ns5__ImageQueryResponse:
		return ((_ns5__ImageQueryResponse *)ptr)->soap_out(soap, "ns5:ImageQueryResponse", id, NULL);
	case SOAP_TYPE__ns5__ImageQuery:
		return ((_ns5__ImageQuery *)ptr)->soap_out(soap, "ns5:ImageQuery", id, NULL);
	case SOAP_TYPE__ns5__SeriesQueryResponse:
		return ((_ns5__SeriesQueryResponse *)ptr)->soap_out(soap, "ns5:SeriesQueryResponse", id, NULL);
	case SOAP_TYPE__ns5__SeriesQuery:
		return ((_ns5__SeriesQuery *)ptr)->soap_out(soap, "ns5:SeriesQuery", id, NULL);
	case SOAP_TYPE__ns5__StudyQueryResponse:
		return ((_ns5__StudyQueryResponse *)ptr)->soap_out(soap, "ns5:StudyQueryResponse", id, NULL);
	case SOAP_TYPE__ns5__StudyQuery:
		return ((_ns5__StudyQuery *)ptr)->soap_out(soap, "ns5:StudyQuery", id, NULL);
	case SOAP_TYPE_ns5__ArrayOfImageIdentifier:
		return ((ns5__ArrayOfImageIdentifier *)ptr)->soap_out(soap, tag, id, "ns5:ArrayOfImageIdentifier");
	case SOAP_TYPE_ns5__ImageIdentifier:
		return ((ns5__ImageIdentifier *)ptr)->soap_out(soap, tag, id, "ns5:ImageIdentifier");
	case SOAP_TYPE_ns5__ArrayOfSeriesIdentifier:
		return ((ns5__ArrayOfSeriesIdentifier *)ptr)->soap_out(soap, tag, id, "ns5:ArrayOfSeriesIdentifier");
	case SOAP_TYPE_ns5__SeriesIdentifier:
		return ((ns5__SeriesIdentifier *)ptr)->soap_out(soap, tag, id, "ns5:SeriesIdentifier");
	case SOAP_TYPE_ns5__DataValidationFault:
		return ((ns5__DataValidationFault *)ptr)->soap_out(soap, tag, id, "ns5:DataValidationFault");
	case SOAP_TYPE_ns5__QueryFailedFault:
		return ((ns5__QueryFailedFault *)ptr)->soap_out(soap, tag, id, "ns5:QueryFailedFault");
	case SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier:
		return ((ns5__ArrayOfStudyRootStudyIdentifier *)ptr)->soap_out(soap, tag, id, "ns5:ArrayOfStudyRootStudyIdentifier");
	case SOAP_TYPE_ns5__Identifier:
		return ((ns5__Identifier *)ptr)->soap_out(soap, tag, id, "ns5:Identifier");
	case SOAP_TYPE_ns5__StudyIdentifier:
		return ((ns5__StudyIdentifier *)ptr)->soap_out(soap, tag, id, "ns5:StudyIdentifier");
	case SOAP_TYPE_ns5__StudyRootStudyIdentifier:
		return ((ns5__StudyRootStudyIdentifier *)ptr)->soap_out(soap, tag, id, "ns5:StudyRootStudyIdentifier");
	case SOAP_TYPE_ns4__ArrayOfstring:
		return ((ns4__ArrayOfstring *)ptr)->soap_out(soap, tag, id, "ns4:ArrayOfstring");
	case SOAP_TYPE__ns2__CloseViewerResponse:
		return ((_ns2__CloseViewerResponse *)ptr)->soap_out(soap, "ns2:CloseViewerResponse", id, NULL);
	case SOAP_TYPE__ns2__CloseViewer:
		return ((_ns2__CloseViewer *)ptr)->soap_out(soap, "ns2:CloseViewer", id, NULL);
	case SOAP_TYPE__ns2__ActivateViewerResponse:
		return ((_ns2__ActivateViewerResponse *)ptr)->soap_out(soap, "ns2:ActivateViewerResponse", id, NULL);
	case SOAP_TYPE__ns2__ActivateViewer:
		return ((_ns2__ActivateViewer *)ptr)->soap_out(soap, "ns2:ActivateViewer", id, NULL);
	case SOAP_TYPE__ns2__OpenStudiesResponse:
		return ((_ns2__OpenStudiesResponse *)ptr)->soap_out(soap, "ns2:OpenStudiesResponse", id, NULL);
	case SOAP_TYPE__ns2__OpenStudies:
		return ((_ns2__OpenStudies *)ptr)->soap_out(soap, "ns2:OpenStudies", id, NULL);
	case SOAP_TYPE__ns2__GetViewerInfoResponse:
		return ((_ns2__GetViewerInfoResponse *)ptr)->soap_out(soap, "ns2:GetViewerInfoResponse", id, NULL);
	case SOAP_TYPE__ns2__GetViewerInfo:
		return ((_ns2__GetViewerInfo *)ptr)->soap_out(soap, "ns2:GetViewerInfo", id, NULL);
	case SOAP_TYPE__ns2__GetActiveViewersResponse:
		return ((_ns2__GetActiveViewersResponse *)ptr)->soap_out(soap, "ns2:GetActiveViewersResponse", id, NULL);
	case SOAP_TYPE__ns2__GetActiveViewers:
		return ((_ns2__GetActiveViewers *)ptr)->soap_out(soap, "ns2:GetActiveViewers", id, NULL);
	case SOAP_TYPE__ns2__GetViewersResponse:
		return ((_ns2__GetViewersResponse *)ptr)->soap_out(soap, "ns2:GetViewersResponse", id, NULL);
	case SOAP_TYPE__ns2__GetViewers:
		return ((_ns2__GetViewers *)ptr)->soap_out(soap, "ns2:GetViewers", id, NULL);
	case SOAP_TYPE__ns2__OpenFilesResponse:
		return ((_ns2__OpenFilesResponse *)ptr)->soap_out(soap, "ns2:OpenFilesResponse", id, NULL);
	case SOAP_TYPE__ns2__OpenFiles:
		return ((_ns2__OpenFiles *)ptr)->soap_out(soap, "ns2:OpenFiles", id, NULL);
	case SOAP_TYPE_ns2__CloseViewerRequest:
		return ((ns2__CloseViewerRequest *)ptr)->soap_out(soap, tag, id, "ns2:CloseViewerRequest");
	case SOAP_TYPE_ns2__ActivateViewerRequest:
		return ((ns2__ActivateViewerRequest *)ptr)->soap_out(soap, tag, id, "ns2:ActivateViewerRequest");
	case SOAP_TYPE_ns2__OpenStudiesFault:
		return ((ns2__OpenStudiesFault *)ptr)->soap_out(soap, tag, id, "ns2:OpenStudiesFault");
	case SOAP_TYPE_ns2__OpenStudiesResult:
		return ((ns2__OpenStudiesResult *)ptr)->soap_out(soap, tag, id, "ns2:OpenStudiesResult");
	case SOAP_TYPE_ns2__OpenStudyInfo:
		return ((ns2__OpenStudyInfo *)ptr)->soap_out(soap, tag, id, "ns2:OpenStudyInfo");
	case SOAP_TYPE_ns2__ArrayOfOpenStudyInfo:
		return ((ns2__ArrayOfOpenStudyInfo *)ptr)->soap_out(soap, tag, id, "ns2:ArrayOfOpenStudyInfo");
	case SOAP_TYPE_ns2__OpenStudiesRequest:
		return ((ns2__OpenStudiesRequest *)ptr)->soap_out(soap, tag, id, "ns2:OpenStudiesRequest");
	case SOAP_TYPE_ns2__ViewerNotFoundFault:
		return ((ns2__ViewerNotFoundFault *)ptr)->soap_out(soap, tag, id, "ns2:ViewerNotFoundFault");
	case SOAP_TYPE_ns2__GetViewerInfoResult:
		return ((ns2__GetViewerInfoResult *)ptr)->soap_out(soap, tag, id, "ns2:GetViewerInfoResult");
	case SOAP_TYPE_ns2__GetViewerInfoRequest:
		return ((ns2__GetViewerInfoRequest *)ptr)->soap_out(soap, tag, id, "ns2:GetViewerInfoRequest");
	case SOAP_TYPE_ns2__NoActiveViewersFault:
		return ((ns2__NoActiveViewersFault *)ptr)->soap_out(soap, tag, id, "ns2:NoActiveViewersFault");
	case SOAP_TYPE_ns2__GetActiveViewersResult:
		return ((ns2__GetActiveViewersResult *)ptr)->soap_out(soap, tag, id, "ns2:GetActiveViewersResult");
	case SOAP_TYPE_ns2__NoViewersFault:
		return ((ns2__NoViewersFault *)ptr)->soap_out(soap, tag, id, "ns2:NoViewersFault");
	case SOAP_TYPE_ns2__ArrayOfViewer:
		return ((ns2__ArrayOfViewer *)ptr)->soap_out(soap, tag, id, "ns2:ArrayOfViewer");
	case SOAP_TYPE_ns2__GetViewersResult:
		return ((ns2__GetViewersResult *)ptr)->soap_out(soap, tag, id, "ns2:GetViewersResult");
	case SOAP_TYPE_ns2__GetViewersRequest:
		return ((ns2__GetViewersRequest *)ptr)->soap_out(soap, tag, id, "ns2:GetViewersRequest");
	case SOAP_TYPE_ns2__OpenFilesFault:
		return ((ns2__OpenFilesFault *)ptr)->soap_out(soap, tag, id, "ns2:OpenFilesFault");
	case SOAP_TYPE_ns2__Viewer:
		return ((ns2__Viewer *)ptr)->soap_out(soap, tag, id, "ns2:Viewer");
	case SOAP_TYPE_ns2__OpenFilesResult:
		return ((ns2__OpenFilesResult *)ptr)->soap_out(soap, tag, id, "ns2:OpenFilesResult");
	case SOAP_TYPE_ns2__OpenFilesRequest:
		return ((ns2__OpenFilesRequest *)ptr)->soap_out(soap, tag, id, "ns2:OpenFilesRequest");
	case SOAP_TYPE_xsd__unsignedShort:
		return ((xsd__unsignedShort *)ptr)->soap_out(soap, tag, id, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedLong:
		return ((xsd__unsignedLong *)ptr)->soap_out(soap, tag, id, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedInt:
		return ((xsd__unsignedInt *)ptr)->soap_out(soap, tag, id, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedByte_:
		return ((xsd__unsignedByte_ *)ptr)->soap_out(soap, tag, id, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__short:
		return ((xsd__short *)ptr)->soap_out(soap, tag, id, "xsd:short");
	case SOAP_TYPE_xsd__long:
		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__float:
		return ((xsd__float *)ptr)->soap_out(soap, tag, id, "xsd:float");
	case SOAP_TYPE_xsd__duration_:
		return ((xsd__duration_ *)ptr)->soap_out(soap, tag, id, "xsd:duration");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const std::string *)ptr, "xsd:duration");
	case SOAP_TYPE_xsd__double:
		return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__decimal_:
		return ((xsd__decimal_ *)ptr)->soap_out(soap, tag, id, "xsd:decimal");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__byte_:
		return ((xsd__byte_ *)ptr)->soap_out(soap, tag, id, "xsd:byte");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__base64Binary_:
		return ((xsd__base64Binary_ *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI_:
		return ((xsd__anyURI_ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName_:
		return ((xsd__QName_ *)ptr)->soap_out(soap, tag, id, "xsd:QName");
	case SOAP_TYPE_xsd__IDREF_:
		return ((xsd__IDREF_ *)ptr)->soap_out(soap, tag, id, "xsd:IDREF");
	case SOAP_TYPE_xsd__IDREF:
		return soap_out_xsd__IDREF(soap, tag, id, (const std::string *)ptr, "xsd:IDREF");
	case SOAP_TYPE_xsd__ID_:
		return ((xsd__ID_ *)ptr)->soap_out(soap, tag, id, "xsd:ID");
	case SOAP_TYPE_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_PointerTo_ns5__ImageQueryResponse:
		return soap_out_PointerTo_ns5__ImageQueryResponse(soap, tag, id, (_ns5__ImageQueryResponse *const*)ptr, "ns5:ImageQueryResponse");
	case SOAP_TYPE_PointerTo_ns5__ImageQuery:
		return soap_out_PointerTo_ns5__ImageQuery(soap, tag, id, (_ns5__ImageQuery *const*)ptr, "ns5:ImageQuery");
	case SOAP_TYPE_PointerTo_ns5__SeriesQueryResponse:
		return soap_out_PointerTo_ns5__SeriesQueryResponse(soap, tag, id, (_ns5__SeriesQueryResponse *const*)ptr, "ns5:SeriesQueryResponse");
	case SOAP_TYPE_PointerTo_ns5__SeriesQuery:
		return soap_out_PointerTo_ns5__SeriesQuery(soap, tag, id, (_ns5__SeriesQuery *const*)ptr, "ns5:SeriesQuery");
	case SOAP_TYPE_PointerTo_ns5__StudyQueryResponse:
		return soap_out_PointerTo_ns5__StudyQueryResponse(soap, tag, id, (_ns5__StudyQueryResponse *const*)ptr, "ns5:StudyQueryResponse");
	case SOAP_TYPE_PointerTo_ns5__StudyQuery:
		return soap_out_PointerTo_ns5__StudyQuery(soap, tag, id, (_ns5__StudyQuery *const*)ptr, "ns5:StudyQuery");
	case SOAP_TYPE_PointerTo_ns2__CloseViewerResponse:
		return soap_out_PointerTo_ns2__CloseViewerResponse(soap, tag, id, (_ns2__CloseViewerResponse *const*)ptr, "ns2:CloseViewerResponse");
	case SOAP_TYPE_PointerTo_ns2__CloseViewer:
		return soap_out_PointerTo_ns2__CloseViewer(soap, tag, id, (_ns2__CloseViewer *const*)ptr, "ns2:CloseViewer");
	case SOAP_TYPE_PointerTo_ns2__ActivateViewerResponse:
		return soap_out_PointerTo_ns2__ActivateViewerResponse(soap, tag, id, (_ns2__ActivateViewerResponse *const*)ptr, "ns2:ActivateViewerResponse");
	case SOAP_TYPE_PointerTo_ns2__ActivateViewer:
		return soap_out_PointerTo_ns2__ActivateViewer(soap, tag, id, (_ns2__ActivateViewer *const*)ptr, "ns2:ActivateViewer");
	case SOAP_TYPE_PointerTo_ns2__OpenStudiesResponse:
		return soap_out_PointerTo_ns2__OpenStudiesResponse(soap, tag, id, (_ns2__OpenStudiesResponse *const*)ptr, "ns2:OpenStudiesResponse");
	case SOAP_TYPE_PointerTo_ns2__OpenStudies:
		return soap_out_PointerTo_ns2__OpenStudies(soap, tag, id, (_ns2__OpenStudies *const*)ptr, "ns2:OpenStudies");
	case SOAP_TYPE_PointerTo_ns2__GetViewerInfoResponse:
		return soap_out_PointerTo_ns2__GetViewerInfoResponse(soap, tag, id, (_ns2__GetViewerInfoResponse *const*)ptr, "ns2:GetViewerInfoResponse");
	case SOAP_TYPE_PointerTo_ns2__GetViewerInfo:
		return soap_out_PointerTo_ns2__GetViewerInfo(soap, tag, id, (_ns2__GetViewerInfo *const*)ptr, "ns2:GetViewerInfo");
	case SOAP_TYPE_PointerTo_ns2__GetActiveViewersResponse:
		return soap_out_PointerTo_ns2__GetActiveViewersResponse(soap, tag, id, (_ns2__GetActiveViewersResponse *const*)ptr, "ns2:GetActiveViewersResponse");
	case SOAP_TYPE_PointerTo_ns2__GetActiveViewers:
		return soap_out_PointerTo_ns2__GetActiveViewers(soap, tag, id, (_ns2__GetActiveViewers *const*)ptr, "ns2:GetActiveViewers");
	case SOAP_TYPE_PointerTo_ns2__GetViewersResponse:
		return soap_out_PointerTo_ns2__GetViewersResponse(soap, tag, id, (_ns2__GetViewersResponse *const*)ptr, "ns2:GetViewersResponse");
	case SOAP_TYPE_PointerTo_ns2__GetViewers:
		return soap_out_PointerTo_ns2__GetViewers(soap, tag, id, (_ns2__GetViewers *const*)ptr, "ns2:GetViewers");
	case SOAP_TYPE_PointerTo_ns2__OpenFilesResponse:
		return soap_out_PointerTo_ns2__OpenFilesResponse(soap, tag, id, (_ns2__OpenFilesResponse *const*)ptr, "ns2:OpenFilesResponse");
	case SOAP_TYPE_PointerTo_ns2__OpenFiles:
		return soap_out_PointerTo_ns2__OpenFiles(soap, tag, id, (_ns2__OpenFiles *const*)ptr, "ns2:OpenFiles");
	case SOAP_TYPE_PointerTons6__StudyOfflineFault:
		return soap_out_PointerTons6__StudyOfflineFault(soap, tag, id, (ns6__StudyOfflineFault *const*)ptr, "ns6:StudyOfflineFault");
	case SOAP_TYPE_PointerTons6__StudyNotFoundFault:
		return soap_out_PointerTons6__StudyNotFoundFault(soap, tag, id, (ns6__StudyNotFoundFault *const*)ptr, "ns6:StudyNotFoundFault");
	case SOAP_TYPE_PointerTons6__StudyNearlineFault:
		return soap_out_PointerTons6__StudyNearlineFault(soap, tag, id, (ns6__StudyNearlineFault *const*)ptr, "ns6:StudyNearlineFault");
	case SOAP_TYPE_PointerTons6__StudyInUseFault:
		return soap_out_PointerTons6__StudyInUseFault(soap, tag, id, (ns6__StudyInUseFault *const*)ptr, "ns6:StudyInUseFault");
	case SOAP_TYPE_PointerTons2__OpenStudiesFault:
		return soap_out_PointerTons2__OpenStudiesFault(soap, tag, id, (ns2__OpenStudiesFault *const*)ptr, "ns2:OpenStudiesFault");
	case SOAP_TYPE_PointerTons2__OpenFilesFault:
		return soap_out_PointerTons2__OpenFilesFault(soap, tag, id, (ns2__OpenFilesFault *const*)ptr, "ns2:OpenFilesFault");
	case SOAP_TYPE_PointerTons2__NoViewersFault:
		return soap_out_PointerTons2__NoViewersFault(soap, tag, id, (ns2__NoViewersFault *const*)ptr, "ns2:NoViewersFault");
	case SOAP_TYPE_PointerTons2__NoActiveViewersFault:
		return soap_out_PointerTons2__NoActiveViewersFault(soap, tag, id, (ns2__NoActiveViewersFault *const*)ptr, "ns2:NoActiveViewersFault");
	case SOAP_TYPE_PointerTons2__ViewerNotFoundFault:
		return soap_out_PointerTons2__ViewerNotFoundFault(soap, tag, id, (ns2__ViewerNotFoundFault *const*)ptr, "ns2:ViewerNotFoundFault");
	case SOAP_TYPE_PointerTons5__QueryFailedFault:
		return soap_out_PointerTons5__QueryFailedFault(soap, tag, id, (ns5__QueryFailedFault *const*)ptr, "ns5:QueryFailedFault");
	case SOAP_TYPE_PointerTons5__DataValidationFault:
		return soap_out_PointerTons5__DataValidationFault(soap, tag, id, (ns5__DataValidationFault *const*)ptr, "ns5:DataValidationFault");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTons5__ArrayOfImageIdentifier:
		return soap_out_PointerTons5__ArrayOfImageIdentifier(soap, tag, id, (ns5__ArrayOfImageIdentifier *const*)ptr, "ns5:ArrayOfImageIdentifier");
	case SOAP_TYPE_PointerTons5__ArrayOfSeriesIdentifier:
		return soap_out_PointerTons5__ArrayOfSeriesIdentifier(soap, tag, id, (ns5__ArrayOfSeriesIdentifier *const*)ptr, "ns5:ArrayOfSeriesIdentifier");
	case SOAP_TYPE_PointerTons5__ArrayOfStudyRootStudyIdentifier:
		return soap_out_PointerTons5__ArrayOfStudyRootStudyIdentifier(soap, tag, id, (ns5__ArrayOfStudyRootStudyIdentifier *const*)ptr, "ns5:ArrayOfStudyRootStudyIdentifier");
	case SOAP_TYPE_PointerTons5__ImageIdentifier:
		return soap_out_PointerTons5__ImageIdentifier(soap, tag, id, (ns5__ImageIdentifier *const*)ptr, "ns5:ImageIdentifier");
	case SOAP_TYPE_PointerTons5__SeriesIdentifier:
		return soap_out_PointerTons5__SeriesIdentifier(soap, tag, id, (ns5__SeriesIdentifier *const*)ptr, "ns5:SeriesIdentifier");
	case SOAP_TYPE_PointerTons2__CloseViewerRequest:
		return soap_out_PointerTons2__CloseViewerRequest(soap, tag, id, (ns2__CloseViewerRequest *const*)ptr, "ns2:CloseViewerRequest");
	case SOAP_TYPE_PointerTons2__ActivateViewerRequest:
		return soap_out_PointerTons2__ActivateViewerRequest(soap, tag, id, (ns2__ActivateViewerRequest *const*)ptr, "ns2:ActivateViewerRequest");
	case SOAP_TYPE_PointerTons2__OpenStudiesResult:
		return soap_out_PointerTons2__OpenStudiesResult(soap, tag, id, (ns2__OpenStudiesResult *const*)ptr, "ns2:OpenStudiesResult");
	case SOAP_TYPE_PointerTons2__OpenStudiesRequest:
		return soap_out_PointerTons2__OpenStudiesRequest(soap, tag, id, (ns2__OpenStudiesRequest *const*)ptr, "ns2:OpenStudiesRequest");
	case SOAP_TYPE_PointerTons2__GetViewerInfoResult:
		return soap_out_PointerTons2__GetViewerInfoResult(soap, tag, id, (ns2__GetViewerInfoResult *const*)ptr, "ns2:GetViewerInfoResult");
	case SOAP_TYPE_PointerTons2__GetViewerInfoRequest:
		return soap_out_PointerTons2__GetViewerInfoRequest(soap, tag, id, (ns2__GetViewerInfoRequest *const*)ptr, "ns2:GetViewerInfoRequest");
	case SOAP_TYPE_PointerTons2__GetActiveViewersResult:
		return soap_out_PointerTons2__GetActiveViewersResult(soap, tag, id, (ns2__GetActiveViewersResult *const*)ptr, "ns2:GetActiveViewersResult");
	case SOAP_TYPE_PointerTons2__GetViewersResult:
		return soap_out_PointerTons2__GetViewersResult(soap, tag, id, (ns2__GetViewersResult *const*)ptr, "ns2:GetViewersResult");
	case SOAP_TYPE_PointerTons2__GetViewersRequest:
		return soap_out_PointerTons2__GetViewersRequest(soap, tag, id, (ns2__GetViewersRequest *const*)ptr, "ns2:GetViewersRequest");
	case SOAP_TYPE_PointerTons2__OpenFilesResult:
		return soap_out_PointerTons2__OpenFilesResult(soap, tag, id, (ns2__OpenFilesResult *const*)ptr, "ns2:OpenFilesResult");
	case SOAP_TYPE_PointerTons2__OpenFilesRequest:
		return soap_out_PointerTons2__OpenFilesRequest(soap, tag, id, (ns2__OpenFilesRequest *const*)ptr, "ns2:OpenFilesRequest");
	case SOAP_TYPE_PointerTons2__OpenStudyInfo:
		return soap_out_PointerTons2__OpenStudyInfo(soap, tag, id, (ns2__OpenStudyInfo *const*)ptr, "ns2:OpenStudyInfo");
	case SOAP_TYPE_PointerTons2__ArrayOfOpenStudyInfo:
		return soap_out_PointerTons2__ArrayOfOpenStudyInfo(soap, tag, id, (ns2__ArrayOfOpenStudyInfo *const*)ptr, "ns2:ArrayOfOpenStudyInfo");
	case SOAP_TYPE_PointerTons2__ArrayOfViewer:
		return soap_out_PointerTons2__ArrayOfViewer(soap, tag, id, (ns2__ArrayOfViewer *const*)ptr, "ns2:ArrayOfViewer");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons5__StudyRootStudyIdentifier:
		return soap_out_PointerTons5__StudyRootStudyIdentifier(soap, tag, id, (ns5__StudyRootStudyIdentifier *const*)ptr, "ns5:StudyRootStudyIdentifier");
	case SOAP_TYPE_PointerTons2__Viewer:
		return soap_out_PointerTons2__Viewer(soap, tag, id, (ns2__Viewer *const*)ptr, "ns2:Viewer");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTons4__ArrayOfstring:
		return soap_out_PointerTons4__ArrayOfstring(soap, tag, id, (ns4__ArrayOfstring *const*)ptr, "ns4:ArrayOfstring");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns6__StudyOfflineFault:
		soap_serialize__ns6__StudyOfflineFault(soap, (const ns6__StudyOfflineFault *)ptr);
		break;
	case SOAP_TYPE__ns6__StudyInUseFault:
		soap_serialize__ns6__StudyInUseFault(soap, (const ns6__StudyInUseFault *)ptr);
		break;
	case SOAP_TYPE__ns6__StudyNotFoundFault:
		soap_serialize__ns6__StudyNotFoundFault(soap, (const ns6__StudyNotFoundFault *)ptr);
		break;
	case SOAP_TYPE__ns6__StudyNearlineFault:
		soap_serialize__ns6__StudyNearlineFault(soap, (const ns6__StudyNearlineFault *)ptr);
		break;
	case SOAP_TYPE__ns5__ArrayOfImageIdentifier:
		soap_serialize__ns5__ArrayOfImageIdentifier(soap, (const ns5__ArrayOfImageIdentifier *)ptr);
		break;
	case SOAP_TYPE__ns5__ImageIdentifier:
		soap_serialize__ns5__ImageIdentifier(soap, (const ns5__ImageIdentifier *)ptr);
		break;
	case SOAP_TYPE__ns5__ArrayOfSeriesIdentifier:
		soap_serialize__ns5__ArrayOfSeriesIdentifier(soap, (const ns5__ArrayOfSeriesIdentifier *)ptr);
		break;
	case SOAP_TYPE__ns5__SeriesIdentifier:
		soap_serialize__ns5__SeriesIdentifier(soap, (const ns5__SeriesIdentifier *)ptr);
		break;
	case SOAP_TYPE__ns5__DataValidationFault:
		soap_serialize__ns5__DataValidationFault(soap, (const ns5__DataValidationFault *)ptr);
		break;
	case SOAP_TYPE__ns5__QueryFailedFault:
		soap_serialize__ns5__QueryFailedFault(soap, (const ns5__QueryFailedFault *)ptr);
		break;
	case SOAP_TYPE__ns5__ArrayOfStudyRootStudyIdentifier:
		soap_serialize__ns5__ArrayOfStudyRootStudyIdentifier(soap, (const ns5__ArrayOfStudyRootStudyIdentifier *)ptr);
		break;
	case SOAP_TYPE__ns5__Identifier:
		soap_serialize__ns5__Identifier(soap, (const ns5__Identifier *)ptr);
		break;
	case SOAP_TYPE__ns5__StudyIdentifier:
		soap_serialize__ns5__StudyIdentifier(soap, (const ns5__StudyIdentifier *)ptr);
		break;
	case SOAP_TYPE__ns5__StudyRootStudyIdentifier:
		soap_serialize__ns5__StudyRootStudyIdentifier(soap, (const ns5__StudyRootStudyIdentifier *)ptr);
		break;
	case SOAP_TYPE__ns4__ArrayOfstring:
		soap_serialize__ns4__ArrayOfstring(soap, (const ns4__ArrayOfstring *)ptr);
		break;
	case SOAP_TYPE__ns3__Ref:
		soap_serialize__ns3__Ref(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__Id:
		soap_serialize__ns3__Id(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__FactoryType:
		soap_serialize__ns3__FactoryType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__guid:
		soap_serialize__ns3__guid(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__duration:
		soap_serialize__ns3__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__string:
		soap_serialize__ns3__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__QName:
		soap_serialize__ns3__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__decimal:
		soap_serialize__ns3__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__base64Binary:
		soap_serialize__ns3__base64Binary(soap, (const xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE__ns3__anyURI:
		soap_serialize__ns3__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns3__anyType:
		soap_serialize__ns3__anyType(soap, (const xsd__anyType *)ptr);
		break;
	case SOAP_TYPE__ns2__CloseViewerRequest:
		soap_serialize__ns2__CloseViewerRequest(soap, (const ns2__CloseViewerRequest *)ptr);
		break;
	case SOAP_TYPE__ns2__ActivateViewerRequest:
		soap_serialize__ns2__ActivateViewerRequest(soap, (const ns2__ActivateViewerRequest *)ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudiesFault:
		soap_serialize__ns2__OpenStudiesFault(soap, (const ns2__OpenStudiesFault *)ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudiesResult:
		soap_serialize__ns2__OpenStudiesResult(soap, (const ns2__OpenStudiesResult *)ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudyInfo:
		soap_serialize__ns2__OpenStudyInfo(soap, (const ns2__OpenStudyInfo *)ptr);
		break;
	case SOAP_TYPE__ns2__ArrayOfOpenStudyInfo:
		soap_serialize__ns2__ArrayOfOpenStudyInfo(soap, (const ns2__ArrayOfOpenStudyInfo *)ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudiesRequest:
		soap_serialize__ns2__OpenStudiesRequest(soap, (const ns2__OpenStudiesRequest *)ptr);
		break;
	case SOAP_TYPE__ns2__ViewerNotFoundFault:
		soap_serialize__ns2__ViewerNotFoundFault(soap, (const ns2__ViewerNotFoundFault *)ptr);
		break;
	case SOAP_TYPE__ns2__GetViewerInfoResult:
		soap_serialize__ns2__GetViewerInfoResult(soap, (const ns2__GetViewerInfoResult *)ptr);
		break;
	case SOAP_TYPE__ns2__GetViewerInfoRequest:
		soap_serialize__ns2__GetViewerInfoRequest(soap, (const ns2__GetViewerInfoRequest *)ptr);
		break;
	case SOAP_TYPE__ns2__NoActiveViewersFault:
		soap_serialize__ns2__NoActiveViewersFault(soap, (const ns2__NoActiveViewersFault *)ptr);
		break;
	case SOAP_TYPE__ns2__GetActiveViewersResult:
		soap_serialize__ns2__GetActiveViewersResult(soap, (const ns2__GetActiveViewersResult *)ptr);
		break;
	case SOAP_TYPE__ns2__NoViewersFault:
		soap_serialize__ns2__NoViewersFault(soap, (const ns2__NoViewersFault *)ptr);
		break;
	case SOAP_TYPE__ns2__ArrayOfViewer:
		soap_serialize__ns2__ArrayOfViewer(soap, (const ns2__ArrayOfViewer *)ptr);
		break;
	case SOAP_TYPE__ns2__GetViewersResult:
		soap_serialize__ns2__GetViewersResult(soap, (const ns2__GetViewersResult *)ptr);
		break;
	case SOAP_TYPE__ns2__GetViewersRequest:
		soap_serialize__ns2__GetViewersRequest(soap, (const ns2__GetViewersRequest *)ptr);
		break;
	case SOAP_TYPE__ns2__OpenFilesFault:
		soap_serialize__ns2__OpenFilesFault(soap, (const ns2__OpenFilesFault *)ptr);
		break;
	case SOAP_TYPE__ns2__Viewer:
		soap_serialize__ns2__Viewer(soap, (const ns2__Viewer *)ptr);
		break;
	case SOAP_TYPE__ns2__OpenFilesResult:
		soap_serialize__ns2__OpenFilesResult(soap, (const ns2__OpenFilesResult *)ptr);
		break;
	case SOAP_TYPE__ns2__OpenFilesRequest:
		soap_serialize__ns2__OpenFilesRequest(soap, (const ns2__OpenFilesRequest *)ptr);
		break;
	case SOAP_TYPE_ns3__guid__:
		((ns3__guid__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__guid:
		soap_serialize_ns3__guid(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__duration__:
		((ns3__duration__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__duration:
		soap_serialize_ns3__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns3__char__:
		((ns3__char__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__StudyOfflineFault:
		((ns6__StudyOfflineFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__StudyInUseFault:
		((ns6__StudyInUseFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__StudyNotFoundFault:
		((ns6__StudyNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__StudyNearlineFault:
		((ns6__StudyNearlineFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__ImageQueryResponse:
		((_ns5__ImageQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__ImageQuery:
		((_ns5__ImageQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__SeriesQueryResponse:
		((_ns5__SeriesQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__SeriesQuery:
		((_ns5__SeriesQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__StudyQueryResponse:
		((_ns5__StudyQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns5__StudyQuery:
		((_ns5__StudyQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ArrayOfImageIdentifier:
		((ns5__ArrayOfImageIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ImageIdentifier:
		((ns5__ImageIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ArrayOfSeriesIdentifier:
		((ns5__ArrayOfSeriesIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__SeriesIdentifier:
		((ns5__SeriesIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__DataValidationFault:
		((ns5__DataValidationFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__QueryFailedFault:
		((ns5__QueryFailedFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier:
		((ns5__ArrayOfStudyRootStudyIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Identifier:
		((ns5__Identifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__StudyIdentifier:
		((ns5__StudyIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__StudyRootStudyIdentifier:
		((ns5__StudyRootStudyIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ArrayOfstring:
		((ns4__ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__CloseViewerResponse:
		((_ns2__CloseViewerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__CloseViewer:
		((_ns2__CloseViewer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__ActivateViewerResponse:
		((_ns2__ActivateViewerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__ActivateViewer:
		((_ns2__ActivateViewer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__OpenStudiesResponse:
		((_ns2__OpenStudiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__OpenStudies:
		((_ns2__OpenStudies *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetViewerInfoResponse:
		((_ns2__GetViewerInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetViewerInfo:
		((_ns2__GetViewerInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetActiveViewersResponse:
		((_ns2__GetActiveViewersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetActiveViewers:
		((_ns2__GetActiveViewers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetViewersResponse:
		((_ns2__GetViewersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__GetViewers:
		((_ns2__GetViewers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__OpenFilesResponse:
		((_ns2__OpenFilesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns2__OpenFiles:
		((_ns2__OpenFiles *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CloseViewerRequest:
		((ns2__CloseViewerRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ActivateViewerRequest:
		((ns2__ActivateViewerRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OpenStudiesFault:
		((ns2__OpenStudiesFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OpenStudiesResult:
		((ns2__OpenStudiesResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OpenStudyInfo:
		((ns2__OpenStudyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ArrayOfOpenStudyInfo:
		((ns2__ArrayOfOpenStudyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OpenStudiesRequest:
		((ns2__OpenStudiesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ViewerNotFoundFault:
		((ns2__ViewerNotFoundFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GetViewerInfoResult:
		((ns2__GetViewerInfoResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GetViewerInfoRequest:
		((ns2__GetViewerInfoRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NoActiveViewersFault:
		((ns2__NoActiveViewersFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GetActiveViewersResult:
		((ns2__GetActiveViewersResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NoViewersFault:
		((ns2__NoViewersFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ArrayOfViewer:
		((ns2__ArrayOfViewer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GetViewersResult:
		((ns2__GetViewersResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__GetViewersRequest:
		((ns2__GetViewersRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OpenFilesFault:
		((ns2__OpenFilesFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Viewer:
		((ns2__Viewer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OpenFilesResult:
		((ns2__OpenFilesResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__OpenFilesRequest:
		((ns2__OpenFilesRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedShort:
		((xsd__unsignedShort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		((xsd__unsignedLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedInt:
		((xsd__unsignedInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedByte_:
		((xsd__unsignedByte_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__short:
		((xsd__short *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long:
		((xsd__long *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__float:
		((xsd__float *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration_:
		((xsd__duration_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_xsd__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__double:
		((xsd__double *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal_:
		((xsd__decimal_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__byte_:
		((xsd__byte_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		((xsd__base64Binary_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI_:
		((xsd__anyURI_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName_:
		((xsd__QName_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__IDREF_:
		((xsd__IDREF_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__IDREF:
		soap_serialize_xsd__IDREF(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__ID_:
		((xsd__ID_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns5__ImageQuery__:
		soap_serialize___ns5__ImageQuery__(soap, (const struct __ns5__ImageQuery__ *)ptr);
		break;
	case SOAP_TYPE___ns5__SeriesQuery__:
		soap_serialize___ns5__SeriesQuery__(soap, (const struct __ns5__SeriesQuery__ *)ptr);
		break;
	case SOAP_TYPE___ns5__StudyQuery__:
		soap_serialize___ns5__StudyQuery__(soap, (const struct __ns5__StudyQuery__ *)ptr);
		break;
	case SOAP_TYPE___ns5__ImageQuery_:
		soap_serialize___ns5__ImageQuery_(soap, (const struct __ns5__ImageQuery_ *)ptr);
		break;
	case SOAP_TYPE___ns5__SeriesQuery_:
		soap_serialize___ns5__SeriesQuery_(soap, (const struct __ns5__SeriesQuery_ *)ptr);
		break;
	case SOAP_TYPE___ns5__StudyQuery_:
		soap_serialize___ns5__StudyQuery_(soap, (const struct __ns5__StudyQuery_ *)ptr);
		break;
	case SOAP_TYPE___ns5__ImageQuery:
		soap_serialize___ns5__ImageQuery(soap, (const struct __ns5__ImageQuery *)ptr);
		break;
	case SOAP_TYPE___ns5__SeriesQuery:
		soap_serialize___ns5__SeriesQuery(soap, (const struct __ns5__SeriesQuery *)ptr);
		break;
	case SOAP_TYPE___ns5__StudyQuery:
		soap_serialize___ns5__StudyQuery(soap, (const struct __ns5__StudyQuery *)ptr);
		break;
	case SOAP_TYPE___ns2__CloseViewer__:
		soap_serialize___ns2__CloseViewer__(soap, (const struct __ns2__CloseViewer__ *)ptr);
		break;
	case SOAP_TYPE___ns2__ActivateViewer__:
		soap_serialize___ns2__ActivateViewer__(soap, (const struct __ns2__ActivateViewer__ *)ptr);
		break;
	case SOAP_TYPE___ns2__OpenStudies__:
		soap_serialize___ns2__OpenStudies__(soap, (const struct __ns2__OpenStudies__ *)ptr);
		break;
	case SOAP_TYPE___ns2__GetViewerInfo__:
		soap_serialize___ns2__GetViewerInfo__(soap, (const struct __ns2__GetViewerInfo__ *)ptr);
		break;
	case SOAP_TYPE___ns2__GetActiveViewers__:
		soap_serialize___ns2__GetActiveViewers__(soap, (const struct __ns2__GetActiveViewers__ *)ptr);
		break;
	case SOAP_TYPE___ns2__GetViewers__:
		soap_serialize___ns2__GetViewers__(soap, (const struct __ns2__GetViewers__ *)ptr);
		break;
	case SOAP_TYPE___ns2__OpenFiles__:
		soap_serialize___ns2__OpenFiles__(soap, (const struct __ns2__OpenFiles__ *)ptr);
		break;
	case SOAP_TYPE___ns2__CloseViewer_:
		soap_serialize___ns2__CloseViewer_(soap, (const struct __ns2__CloseViewer_ *)ptr);
		break;
	case SOAP_TYPE___ns2__ActivateViewer_:
		soap_serialize___ns2__ActivateViewer_(soap, (const struct __ns2__ActivateViewer_ *)ptr);
		break;
	case SOAP_TYPE___ns2__OpenStudies_:
		soap_serialize___ns2__OpenStudies_(soap, (const struct __ns2__OpenStudies_ *)ptr);
		break;
	case SOAP_TYPE___ns2__GetViewerInfo_:
		soap_serialize___ns2__GetViewerInfo_(soap, (const struct __ns2__GetViewerInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns2__GetActiveViewers_:
		soap_serialize___ns2__GetActiveViewers_(soap, (const struct __ns2__GetActiveViewers_ *)ptr);
		break;
	case SOAP_TYPE___ns2__GetViewers_:
		soap_serialize___ns2__GetViewers_(soap, (const struct __ns2__GetViewers_ *)ptr);
		break;
	case SOAP_TYPE___ns2__OpenFiles_:
		soap_serialize___ns2__OpenFiles_(soap, (const struct __ns2__OpenFiles_ *)ptr);
		break;
	case SOAP_TYPE___ns2__CloseViewer:
		soap_serialize___ns2__CloseViewer(soap, (const struct __ns2__CloseViewer *)ptr);
		break;
	case SOAP_TYPE___ns2__ActivateViewer:
		soap_serialize___ns2__ActivateViewer(soap, (const struct __ns2__ActivateViewer *)ptr);
		break;
	case SOAP_TYPE___ns2__OpenStudies:
		soap_serialize___ns2__OpenStudies(soap, (const struct __ns2__OpenStudies *)ptr);
		break;
	case SOAP_TYPE___ns2__GetViewerInfo:
		soap_serialize___ns2__GetViewerInfo(soap, (const struct __ns2__GetViewerInfo *)ptr);
		break;
	case SOAP_TYPE___ns2__GetActiveViewers:
		soap_serialize___ns2__GetActiveViewers(soap, (const struct __ns2__GetActiveViewers *)ptr);
		break;
	case SOAP_TYPE___ns2__GetViewers:
		soap_serialize___ns2__GetViewers(soap, (const struct __ns2__GetViewers *)ptr);
		break;
	case SOAP_TYPE___ns2__OpenFiles:
		soap_serialize___ns2__OpenFiles(soap, (const struct __ns2__OpenFiles *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__ImageQueryResponse:
		soap_serialize_PointerTo_ns5__ImageQueryResponse(soap, (_ns5__ImageQueryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__ImageQuery:
		soap_serialize_PointerTo_ns5__ImageQuery(soap, (_ns5__ImageQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__SeriesQueryResponse:
		soap_serialize_PointerTo_ns5__SeriesQueryResponse(soap, (_ns5__SeriesQueryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__SeriesQuery:
		soap_serialize_PointerTo_ns5__SeriesQuery(soap, (_ns5__SeriesQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__StudyQueryResponse:
		soap_serialize_PointerTo_ns5__StudyQueryResponse(soap, (_ns5__StudyQueryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns5__StudyQuery:
		soap_serialize_PointerTo_ns5__StudyQuery(soap, (_ns5__StudyQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__CloseViewerResponse:
		soap_serialize_PointerTo_ns2__CloseViewerResponse(soap, (_ns2__CloseViewerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__CloseViewer:
		soap_serialize_PointerTo_ns2__CloseViewer(soap, (_ns2__CloseViewer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ActivateViewerResponse:
		soap_serialize_PointerTo_ns2__ActivateViewerResponse(soap, (_ns2__ActivateViewerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__ActivateViewer:
		soap_serialize_PointerTo_ns2__ActivateViewer(soap, (_ns2__ActivateViewer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__OpenStudiesResponse:
		soap_serialize_PointerTo_ns2__OpenStudiesResponse(soap, (_ns2__OpenStudiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__OpenStudies:
		soap_serialize_PointerTo_ns2__OpenStudies(soap, (_ns2__OpenStudies *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetViewerInfoResponse:
		soap_serialize_PointerTo_ns2__GetViewerInfoResponse(soap, (_ns2__GetViewerInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetViewerInfo:
		soap_serialize_PointerTo_ns2__GetViewerInfo(soap, (_ns2__GetViewerInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetActiveViewersResponse:
		soap_serialize_PointerTo_ns2__GetActiveViewersResponse(soap, (_ns2__GetActiveViewersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetActiveViewers:
		soap_serialize_PointerTo_ns2__GetActiveViewers(soap, (_ns2__GetActiveViewers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetViewersResponse:
		soap_serialize_PointerTo_ns2__GetViewersResponse(soap, (_ns2__GetViewersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__GetViewers:
		soap_serialize_PointerTo_ns2__GetViewers(soap, (_ns2__GetViewers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__OpenFilesResponse:
		soap_serialize_PointerTo_ns2__OpenFilesResponse(soap, (_ns2__OpenFilesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__OpenFiles:
		soap_serialize_PointerTo_ns2__OpenFiles(soap, (_ns2__OpenFiles *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__StudyOfflineFault:
		soap_serialize_PointerTons6__StudyOfflineFault(soap, (ns6__StudyOfflineFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__StudyNotFoundFault:
		soap_serialize_PointerTons6__StudyNotFoundFault(soap, (ns6__StudyNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__StudyNearlineFault:
		soap_serialize_PointerTons6__StudyNearlineFault(soap, (ns6__StudyNearlineFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__StudyInUseFault:
		soap_serialize_PointerTons6__StudyInUseFault(soap, (ns6__StudyInUseFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OpenStudiesFault:
		soap_serialize_PointerTons2__OpenStudiesFault(soap, (ns2__OpenStudiesFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OpenFilesFault:
		soap_serialize_PointerTons2__OpenFilesFault(soap, (ns2__OpenFilesFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NoViewersFault:
		soap_serialize_PointerTons2__NoViewersFault(soap, (ns2__NoViewersFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NoActiveViewersFault:
		soap_serialize_PointerTons2__NoActiveViewersFault(soap, (ns2__NoActiveViewersFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ViewerNotFoundFault:
		soap_serialize_PointerTons2__ViewerNotFoundFault(soap, (ns2__ViewerNotFoundFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__QueryFailedFault:
		soap_serialize_PointerTons5__QueryFailedFault(soap, (ns5__QueryFailedFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__DataValidationFault:
		soap_serialize_PointerTons5__DataValidationFault(soap, (ns5__DataValidationFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ArrayOfImageIdentifier:
		soap_serialize_PointerTons5__ArrayOfImageIdentifier(soap, (ns5__ArrayOfImageIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ArrayOfSeriesIdentifier:
		soap_serialize_PointerTons5__ArrayOfSeriesIdentifier(soap, (ns5__ArrayOfSeriesIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ArrayOfStudyRootStudyIdentifier:
		soap_serialize_PointerTons5__ArrayOfStudyRootStudyIdentifier(soap, (ns5__ArrayOfStudyRootStudyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ImageIdentifier:
		soap_serialize_PointerTons5__ImageIdentifier(soap, (ns5__ImageIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__SeriesIdentifier:
		soap_serialize_PointerTons5__SeriesIdentifier(soap, (ns5__SeriesIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CloseViewerRequest:
		soap_serialize_PointerTons2__CloseViewerRequest(soap, (ns2__CloseViewerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ActivateViewerRequest:
		soap_serialize_PointerTons2__ActivateViewerRequest(soap, (ns2__ActivateViewerRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OpenStudiesResult:
		soap_serialize_PointerTons2__OpenStudiesResult(soap, (ns2__OpenStudiesResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OpenStudiesRequest:
		soap_serialize_PointerTons2__OpenStudiesRequest(soap, (ns2__OpenStudiesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GetViewerInfoResult:
		soap_serialize_PointerTons2__GetViewerInfoResult(soap, (ns2__GetViewerInfoResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GetViewerInfoRequest:
		soap_serialize_PointerTons2__GetViewerInfoRequest(soap, (ns2__GetViewerInfoRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GetActiveViewersResult:
		soap_serialize_PointerTons2__GetActiveViewersResult(soap, (ns2__GetActiveViewersResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GetViewersResult:
		soap_serialize_PointerTons2__GetViewersResult(soap, (ns2__GetViewersResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__GetViewersRequest:
		soap_serialize_PointerTons2__GetViewersRequest(soap, (ns2__GetViewersRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OpenFilesResult:
		soap_serialize_PointerTons2__OpenFilesResult(soap, (ns2__OpenFilesResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OpenFilesRequest:
		soap_serialize_PointerTons2__OpenFilesRequest(soap, (ns2__OpenFilesRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__OpenStudyInfo:
		soap_serialize_PointerTons2__OpenStudyInfo(soap, (ns2__OpenStudyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ArrayOfOpenStudyInfo:
		soap_serialize_PointerTons2__ArrayOfOpenStudyInfo(soap, (ns2__ArrayOfOpenStudyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ArrayOfViewer:
		soap_serialize_PointerTons2__ArrayOfViewer(soap, (ns2__ArrayOfViewer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__StudyRootStudyIdentifier:
		soap_serialize_PointerTons5__StudyRootStudyIdentifier(soap, (ns5__StudyRootStudyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Viewer:
		soap_serialize_PointerTons2__Viewer(soap, (ns2__Viewer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ArrayOfstring:
		soap_serialize_PointerTons4__ArrayOfstring(soap, (ns4__ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ID_:
		return (void*)soap_instantiate_xsd__ID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__IDREF_:
		return (void*)soap_instantiate_xsd__IDREF_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName_:
		return (void*)soap_instantiate_xsd__QName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI_:
		return (void*)soap_instantiate_xsd__anyURI_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary_:
		return (void*)soap_instantiate_xsd__base64Binary_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__byte_:
		return (void*)soap_instantiate_xsd__byte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal_:
		return (void*)soap_instantiate_xsd__decimal_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double:
		return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration_:
		return (void*)soap_instantiate_xsd__duration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__float:
		return (void*)soap_instantiate_xsd__float(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long:
		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__short:
		return (void*)soap_instantiate_xsd__short(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedByte_:
		return (void*)soap_instantiate_xsd__unsignedByte_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedInt:
		return (void*)soap_instantiate_xsd__unsignedInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedLong:
		return (void*)soap_instantiate_xsd__unsignedLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedShort:
		return (void*)soap_instantiate_xsd__unsignedShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__char__:
		return (void*)soap_instantiate_ns3__char__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__duration__:
		return (void*)soap_instantiate_ns3__duration__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__guid__:
		return (void*)soap_instantiate_ns3__guid__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OpenFilesRequest:
		return (void*)soap_instantiate_ns2__OpenFilesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OpenFilesResult:
		return (void*)soap_instantiate_ns2__OpenFilesResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Viewer:
		return (void*)soap_instantiate_ns2__Viewer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OpenFilesFault:
		return (void*)soap_instantiate_ns2__OpenFilesFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GetViewersRequest:
		return (void*)soap_instantiate_ns2__GetViewersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GetViewersResult:
		return (void*)soap_instantiate_ns2__GetViewersResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ArrayOfViewer:
		return (void*)soap_instantiate_ns2__ArrayOfViewer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NoViewersFault:
		return (void*)soap_instantiate_ns2__NoViewersFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GetActiveViewersResult:
		return (void*)soap_instantiate_ns2__GetActiveViewersResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NoActiveViewersFault:
		return (void*)soap_instantiate_ns2__NoActiveViewersFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GetViewerInfoRequest:
		return (void*)soap_instantiate_ns2__GetViewerInfoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__GetViewerInfoResult:
		return (void*)soap_instantiate_ns2__GetViewerInfoResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ViewerNotFoundFault:
		return (void*)soap_instantiate_ns2__ViewerNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OpenStudiesRequest:
		return (void*)soap_instantiate_ns2__OpenStudiesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ArrayOfOpenStudyInfo:
		return (void*)soap_instantiate_ns2__ArrayOfOpenStudyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OpenStudyInfo:
		return (void*)soap_instantiate_ns2__OpenStudyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OpenStudiesResult:
		return (void*)soap_instantiate_ns2__OpenStudiesResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__OpenStudiesFault:
		return (void*)soap_instantiate_ns2__OpenStudiesFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ActivateViewerRequest:
		return (void*)soap_instantiate_ns2__ActivateViewerRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CloseViewerRequest:
		return (void*)soap_instantiate_ns2__CloseViewerRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenFiles:
		return (void*)soap_instantiate__ns2__OpenFiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenFilesResponse:
		return (void*)soap_instantiate__ns2__OpenFilesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetViewers:
		return (void*)soap_instantiate__ns2__GetViewers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetViewersResponse:
		return (void*)soap_instantiate__ns2__GetViewersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetActiveViewers:
		return (void*)soap_instantiate__ns2__GetActiveViewers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetActiveViewersResponse:
		return (void*)soap_instantiate__ns2__GetActiveViewersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetViewerInfo:
		return (void*)soap_instantiate__ns2__GetViewerInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetViewerInfoResponse:
		return (void*)soap_instantiate__ns2__GetViewerInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenStudies:
		return (void*)soap_instantiate__ns2__OpenStudies(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenStudiesResponse:
		return (void*)soap_instantiate__ns2__OpenStudiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ActivateViewer:
		return (void*)soap_instantiate__ns2__ActivateViewer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ActivateViewerResponse:
		return (void*)soap_instantiate__ns2__ActivateViewerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__CloseViewer:
		return (void*)soap_instantiate__ns2__CloseViewer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__CloseViewerResponse:
		return (void*)soap_instantiate__ns2__CloseViewerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ArrayOfstring:
		return (void*)soap_instantiate_ns4__ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Identifier:
		return (void*)soap_instantiate_ns5__Identifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier:
		return (void*)soap_instantiate_ns5__ArrayOfStudyRootStudyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__QueryFailedFault:
		return (void*)soap_instantiate_ns5__QueryFailedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__DataValidationFault:
		return (void*)soap_instantiate_ns5__DataValidationFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ArrayOfSeriesIdentifier:
		return (void*)soap_instantiate_ns5__ArrayOfSeriesIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ArrayOfImageIdentifier:
		return (void*)soap_instantiate_ns5__ArrayOfImageIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__StudyQuery:
		return (void*)soap_instantiate__ns5__StudyQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__StudyQueryResponse:
		return (void*)soap_instantiate__ns5__StudyQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__SeriesQuery:
		return (void*)soap_instantiate__ns5__SeriesQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__SeriesQueryResponse:
		return (void*)soap_instantiate__ns5__SeriesQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ImageQuery:
		return (void*)soap_instantiate__ns5__ImageQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ImageQueryResponse:
		return (void*)soap_instantiate__ns5__ImageQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__StudyNearlineFault:
		return (void*)soap_instantiate_ns6__StudyNearlineFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__StudyNotFoundFault:
		return (void*)soap_instantiate_ns6__StudyNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__StudyInUseFault:
		return (void*)soap_instantiate_ns6__StudyInUseFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__StudyOfflineFault:
		return (void*)soap_instantiate_ns6__StudyOfflineFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__StudyIdentifier:
		return (void*)soap_instantiate_ns5__StudyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__SeriesIdentifier:
		return (void*)soap_instantiate_ns5__SeriesIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ImageIdentifier:
		return (void*)soap_instantiate_ns5__ImageIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__StudyRootStudyIdentifier:
		return (void*)soap_instantiate_ns5__StudyRootStudyIdentifier(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns2__OpenFiles:
		return (void*)soap_instantiate___ns2__OpenFiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetViewers:
		return (void*)soap_instantiate___ns2__GetViewers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetActiveViewers:
		return (void*)soap_instantiate___ns2__GetActiveViewers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetViewerInfo:
		return (void*)soap_instantiate___ns2__GetViewerInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__OpenStudies:
		return (void*)soap_instantiate___ns2__OpenStudies(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__ActivateViewer:
		return (void*)soap_instantiate___ns2__ActivateViewer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__CloseViewer:
		return (void*)soap_instantiate___ns2__CloseViewer(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__OpenFiles_:
		return (void*)soap_instantiate___ns2__OpenFiles_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetViewers_:
		return (void*)soap_instantiate___ns2__GetViewers_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetActiveViewers_:
		return (void*)soap_instantiate___ns2__GetActiveViewers_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetViewerInfo_:
		return (void*)soap_instantiate___ns2__GetViewerInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__OpenStudies_:
		return (void*)soap_instantiate___ns2__OpenStudies_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__ActivateViewer_:
		return (void*)soap_instantiate___ns2__ActivateViewer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__CloseViewer_:
		return (void*)soap_instantiate___ns2__CloseViewer_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__OpenFiles__:
		return (void*)soap_instantiate___ns2__OpenFiles__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetViewers__:
		return (void*)soap_instantiate___ns2__GetViewers__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetActiveViewers__:
		return (void*)soap_instantiate___ns2__GetActiveViewers__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__GetViewerInfo__:
		return (void*)soap_instantiate___ns2__GetViewerInfo__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__OpenStudies__:
		return (void*)soap_instantiate___ns2__OpenStudies__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__ActivateViewer__:
		return (void*)soap_instantiate___ns2__ActivateViewer__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns2__CloseViewer__:
		return (void*)soap_instantiate___ns2__CloseViewer__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__StudyQuery:
		return (void*)soap_instantiate___ns5__StudyQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__SeriesQuery:
		return (void*)soap_instantiate___ns5__SeriesQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__ImageQuery:
		return (void*)soap_instantiate___ns5__ImageQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__StudyQuery_:
		return (void*)soap_instantiate___ns5__StudyQuery_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__SeriesQuery_:
		return (void*)soap_instantiate___ns5__SeriesQuery_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__ImageQuery_:
		return (void*)soap_instantiate___ns5__ImageQuery_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__StudyQuery__:
		return (void*)soap_instantiate___ns5__StudyQuery__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__SeriesQuery__:
		return (void*)soap_instantiate___ns5__SeriesQuery__(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns5__ImageQuery__:
		return (void*)soap_instantiate___ns5__ImageQuery__(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__IDREF:
		return (void*)soap_instantiate_xsd__IDREF(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration:
		return (void*)soap_instantiate_xsd__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__duration:
		return (void*)soap_instantiate_ns3__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__guid:
		return (void*)soap_instantiate_ns3__guid(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenFilesRequest:
		return (void*)soap_instantiate__ns2__OpenFilesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenFilesResult:
		return (void*)soap_instantiate__ns2__OpenFilesResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__Viewer:
		return (void*)soap_instantiate__ns2__Viewer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenFilesFault:
		return (void*)soap_instantiate__ns2__OpenFilesFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetViewersRequest:
		return (void*)soap_instantiate__ns2__GetViewersRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetViewersResult:
		return (void*)soap_instantiate__ns2__GetViewersResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ArrayOfViewer:
		return (void*)soap_instantiate__ns2__ArrayOfViewer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__NoViewersFault:
		return (void*)soap_instantiate__ns2__NoViewersFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetActiveViewersResult:
		return (void*)soap_instantiate__ns2__GetActiveViewersResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__NoActiveViewersFault:
		return (void*)soap_instantiate__ns2__NoActiveViewersFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetViewerInfoRequest:
		return (void*)soap_instantiate__ns2__GetViewerInfoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__GetViewerInfoResult:
		return (void*)soap_instantiate__ns2__GetViewerInfoResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ViewerNotFoundFault:
		return (void*)soap_instantiate__ns2__ViewerNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenStudiesRequest:
		return (void*)soap_instantiate__ns2__OpenStudiesRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ArrayOfOpenStudyInfo:
		return (void*)soap_instantiate__ns2__ArrayOfOpenStudyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenStudyInfo:
		return (void*)soap_instantiate__ns2__OpenStudyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenStudiesResult:
		return (void*)soap_instantiate__ns2__OpenStudiesResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__OpenStudiesFault:
		return (void*)soap_instantiate__ns2__OpenStudiesFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__ActivateViewerRequest:
		return (void*)soap_instantiate__ns2__ActivateViewerRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns2__CloseViewerRequest:
		return (void*)soap_instantiate__ns2__CloseViewerRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__anyType:
		return (void*)soap_instantiate__ns3__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__anyURI:
		return (void*)soap_instantiate__ns3__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__base64Binary:
		return (void*)soap_instantiate__ns3__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__decimal:
		return (void*)soap_instantiate__ns3__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__QName:
		return (void*)soap_instantiate__ns3__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__string:
		return (void*)soap_instantiate__ns3__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__duration:
		return (void*)soap_instantiate__ns3__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__guid:
		return (void*)soap_instantiate__ns3__guid(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__FactoryType:
		return (void*)soap_instantiate__ns3__FactoryType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Id:
		return (void*)soap_instantiate__ns3__Id(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns3__Ref:
		return (void*)soap_instantiate__ns3__Ref(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__ArrayOfstring:
		return (void*)soap_instantiate__ns4__ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__StudyRootStudyIdentifier:
		return (void*)soap_instantiate__ns5__StudyRootStudyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__StudyIdentifier:
		return (void*)soap_instantiate__ns5__StudyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__Identifier:
		return (void*)soap_instantiate__ns5__Identifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ArrayOfStudyRootStudyIdentifier:
		return (void*)soap_instantiate__ns5__ArrayOfStudyRootStudyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__QueryFailedFault:
		return (void*)soap_instantiate__ns5__QueryFailedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__DataValidationFault:
		return (void*)soap_instantiate__ns5__DataValidationFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__SeriesIdentifier:
		return (void*)soap_instantiate__ns5__SeriesIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ArrayOfSeriesIdentifier:
		return (void*)soap_instantiate__ns5__ArrayOfSeriesIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ImageIdentifier:
		return (void*)soap_instantiate__ns5__ImageIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns5__ArrayOfImageIdentifier:
		return (void*)soap_instantiate__ns5__ArrayOfImageIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__StudyNearlineFault:
		return (void*)soap_instantiate__ns6__StudyNearlineFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__StudyNotFoundFault:
		return (void*)soap_instantiate__ns6__StudyNotFoundFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__StudyInUseFault:
		return (void*)soap_instantiate__ns6__StudyInUseFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns6__StudyOfflineFault:
		return (void*)soap_instantiate__ns6__StudyOfflineFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ImageIdentifier:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__ImageIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__SeriesIdentifier:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__SeriesIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OpenStudyInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__OpenStudyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Viewer:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__Viewer(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE((xsd__anyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__anyType*)p->ptr);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_xsd__ID_:
		if (p->size < 0)
			SOAP_DELETE((xsd__ID_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__ID_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__IDREF_:
		if (p->size < 0)
			SOAP_DELETE((xsd__IDREF_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__IDREF_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__QName_:
		if (p->size < 0)
			SOAP_DELETE((xsd__QName_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__QName_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI_:
		if (p->size < 0)
			SOAP_DELETE((xsd__anyURI_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__anyURI_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary_:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			SOAP_DELETE((xsd__boolean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__boolean*)p->ptr);
		break;
	case SOAP_TYPE_xsd__byte_:
		if (p->size < 0)
			SOAP_DELETE((xsd__byte_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__byte_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			SOAP_DELETE((xsd__dateTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__dateTime*)p->ptr);
		break;
	case SOAP_TYPE_xsd__decimal_:
		if (p->size < 0)
			SOAP_DELETE((xsd__decimal_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__decimal_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__double:
		if (p->size < 0)
			SOAP_DELETE((xsd__double*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__double*)p->ptr);
		break;
	case SOAP_TYPE_xsd__duration_:
		if (p->size < 0)
			SOAP_DELETE((xsd__duration_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__duration_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__float:
		if (p->size < 0)
			SOAP_DELETE((xsd__float*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__float*)p->ptr);
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			SOAP_DELETE((xsd__int*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__int*)p->ptr);
		break;
	case SOAP_TYPE_xsd__long:
		if (p->size < 0)
			SOAP_DELETE((xsd__long*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__long*)p->ptr);
		break;
	case SOAP_TYPE_xsd__short:
		if (p->size < 0)
			SOAP_DELETE((xsd__short*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__short*)p->ptr);
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			SOAP_DELETE((xsd__string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__unsignedByte_:
		if (p->size < 0)
			SOAP_DELETE((xsd__unsignedByte_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__unsignedByte_*)p->ptr);
		break;
	case SOAP_TYPE_xsd__unsignedInt:
		if (p->size < 0)
			SOAP_DELETE((xsd__unsignedInt*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__unsignedInt*)p->ptr);
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		if (p->size < 0)
			SOAP_DELETE((xsd__unsignedLong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__unsignedLong*)p->ptr);
		break;
	case SOAP_TYPE_xsd__unsignedShort:
		if (p->size < 0)
			SOAP_DELETE((xsd__unsignedShort*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__unsignedShort*)p->ptr);
		break;
	case SOAP_TYPE_ns3__char__:
		if (p->size < 0)
			SOAP_DELETE((ns3__char__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__char__*)p->ptr);
		break;
	case SOAP_TYPE_ns3__duration__:
		if (p->size < 0)
			SOAP_DELETE((ns3__duration__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__duration__*)p->ptr);
		break;
	case SOAP_TYPE_ns3__guid__:
		if (p->size < 0)
			SOAP_DELETE((ns3__guid__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__guid__*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OpenFilesRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenFilesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenFilesRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OpenFilesResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenFilesResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenFilesResult*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Viewer:
		if (p->size < 0)
			SOAP_DELETE((ns2__Viewer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Viewer*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OpenFilesFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenFilesFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenFilesFault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__GetViewersRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetViewersRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetViewersRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns2__GetViewersResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetViewersResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetViewersResult*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ArrayOfViewer:
		if (p->size < 0)
			SOAP_DELETE((ns2__ArrayOfViewer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ArrayOfViewer*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NoViewersFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__NoViewersFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NoViewersFault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__GetActiveViewersResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetActiveViewersResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetActiveViewersResult*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NoActiveViewersFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__NoActiveViewersFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NoActiveViewersFault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__GetViewerInfoRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetViewerInfoRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetViewerInfoRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns2__GetViewerInfoResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetViewerInfoResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetViewerInfoResult*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ViewerNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__ViewerNotFoundFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ViewerNotFoundFault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OpenStudiesRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenStudiesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenStudiesRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ArrayOfOpenStudyInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__ArrayOfOpenStudyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ArrayOfOpenStudyInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OpenStudyInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenStudyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenStudyInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OpenStudiesResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenStudiesResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenStudiesResult*)p->ptr);
		break;
	case SOAP_TYPE_ns2__OpenStudiesFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenStudiesFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenStudiesFault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ActivateViewerRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__ActivateViewerRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ActivateViewerRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CloseViewerRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__CloseViewerRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CloseViewerRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenFiles:
		if (p->size < 0)
			SOAP_DELETE((_ns2__OpenFiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__OpenFiles*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenFilesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__OpenFilesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__OpenFilesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetViewers:
		if (p->size < 0)
			SOAP_DELETE((_ns2__GetViewers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__GetViewers*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetViewersResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__GetViewersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__GetViewersResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetActiveViewers:
		if (p->size < 0)
			SOAP_DELETE((_ns2__GetActiveViewers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__GetActiveViewers*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetActiveViewersResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__GetActiveViewersResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__GetActiveViewersResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetViewerInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns2__GetViewerInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__GetViewerInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetViewerInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__GetViewerInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__GetViewerInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudies:
		if (p->size < 0)
			SOAP_DELETE((_ns2__OpenStudies*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__OpenStudies*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudiesResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__OpenStudiesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__OpenStudiesResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ActivateViewer:
		if (p->size < 0)
			SOAP_DELETE((_ns2__ActivateViewer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__ActivateViewer*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ActivateViewerResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__ActivateViewerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__ActivateViewerResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns2__CloseViewer:
		if (p->size < 0)
			SOAP_DELETE((_ns2__CloseViewer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__CloseViewer*)p->ptr);
		break;
	case SOAP_TYPE__ns2__CloseViewerResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns2__CloseViewerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns2__CloseViewerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns4__ArrayOfstring:
		if (p->size < 0)
			SOAP_DELETE((ns4__ArrayOfstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__ArrayOfstring*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Identifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__Identifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Identifier*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__ArrayOfStudyRootStudyIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ArrayOfStudyRootStudyIdentifier*)p->ptr);
		break;
	case SOAP_TYPE_ns5__QueryFailedFault:
		if (p->size < 0)
			SOAP_DELETE((ns5__QueryFailedFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__QueryFailedFault*)p->ptr);
		break;
	case SOAP_TYPE_ns5__DataValidationFault:
		if (p->size < 0)
			SOAP_DELETE((ns5__DataValidationFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__DataValidationFault*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ArrayOfSeriesIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__ArrayOfSeriesIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ArrayOfSeriesIdentifier*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ArrayOfImageIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__ArrayOfImageIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ArrayOfImageIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__ns5__StudyQuery:
		if (p->size < 0)
			SOAP_DELETE((_ns5__StudyQuery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__StudyQuery*)p->ptr);
		break;
	case SOAP_TYPE__ns5__StudyQueryResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns5__StudyQueryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__StudyQueryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns5__SeriesQuery:
		if (p->size < 0)
			SOAP_DELETE((_ns5__SeriesQuery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__SeriesQuery*)p->ptr);
		break;
	case SOAP_TYPE__ns5__SeriesQueryResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns5__SeriesQueryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__SeriesQueryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns5__ImageQuery:
		if (p->size < 0)
			SOAP_DELETE((_ns5__ImageQuery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__ImageQuery*)p->ptr);
		break;
	case SOAP_TYPE__ns5__ImageQueryResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns5__ImageQueryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns5__ImageQueryResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns6__StudyNearlineFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__StudyNearlineFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__StudyNearlineFault*)p->ptr);
		break;
	case SOAP_TYPE_ns6__StudyNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__StudyNotFoundFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__StudyNotFoundFault*)p->ptr);
		break;
	case SOAP_TYPE_ns6__StudyInUseFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__StudyInUseFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__StudyInUseFault*)p->ptr);
		break;
	case SOAP_TYPE_ns6__StudyOfflineFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__StudyOfflineFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__StudyOfflineFault*)p->ptr);
		break;
	case SOAP_TYPE_ns5__StudyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__StudyIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__StudyIdentifier*)p->ptr);
		break;
	case SOAP_TYPE_ns5__SeriesIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__SeriesIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__SeriesIdentifier*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ImageIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__ImageIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ImageIdentifier*)p->ptr);
		break;
	case SOAP_TYPE_ns5__StudyRootStudyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__StudyRootStudyIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__StudyRootStudyIdentifier*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___ns2__OpenFiles:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__OpenFiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__OpenFiles*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetViewers:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetViewers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetViewers*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetActiveViewers:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetActiveViewers*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetActiveViewers*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetViewerInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetViewerInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetViewerInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns2__OpenStudies:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__OpenStudies*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__OpenStudies*)p->ptr);
		break;
	case SOAP_TYPE___ns2__ActivateViewer:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__ActivateViewer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__ActivateViewer*)p->ptr);
		break;
	case SOAP_TYPE___ns2__CloseViewer:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__CloseViewer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__CloseViewer*)p->ptr);
		break;
	case SOAP_TYPE___ns2__OpenFiles_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__OpenFiles_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__OpenFiles_*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetViewers_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetViewers_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetViewers_*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetActiveViewers_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetActiveViewers_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetActiveViewers_*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetViewerInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetViewerInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetViewerInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns2__OpenStudies_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__OpenStudies_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__OpenStudies_*)p->ptr);
		break;
	case SOAP_TYPE___ns2__ActivateViewer_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__ActivateViewer_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__ActivateViewer_*)p->ptr);
		break;
	case SOAP_TYPE___ns2__CloseViewer_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__CloseViewer_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__CloseViewer_*)p->ptr);
		break;
	case SOAP_TYPE___ns2__OpenFiles__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__OpenFiles__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__OpenFiles__*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetViewers__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetViewers__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetViewers__*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetActiveViewers__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetActiveViewers__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetActiveViewers__*)p->ptr);
		break;
	case SOAP_TYPE___ns2__GetViewerInfo__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__GetViewerInfo__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__GetViewerInfo__*)p->ptr);
		break;
	case SOAP_TYPE___ns2__OpenStudies__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__OpenStudies__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__OpenStudies__*)p->ptr);
		break;
	case SOAP_TYPE___ns2__ActivateViewer__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__ActivateViewer__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__ActivateViewer__*)p->ptr);
		break;
	case SOAP_TYPE___ns2__CloseViewer__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns2__CloseViewer__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns2__CloseViewer__*)p->ptr);
		break;
	case SOAP_TYPE___ns5__StudyQuery:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__StudyQuery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__StudyQuery*)p->ptr);
		break;
	case SOAP_TYPE___ns5__SeriesQuery:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__SeriesQuery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__SeriesQuery*)p->ptr);
		break;
	case SOAP_TYPE___ns5__ImageQuery:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__ImageQuery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__ImageQuery*)p->ptr);
		break;
	case SOAP_TYPE___ns5__StudyQuery_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__StudyQuery_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__StudyQuery_*)p->ptr);
		break;
	case SOAP_TYPE___ns5__SeriesQuery_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__SeriesQuery_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__SeriesQuery_*)p->ptr);
		break;
	case SOAP_TYPE___ns5__ImageQuery_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__ImageQuery_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__ImageQuery_*)p->ptr);
		break;
	case SOAP_TYPE___ns5__StudyQuery__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__StudyQuery__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__StudyQuery__*)p->ptr);
		break;
	case SOAP_TYPE___ns5__SeriesQuery__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__SeriesQuery__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__SeriesQuery__*)p->ptr);
		break;
	case SOAP_TYPE___ns5__ImageQuery__:
		if (p->size < 0)
			SOAP_DELETE((struct __ns5__ImageQuery__*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns5__ImageQuery__*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__IDREF:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__duration:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns3__guid:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenFilesRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenFilesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenFilesRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenFilesResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenFilesResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenFilesResult*)p->ptr);
		break;
	case SOAP_TYPE__ns2__Viewer:
		if (p->size < 0)
			SOAP_DELETE((ns2__Viewer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Viewer*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenFilesFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenFilesFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenFilesFault*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetViewersRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetViewersRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetViewersRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetViewersResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetViewersResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetViewersResult*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ArrayOfViewer:
		if (p->size < 0)
			SOAP_DELETE((ns2__ArrayOfViewer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ArrayOfViewer*)p->ptr);
		break;
	case SOAP_TYPE__ns2__NoViewersFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__NoViewersFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NoViewersFault*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetActiveViewersResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetActiveViewersResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetActiveViewersResult*)p->ptr);
		break;
	case SOAP_TYPE__ns2__NoActiveViewersFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__NoActiveViewersFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NoActiveViewersFault*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetViewerInfoRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetViewerInfoRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetViewerInfoRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns2__GetViewerInfoResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__GetViewerInfoResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__GetViewerInfoResult*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ViewerNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__ViewerNotFoundFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ViewerNotFoundFault*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudiesRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenStudiesRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenStudiesRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ArrayOfOpenStudyInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__ArrayOfOpenStudyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ArrayOfOpenStudyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudyInfo:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenStudyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenStudyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudiesResult:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenStudiesResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenStudiesResult*)p->ptr);
		break;
	case SOAP_TYPE__ns2__OpenStudiesFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__OpenStudiesFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__OpenStudiesFault*)p->ptr);
		break;
	case SOAP_TYPE__ns2__ActivateViewerRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__ActivateViewerRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ActivateViewerRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns2__CloseViewerRequest:
		if (p->size < 0)
			SOAP_DELETE((ns2__CloseViewerRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CloseViewerRequest*)p->ptr);
		break;
	case SOAP_TYPE__ns3__anyType:
		if (p->size < 0)
			SOAP_DELETE((xsd__anyType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__anyType*)p->ptr);
		break;
	case SOAP_TYPE__ns3__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns3__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE__ns3__decimal:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns3__QName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns3__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns3__duration:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns3__guid:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns3__FactoryType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns3__Id:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns3__Ref:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE__ns4__ArrayOfstring:
		if (p->size < 0)
			SOAP_DELETE((ns4__ArrayOfstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns4__ArrayOfstring*)p->ptr);
		break;
	case SOAP_TYPE__ns5__StudyRootStudyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__StudyRootStudyIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__StudyRootStudyIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__ns5__StudyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__StudyIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__StudyIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__ns5__Identifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__Identifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Identifier*)p->ptr);
		break;
	case SOAP_TYPE__ns5__ArrayOfStudyRootStudyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__ArrayOfStudyRootStudyIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ArrayOfStudyRootStudyIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__ns5__QueryFailedFault:
		if (p->size < 0)
			SOAP_DELETE((ns5__QueryFailedFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__QueryFailedFault*)p->ptr);
		break;
	case SOAP_TYPE__ns5__DataValidationFault:
		if (p->size < 0)
			SOAP_DELETE((ns5__DataValidationFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__DataValidationFault*)p->ptr);
		break;
	case SOAP_TYPE__ns5__SeriesIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__SeriesIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__SeriesIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__ns5__ArrayOfSeriesIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__ArrayOfSeriesIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ArrayOfSeriesIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__ns5__ImageIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__ImageIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ImageIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__ns5__ArrayOfImageIdentifier:
		if (p->size < 0)
			SOAP_DELETE((ns5__ArrayOfImageIdentifier*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ArrayOfImageIdentifier*)p->ptr);
		break;
	case SOAP_TYPE__ns6__StudyNearlineFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__StudyNearlineFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__StudyNearlineFault*)p->ptr);
		break;
	case SOAP_TYPE__ns6__StudyNotFoundFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__StudyNotFoundFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__StudyNotFoundFault*)p->ptr);
		break;
	case SOAP_TYPE__ns6__StudyInUseFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__StudyInUseFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__StudyInUseFault*)p->ptr);
		break;
	case SOAP_TYPE__ns6__StudyOfflineFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__StudyOfflineFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__StudyOfflineFault*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ImageIdentifier:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__ImageIdentifier * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__ImageIdentifier * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__SeriesIdentifier:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__SeriesIdentifier * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__SeriesIdentifier * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__StudyRootStudyIdentifier * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__StudyRootStudyIdentifier * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OpenStudyInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__OpenStudyInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__OpenStudyInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Viewer:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__Viewer * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__Viewer * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ImageIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__ImageIdentifier * >*)p)[len] = *(ns5__ImageIdentifier **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__SeriesIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__SeriesIdentifier * >*)p)[len] = *(ns5__SeriesIdentifier **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__StudyRootStudyIdentifier * >*)p)[len] = *(ns5__StudyRootStudyIdentifier **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__OpenStudyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__OpenStudyInfo * >*)p)[len] = *(ns2__OpenStudyInfo **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__Viewer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__Viewer * >*)p)[len] = *(ns2__Viewer **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag?tag:"xsd:byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{	short *p;
	p = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag?tag:"short", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__char(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ns3__char);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_ns3__char(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_ns3__char);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__char(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__char);
	if (soap_out_ns3__char(soap, tag?tag:"ns3:char", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_ns3__char(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__char(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_xsd__unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_xsd__unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte);
	if (soap_out_xsd__unsignedByte(soap, tag?tag:"xsd:unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{	unsigned short *p;
	p = soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag?tag:"unsignedShort", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{	ULONG64 *p;
	p = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns3__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE__ns3__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE__ns3__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in__ns3__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns3__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns3__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy__ns3__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void ns3__guid__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns3__guid(soap, &this->ns3__guid__::__item);
}

void ns3__guid__::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns3__guid(soap, &this->ns3__guid__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns3__guid__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__guid__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__guid__(struct soap *soap, const char *tag, int id, const ns3__guid__ *a, const char *type)
{
	return soap_out_ns3__guid(soap, tag, id, &(a->ns3__guid__::__item), "ns3:guid");
}

void *ns3__guid__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__guid__(soap, tag, this, type);
}

SOAP_FMAC3 ns3__guid__ * SOAP_FMAC4 soap_in_ns3__guid__(struct soap *soap, const char *tag, ns3__guid__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns3__guid__ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__guid__, sizeof(ns3__guid__), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__guid__)
			return (ns3__guid__ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns3__guid(soap, tag, &(a->ns3__guid__::__item), "ns3:guid"))
		return NULL;
	return a;
}

int ns3__guid__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__guid__);
	if (this->soap_out(soap, tag?tag:"ns3:guid", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__guid__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__guid__(soap, this, tag, type);
}

SOAP_FMAC3 ns3__guid__ * SOAP_FMAC4 soap_get_ns3__guid__(struct soap *soap, ns3__guid__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__guid__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__guid__ * SOAP_FMAC2 soap_instantiate_ns3__guid__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__guid__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__guid__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__guid__);
		if (size)
			*size = sizeof(ns3__guid__);
		((ns3__guid__*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__guid__, n);
		if (size)
			*size = n * sizeof(ns3__guid__);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__guid__*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__guid__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__guid__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__guid__ %p -> %p\n", q, p));
	*(ns3__guid__*)p = *(ns3__guid__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__guid(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__guid(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__guid), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__guid(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__guid, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__guid, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__guid, 0, sizeof(std::string), 0, soap_copy_ns3__guid);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__guid(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__guid);
	if (soap_out_ns3__guid(soap, tag?tag:"ns3:guid", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__guid(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__guid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__duration__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns3__duration(soap, &this->ns3__duration__::__item);
}

void ns3__duration__::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns3__duration(soap, &this->ns3__duration__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns3__duration__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__duration__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__duration__(struct soap *soap, const char *tag, int id, const ns3__duration__ *a, const char *type)
{
	return soap_out_ns3__duration(soap, tag, id, &(a->ns3__duration__::__item), "ns3:duration");
}

void *ns3__duration__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__duration__(soap, tag, this, type);
}

SOAP_FMAC3 ns3__duration__ * SOAP_FMAC4 soap_in_ns3__duration__(struct soap *soap, const char *tag, ns3__duration__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns3__duration__ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__duration__, sizeof(ns3__duration__), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__duration__)
			return (ns3__duration__ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns3__duration(soap, tag, &(a->ns3__duration__::__item), "ns3:duration"))
		return NULL;
	return a;
}

int ns3__duration__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__duration__);
	if (this->soap_out(soap, tag?tag:"ns3:duration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__duration__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__duration__(soap, this, tag, type);
}

SOAP_FMAC3 ns3__duration__ * SOAP_FMAC4 soap_get_ns3__duration__(struct soap *soap, ns3__duration__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__duration__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__duration__ * SOAP_FMAC2 soap_instantiate_ns3__duration__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__duration__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__duration__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__duration__);
		if (size)
			*size = sizeof(ns3__duration__);
		((ns3__duration__*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__duration__, n);
		if (size)
			*size = n * sizeof(ns3__duration__);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__duration__*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__duration__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__duration__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__duration__ %p -> %p\n", q, p));
	*(ns3__duration__*)p = *(ns3__duration__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns3__duration(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ns3__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_ns3__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__duration, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ns3__duration, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ns3__duration, 0, sizeof(std::string), 0, soap_copy_ns3__duration);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns3__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns3__duration);
	if (soap_out_ns3__duration(soap, tag?tag:"ns3:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_ns3__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns3__char__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns3__char(soap, &this->ns3__char__::__item);
}

void ns3__char__::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns3__char__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__char__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__char__(struct soap *soap, const char *tag, int id, const ns3__char__ *a, const char *type)
{
	return soap_out_ns3__char(soap, tag, id, &(a->ns3__char__::__item), "ns3:char");
}

void *ns3__char__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__char__(soap, tag, this, type);
}

SOAP_FMAC3 ns3__char__ * SOAP_FMAC4 soap_in_ns3__char__(struct soap *soap, const char *tag, ns3__char__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns3__char__ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__char__, sizeof(ns3__char__), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__char__)
			return (ns3__char__ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_ns3__char(soap, tag, &(a->ns3__char__::__item), "ns3:char"))
		return NULL;
	return a;
}

int ns3__char__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__char__);
	if (this->soap_out(soap, tag?tag:"ns3:char", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__char__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__char__(soap, this, tag, type);
}

SOAP_FMAC3 ns3__char__ * SOAP_FMAC4 soap_get_ns3__char__(struct soap *soap, ns3__char__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__char__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__char__ * SOAP_FMAC2 soap_instantiate_ns3__char__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__char__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__char__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__char__);
		if (size)
			*size = sizeof(ns3__char__);
		((ns3__char__*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__char__, n);
		if (size)
			*size = n * sizeof(ns3__char__);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns3__char__*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns3__char__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__char__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__char__ %p -> %p\n", q, p));
	*(ns3__char__*)p = *(ns3__char__*)q;
}

void ns6__StudyOfflineFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns6__StudyOfflineFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns6__StudyOfflineFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__StudyOfflineFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__StudyOfflineFault(struct soap *soap, const char *tag, int id, const ns6__StudyOfflineFault *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns6:StudyOfflineFault");
}

void *ns6__StudyOfflineFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__StudyOfflineFault(soap, tag, this, type);
}

SOAP_FMAC3 ns6__StudyOfflineFault * SOAP_FMAC4 soap_in_ns6__StudyOfflineFault(struct soap *soap, const char *tag, ns6__StudyOfflineFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__StudyOfflineFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StudyOfflineFault, sizeof(ns6__StudyOfflineFault), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__StudyOfflineFault)
			return (ns6__StudyOfflineFault *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns6__StudyOfflineFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__StudyOfflineFault);
	if (this->soap_out(soap, tag?tag:"ns6:StudyOfflineFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__StudyOfflineFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__StudyOfflineFault(soap, this, tag, type);
}

SOAP_FMAC3 ns6__StudyOfflineFault * SOAP_FMAC4 soap_get_ns6__StudyOfflineFault(struct soap *soap, ns6__StudyOfflineFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__StudyOfflineFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__StudyOfflineFault * SOAP_FMAC2 soap_instantiate_ns6__StudyOfflineFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__StudyOfflineFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__StudyOfflineFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__StudyOfflineFault);
		if (size)
			*size = sizeof(ns6__StudyOfflineFault);
		((ns6__StudyOfflineFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__StudyOfflineFault, n);
		if (size)
			*size = n * sizeof(ns6__StudyOfflineFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns6__StudyOfflineFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns6__StudyOfflineFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__StudyOfflineFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__StudyOfflineFault %p -> %p\n", q, p));
	*(ns6__StudyOfflineFault*)p = *(ns6__StudyOfflineFault*)q;
}

void ns6__StudyInUseFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns6__StudyInUseFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns6__StudyInUseFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__StudyInUseFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__StudyInUseFault(struct soap *soap, const char *tag, int id, const ns6__StudyInUseFault *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns6:StudyInUseFault");
}

void *ns6__StudyInUseFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__StudyInUseFault(soap, tag, this, type);
}

SOAP_FMAC3 ns6__StudyInUseFault * SOAP_FMAC4 soap_in_ns6__StudyInUseFault(struct soap *soap, const char *tag, ns6__StudyInUseFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__StudyInUseFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StudyInUseFault, sizeof(ns6__StudyInUseFault), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__StudyInUseFault)
			return (ns6__StudyInUseFault *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns6__StudyInUseFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__StudyInUseFault);
	if (this->soap_out(soap, tag?tag:"ns6:StudyInUseFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__StudyInUseFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__StudyInUseFault(soap, this, tag, type);
}

SOAP_FMAC3 ns6__StudyInUseFault * SOAP_FMAC4 soap_get_ns6__StudyInUseFault(struct soap *soap, ns6__StudyInUseFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__StudyInUseFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__StudyInUseFault * SOAP_FMAC2 soap_instantiate_ns6__StudyInUseFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__StudyInUseFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__StudyInUseFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__StudyInUseFault);
		if (size)
			*size = sizeof(ns6__StudyInUseFault);
		((ns6__StudyInUseFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__StudyInUseFault, n);
		if (size)
			*size = n * sizeof(ns6__StudyInUseFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns6__StudyInUseFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns6__StudyInUseFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__StudyInUseFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__StudyInUseFault %p -> %p\n", q, p));
	*(ns6__StudyInUseFault*)p = *(ns6__StudyInUseFault*)q;
}

void ns6__StudyNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns6__StudyNotFoundFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns6__StudyNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__StudyNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__StudyNotFoundFault(struct soap *soap, const char *tag, int id, const ns6__StudyNotFoundFault *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns6:StudyNotFoundFault");
}

void *ns6__StudyNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__StudyNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 ns6__StudyNotFoundFault * SOAP_FMAC4 soap_in_ns6__StudyNotFoundFault(struct soap *soap, const char *tag, ns6__StudyNotFoundFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns6__StudyNotFoundFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StudyNotFoundFault, sizeof(ns6__StudyNotFoundFault), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__StudyNotFoundFault)
			return (ns6__StudyNotFoundFault *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns6__StudyNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__StudyNotFoundFault);
	if (this->soap_out(soap, tag?tag:"ns6:StudyNotFoundFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__StudyNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__StudyNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 ns6__StudyNotFoundFault * SOAP_FMAC4 soap_get_ns6__StudyNotFoundFault(struct soap *soap, ns6__StudyNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__StudyNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__StudyNotFoundFault * SOAP_FMAC2 soap_instantiate_ns6__StudyNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__StudyNotFoundFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__StudyNotFoundFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__StudyNotFoundFault);
		if (size)
			*size = sizeof(ns6__StudyNotFoundFault);
		((ns6__StudyNotFoundFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__StudyNotFoundFault, n);
		if (size)
			*size = n * sizeof(ns6__StudyNotFoundFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns6__StudyNotFoundFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns6__StudyNotFoundFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__StudyNotFoundFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__StudyNotFoundFault %p -> %p\n", q, p));
	*(ns6__StudyNotFoundFault*)p = *(ns6__StudyNotFoundFault*)q;
}

void ns6__StudyNearlineFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns6__StudyNearlineFault::IsStudyBeingRestored = NULL;
}

void ns6__StudyNearlineFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->ns6__StudyNearlineFault::IsStudyBeingRestored);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns6__StudyNearlineFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__StudyNearlineFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__StudyNearlineFault(struct soap *soap, const char *tag, int id, const ns6__StudyNearlineFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__StudyNearlineFault), "ns6:StudyNearlineFault"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobool(soap, "ns6:IsStudyBeingRestored", -1, &(a->ns6__StudyNearlineFault::IsStudyBeingRestored), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__StudyNearlineFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__StudyNearlineFault(soap, tag, this, type);
}

SOAP_FMAC3 ns6__StudyNearlineFault * SOAP_FMAC4 soap_in_ns6__StudyNearlineFault(struct soap *soap, const char *tag, ns6__StudyNearlineFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__StudyNearlineFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StudyNearlineFault, sizeof(ns6__StudyNearlineFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__StudyNearlineFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__StudyNearlineFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_IsStudyBeingRestored1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_IsStudyBeingRestored1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns6:IsStudyBeingRestored", &(a->ns6__StudyNearlineFault::IsStudyBeingRestored), "xsd:boolean"))
				{	soap_flag_IsStudyBeingRestored1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__StudyNearlineFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__StudyNearlineFault, 0, sizeof(ns6__StudyNearlineFault), 0, soap_copy_ns6__StudyNearlineFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns6__StudyNearlineFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__StudyNearlineFault);
	if (this->soap_out(soap, tag?tag:"ns6:StudyNearlineFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__StudyNearlineFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__StudyNearlineFault(soap, this, tag, type);
}

SOAP_FMAC3 ns6__StudyNearlineFault * SOAP_FMAC4 soap_get_ns6__StudyNearlineFault(struct soap *soap, ns6__StudyNearlineFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__StudyNearlineFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__StudyNearlineFault * SOAP_FMAC2 soap_instantiate_ns6__StudyNearlineFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__StudyNearlineFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__StudyNearlineFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__StudyNearlineFault);
		if (size)
			*size = sizeof(ns6__StudyNearlineFault);
		((ns6__StudyNearlineFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__StudyNearlineFault, n);
		if (size)
			*size = n * sizeof(ns6__StudyNearlineFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns6__StudyNearlineFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns6__StudyNearlineFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__StudyNearlineFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__StudyNearlineFault %p -> %p\n", q, p));
	*(ns6__StudyNearlineFault*)p = *(ns6__StudyNearlineFault*)q;
}

void _ns5__ImageQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__ImageQueryResponse::ImageQueryResult = NULL;
	/* transient soap skipped */
}

void _ns5__ImageQueryResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__ArrayOfImageIdentifier(soap, &this->_ns5__ImageQueryResponse::ImageQueryResult);
	/* transient soap skipped */
#endif
}

int _ns5__ImageQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__ImageQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__ImageQueryResponse(struct soap *soap, const char *tag, int id, const _ns5__ImageQueryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__ImageQueryResponse), type))
		return soap->error;
	if (a->ImageQueryResult)
		soap_element_result(soap, "ns5:ImageQueryResult");
	if (soap_out_PointerTons5__ArrayOfImageIdentifier(soap, "ns5:ImageQueryResult", -1, &(a->_ns5__ImageQueryResponse::ImageQueryResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__ImageQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__ImageQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__ImageQueryResponse * SOAP_FMAC4 soap_in__ns5__ImageQueryResponse(struct soap *soap, const char *tag, _ns5__ImageQueryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__ImageQueryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ImageQueryResponse, sizeof(_ns5__ImageQueryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__ImageQueryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__ImageQueryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ImageQueryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageQueryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ArrayOfImageIdentifier(soap, "ns5:ImageQueryResult", &(a->_ns5__ImageQueryResponse::ImageQueryResult), "ns5:ArrayOfImageIdentifier"))
				{	soap_flag_ImageQueryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns5:ImageQueryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__ImageQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ImageQueryResponse, 0, sizeof(_ns5__ImageQueryResponse), 0, soap_copy__ns5__ImageQueryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns5__ImageQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__ImageQueryResponse);
	if (this->soap_out(soap, tag?tag:"ns5:ImageQueryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__ImageQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__ImageQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__ImageQueryResponse * SOAP_FMAC4 soap_get__ns5__ImageQueryResponse(struct soap *soap, _ns5__ImageQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__ImageQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__ImageQueryResponse * SOAP_FMAC2 soap_instantiate__ns5__ImageQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__ImageQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__ImageQueryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__ImageQueryResponse);
		if (size)
			*size = sizeof(_ns5__ImageQueryResponse);
		((_ns5__ImageQueryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__ImageQueryResponse, n);
		if (size)
			*size = n * sizeof(_ns5__ImageQueryResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__ImageQueryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__ImageQueryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__ImageQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__ImageQueryResponse %p -> %p\n", q, p));
	*(_ns5__ImageQueryResponse*)p = *(_ns5__ImageQueryResponse*)q;
}

void _ns5__ImageQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__ImageQuery::queryCriteria = NULL;
	/* transient soap skipped */
}

void _ns5__ImageQuery::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__ImageIdentifier(soap, &this->_ns5__ImageQuery::queryCriteria);
	/* transient soap skipped */
#endif
}

int _ns5__ImageQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__ImageQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__ImageQuery(struct soap *soap, const char *tag, int id, const _ns5__ImageQuery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__ImageQuery), type))
		return soap->error;
	if (soap_out_PointerTons5__ImageIdentifier(soap, "ns5:queryCriteria", -1, &(a->_ns5__ImageQuery::queryCriteria), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__ImageQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__ImageQuery(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__ImageQuery * SOAP_FMAC4 soap_in__ns5__ImageQuery(struct soap *soap, const char *tag, _ns5__ImageQuery *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__ImageQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__ImageQuery, sizeof(_ns5__ImageQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__ImageQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__ImageQuery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_queryCriteria1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queryCriteria1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ImageIdentifier(soap, "ns5:queryCriteria", &(a->_ns5__ImageQuery::queryCriteria), "ns5:ImageIdentifier"))
				{	soap_flag_queryCriteria1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__ImageQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__ImageQuery, 0, sizeof(_ns5__ImageQuery), 0, soap_copy__ns5__ImageQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns5__ImageQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__ImageQuery);
	if (this->soap_out(soap, tag?tag:"ns5:ImageQuery", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__ImageQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__ImageQuery(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__ImageQuery * SOAP_FMAC4 soap_get__ns5__ImageQuery(struct soap *soap, _ns5__ImageQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__ImageQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__ImageQuery * SOAP_FMAC2 soap_instantiate__ns5__ImageQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__ImageQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__ImageQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__ImageQuery);
		if (size)
			*size = sizeof(_ns5__ImageQuery);
		((_ns5__ImageQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__ImageQuery, n);
		if (size)
			*size = n * sizeof(_ns5__ImageQuery);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__ImageQuery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__ImageQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__ImageQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__ImageQuery %p -> %p\n", q, p));
	*(_ns5__ImageQuery*)p = *(_ns5__ImageQuery*)q;
}

void _ns5__SeriesQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__SeriesQueryResponse::SeriesQueryResult = NULL;
	/* transient soap skipped */
}

void _ns5__SeriesQueryResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__ArrayOfSeriesIdentifier(soap, &this->_ns5__SeriesQueryResponse::SeriesQueryResult);
	/* transient soap skipped */
#endif
}

int _ns5__SeriesQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__SeriesQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__SeriesQueryResponse(struct soap *soap, const char *tag, int id, const _ns5__SeriesQueryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__SeriesQueryResponse), type))
		return soap->error;
	if (a->SeriesQueryResult)
		soap_element_result(soap, "ns5:SeriesQueryResult");
	if (soap_out_PointerTons5__ArrayOfSeriesIdentifier(soap, "ns5:SeriesQueryResult", -1, &(a->_ns5__SeriesQueryResponse::SeriesQueryResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__SeriesQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__SeriesQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__SeriesQueryResponse * SOAP_FMAC4 soap_in__ns5__SeriesQueryResponse(struct soap *soap, const char *tag, _ns5__SeriesQueryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__SeriesQueryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__SeriesQueryResponse, sizeof(_ns5__SeriesQueryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__SeriesQueryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__SeriesQueryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SeriesQueryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SeriesQueryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ArrayOfSeriesIdentifier(soap, "ns5:SeriesQueryResult", &(a->_ns5__SeriesQueryResponse::SeriesQueryResult), "ns5:ArrayOfSeriesIdentifier"))
				{	soap_flag_SeriesQueryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns5:SeriesQueryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__SeriesQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__SeriesQueryResponse, 0, sizeof(_ns5__SeriesQueryResponse), 0, soap_copy__ns5__SeriesQueryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns5__SeriesQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__SeriesQueryResponse);
	if (this->soap_out(soap, tag?tag:"ns5:SeriesQueryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__SeriesQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__SeriesQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__SeriesQueryResponse * SOAP_FMAC4 soap_get__ns5__SeriesQueryResponse(struct soap *soap, _ns5__SeriesQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__SeriesQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__SeriesQueryResponse * SOAP_FMAC2 soap_instantiate__ns5__SeriesQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__SeriesQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__SeriesQueryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__SeriesQueryResponse);
		if (size)
			*size = sizeof(_ns5__SeriesQueryResponse);
		((_ns5__SeriesQueryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__SeriesQueryResponse, n);
		if (size)
			*size = n * sizeof(_ns5__SeriesQueryResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__SeriesQueryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__SeriesQueryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__SeriesQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__SeriesQueryResponse %p -> %p\n", q, p));
	*(_ns5__SeriesQueryResponse*)p = *(_ns5__SeriesQueryResponse*)q;
}

void _ns5__SeriesQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__SeriesQuery::queryCriteria = NULL;
	/* transient soap skipped */
}

void _ns5__SeriesQuery::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__SeriesIdentifier(soap, &this->_ns5__SeriesQuery::queryCriteria);
	/* transient soap skipped */
#endif
}

int _ns5__SeriesQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__SeriesQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__SeriesQuery(struct soap *soap, const char *tag, int id, const _ns5__SeriesQuery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__SeriesQuery), type))
		return soap->error;
	if (soap_out_PointerTons5__SeriesIdentifier(soap, "ns5:queryCriteria", -1, &(a->_ns5__SeriesQuery::queryCriteria), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__SeriesQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__SeriesQuery(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__SeriesQuery * SOAP_FMAC4 soap_in__ns5__SeriesQuery(struct soap *soap, const char *tag, _ns5__SeriesQuery *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__SeriesQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__SeriesQuery, sizeof(_ns5__SeriesQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__SeriesQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__SeriesQuery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_queryCriteria1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queryCriteria1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__SeriesIdentifier(soap, "ns5:queryCriteria", &(a->_ns5__SeriesQuery::queryCriteria), "ns5:SeriesIdentifier"))
				{	soap_flag_queryCriteria1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__SeriesQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__SeriesQuery, 0, sizeof(_ns5__SeriesQuery), 0, soap_copy__ns5__SeriesQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns5__SeriesQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__SeriesQuery);
	if (this->soap_out(soap, tag?tag:"ns5:SeriesQuery", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__SeriesQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__SeriesQuery(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__SeriesQuery * SOAP_FMAC4 soap_get__ns5__SeriesQuery(struct soap *soap, _ns5__SeriesQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__SeriesQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__SeriesQuery * SOAP_FMAC2 soap_instantiate__ns5__SeriesQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__SeriesQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__SeriesQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__SeriesQuery);
		if (size)
			*size = sizeof(_ns5__SeriesQuery);
		((_ns5__SeriesQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__SeriesQuery, n);
		if (size)
			*size = n * sizeof(_ns5__SeriesQuery);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__SeriesQuery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__SeriesQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__SeriesQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__SeriesQuery %p -> %p\n", q, p));
	*(_ns5__SeriesQuery*)p = *(_ns5__SeriesQuery*)q;
}

void _ns5__StudyQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__StudyQueryResponse::StudyQueryResult = NULL;
	/* transient soap skipped */
}

void _ns5__StudyQueryResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__ArrayOfStudyRootStudyIdentifier(soap, &this->_ns5__StudyQueryResponse::StudyQueryResult);
	/* transient soap skipped */
#endif
}

int _ns5__StudyQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__StudyQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__StudyQueryResponse(struct soap *soap, const char *tag, int id, const _ns5__StudyQueryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__StudyQueryResponse), type))
		return soap->error;
	if (a->StudyQueryResult)
		soap_element_result(soap, "ns5:StudyQueryResult");
	if (soap_out_PointerTons5__ArrayOfStudyRootStudyIdentifier(soap, "ns5:StudyQueryResult", -1, &(a->_ns5__StudyQueryResponse::StudyQueryResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__StudyQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__StudyQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__StudyQueryResponse * SOAP_FMAC4 soap_in__ns5__StudyQueryResponse(struct soap *soap, const char *tag, _ns5__StudyQueryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__StudyQueryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__StudyQueryResponse, sizeof(_ns5__StudyQueryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__StudyQueryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__StudyQueryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_StudyQueryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StudyQueryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ArrayOfStudyRootStudyIdentifier(soap, "ns5:StudyQueryResult", &(a->_ns5__StudyQueryResponse::StudyQueryResult), "ns5:ArrayOfStudyRootStudyIdentifier"))
				{	soap_flag_StudyQueryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns5:StudyQueryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__StudyQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__StudyQueryResponse, 0, sizeof(_ns5__StudyQueryResponse), 0, soap_copy__ns5__StudyQueryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns5__StudyQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__StudyQueryResponse);
	if (this->soap_out(soap, tag?tag:"ns5:StudyQueryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__StudyQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__StudyQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__StudyQueryResponse * SOAP_FMAC4 soap_get__ns5__StudyQueryResponse(struct soap *soap, _ns5__StudyQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__StudyQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__StudyQueryResponse * SOAP_FMAC2 soap_instantiate__ns5__StudyQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__StudyQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__StudyQueryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__StudyQueryResponse);
		if (size)
			*size = sizeof(_ns5__StudyQueryResponse);
		((_ns5__StudyQueryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__StudyQueryResponse, n);
		if (size)
			*size = n * sizeof(_ns5__StudyQueryResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__StudyQueryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__StudyQueryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__StudyQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__StudyQueryResponse %p -> %p\n", q, p));
	*(_ns5__StudyQueryResponse*)p = *(_ns5__StudyQueryResponse*)q;
}

void _ns5__StudyQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns5__StudyQuery::queryCriteria = NULL;
	/* transient soap skipped */
}

void _ns5__StudyQuery::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__StudyRootStudyIdentifier(soap, &this->_ns5__StudyQuery::queryCriteria);
	/* transient soap skipped */
#endif
}

int _ns5__StudyQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns5__StudyQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__StudyQuery(struct soap *soap, const char *tag, int id, const _ns5__StudyQuery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__StudyQuery), type))
		return soap->error;
	if (soap_out_PointerTons5__StudyRootStudyIdentifier(soap, "ns5:queryCriteria", -1, &(a->_ns5__StudyQuery::queryCriteria), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns5__StudyQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns5__StudyQuery(soap, tag, this, type);
}

SOAP_FMAC3 _ns5__StudyQuery * SOAP_FMAC4 soap_in__ns5__StudyQuery(struct soap *soap, const char *tag, _ns5__StudyQuery *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns5__StudyQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__StudyQuery, sizeof(_ns5__StudyQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns5__StudyQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns5__StudyQuery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_queryCriteria1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queryCriteria1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__StudyRootStudyIdentifier(soap, "ns5:queryCriteria", &(a->_ns5__StudyQuery::queryCriteria), "ns5:StudyRootStudyIdentifier"))
				{	soap_flag_queryCriteria1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns5__StudyQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__StudyQuery, 0, sizeof(_ns5__StudyQuery), 0, soap_copy__ns5__StudyQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns5__StudyQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns5__StudyQuery);
	if (this->soap_out(soap, tag?tag:"ns5:StudyQuery", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns5__StudyQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns5__StudyQuery(soap, this, tag, type);
}

SOAP_FMAC3 _ns5__StudyQuery * SOAP_FMAC4 soap_get__ns5__StudyQuery(struct soap *soap, _ns5__StudyQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__StudyQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns5__StudyQuery * SOAP_FMAC2 soap_instantiate__ns5__StudyQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns5__StudyQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns5__StudyQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns5__StudyQuery);
		if (size)
			*size = sizeof(_ns5__StudyQuery);
		((_ns5__StudyQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns5__StudyQuery, n);
		if (size)
			*size = n * sizeof(_ns5__StudyQuery);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns5__StudyQuery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns5__StudyQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns5__StudyQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns5__StudyQuery %p -> %p\n", q, p));
	*(_ns5__StudyQuery*)p = *(_ns5__StudyQuery*)q;
}

void ns5__ArrayOfImageIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTons5__ImageIdentifier(soap, &this->ns5__ArrayOfImageIdentifier::ImageIdentifier);
}

void ns5__ArrayOfImageIdentifier::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__ImageIdentifier(soap, &this->ns5__ArrayOfImageIdentifier::ImageIdentifier);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__ArrayOfImageIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ArrayOfImageIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ArrayOfImageIdentifier(struct soap *soap, const char *tag, int id, const ns5__ArrayOfImageIdentifier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ArrayOfImageIdentifier), "ns5:ArrayOfImageIdentifier"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons5__ImageIdentifier(soap, "ns5:ImageIdentifier", -1, &(a->ns5__ArrayOfImageIdentifier::ImageIdentifier), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ArrayOfImageIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ArrayOfImageIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ArrayOfImageIdentifier * SOAP_FMAC4 soap_in_ns5__ArrayOfImageIdentifier(struct soap *soap, const char *tag, ns5__ArrayOfImageIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ArrayOfImageIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ArrayOfImageIdentifier, sizeof(ns5__ArrayOfImageIdentifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ArrayOfImageIdentifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ArrayOfImageIdentifier *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ImageIdentifier(soap, "ns5:ImageIdentifier", &(a->ns5__ArrayOfImageIdentifier::ImageIdentifier), "ns5:ImageIdentifier"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ArrayOfImageIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ArrayOfImageIdentifier, 0, sizeof(ns5__ArrayOfImageIdentifier), 0, soap_copy_ns5__ArrayOfImageIdentifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ArrayOfImageIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ArrayOfImageIdentifier);
	if (this->soap_out(soap, tag?tag:"ns5:ArrayOfImageIdentifier", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ArrayOfImageIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ArrayOfImageIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ArrayOfImageIdentifier * SOAP_FMAC4 soap_get_ns5__ArrayOfImageIdentifier(struct soap *soap, ns5__ArrayOfImageIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ArrayOfImageIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ArrayOfImageIdentifier * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfImageIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ArrayOfImageIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ArrayOfImageIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ArrayOfImageIdentifier);
		if (size)
			*size = sizeof(ns5__ArrayOfImageIdentifier);
		((ns5__ArrayOfImageIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ArrayOfImageIdentifier, n);
		if (size)
			*size = n * sizeof(ns5__ArrayOfImageIdentifier);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__ArrayOfImageIdentifier*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__ArrayOfImageIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ArrayOfImageIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ArrayOfImageIdentifier %p -> %p\n", q, p));
	*(ns5__ArrayOfImageIdentifier*)p = *(ns5__ArrayOfImageIdentifier*)q;
}

void ns5__ImageIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__Identifier::soap_default(soap);
	this->ns5__ImageIdentifier::InstanceNumber = NULL;
	this->ns5__ImageIdentifier::SeriesInstanceUid = NULL;
	this->ns5__ImageIdentifier::SopClassUid = NULL;
	this->ns5__ImageIdentifier::SopInstanceUid = NULL;
	this->ns5__ImageIdentifier::StudyInstanceUid = NULL;
}

void ns5__ImageIdentifier::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &this->ns5__ImageIdentifier::InstanceNumber);
	soap_serialize_PointerTostd__string(soap, &this->ns5__ImageIdentifier::SeriesInstanceUid);
	soap_serialize_PointerTostd__string(soap, &this->ns5__ImageIdentifier::SopClassUid);
	soap_serialize_PointerTostd__string(soap, &this->ns5__ImageIdentifier::SopInstanceUid);
	soap_serialize_PointerTostd__string(soap, &this->ns5__ImageIdentifier::StudyInstanceUid);
	this->ns5__Identifier::soap_serialize(soap);
#endif
}

int ns5__ImageIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ImageIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ImageIdentifier(struct soap *soap, const char *tag, int id, const ns5__ImageIdentifier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ImageIdentifier), "ns5:ImageIdentifier"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns5:InstanceAvailability", -1, &(a->ns5__Identifier::InstanceAvailability), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:RetrieveAeTitle", -1, &(a->ns5__Identifier::RetrieveAeTitle), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SpecificCharacterSet", -1, &(a->ns5__Identifier::SpecificCharacterSet), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:InstanceNumber", -1, &(a->ns5__ImageIdentifier::InstanceNumber), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SeriesInstanceUid", -1, &(a->ns5__ImageIdentifier::SeriesInstanceUid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SopClassUid", -1, &(a->ns5__ImageIdentifier::SopClassUid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SopInstanceUid", -1, &(a->ns5__ImageIdentifier::SopInstanceUid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyInstanceUid", -1, &(a->ns5__ImageIdentifier::StudyInstanceUid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ImageIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ImageIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ImageIdentifier * SOAP_FMAC4 soap_in_ns5__ImageIdentifier(struct soap *soap, const char *tag, ns5__ImageIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ImageIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ImageIdentifier, sizeof(ns5__ImageIdentifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ImageIdentifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ImageIdentifier *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_InstanceAvailability2 = 1;
	size_t soap_flag_RetrieveAeTitle2 = 1;
	size_t soap_flag_SpecificCharacterSet2 = 1;
	size_t soap_flag_InstanceNumber1 = 1;
	size_t soap_flag_SeriesInstanceUid1 = 1;
	size_t soap_flag_SopClassUid1 = 1;
	size_t soap_flag_SopInstanceUid1 = 1;
	size_t soap_flag_StudyInstanceUid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_InstanceAvailability2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:InstanceAvailability", &(a->ns5__Identifier::InstanceAvailability), "xsd:string"))
				{	soap_flag_InstanceAvailability2--;
					continue;
				}
			if (soap_flag_RetrieveAeTitle2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetrieveAeTitle", &(a->ns5__Identifier::RetrieveAeTitle), "xsd:string"))
				{	soap_flag_RetrieveAeTitle2--;
					continue;
				}
			if (soap_flag_SpecificCharacterSet2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SpecificCharacterSet", &(a->ns5__Identifier::SpecificCharacterSet), "xsd:string"))
				{	soap_flag_SpecificCharacterSet2--;
					continue;
				}
			if (soap_flag_InstanceNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns5:InstanceNumber", &(a->ns5__ImageIdentifier::InstanceNumber), "xsd:int"))
				{	soap_flag_InstanceNumber1--;
					continue;
				}
			if (soap_flag_SeriesInstanceUid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SeriesInstanceUid", &(a->ns5__ImageIdentifier::SeriesInstanceUid), "xsd:string"))
				{	soap_flag_SeriesInstanceUid1--;
					continue;
				}
			if (soap_flag_SopClassUid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SopClassUid", &(a->ns5__ImageIdentifier::SopClassUid), "xsd:string"))
				{	soap_flag_SopClassUid1--;
					continue;
				}
			if (soap_flag_SopInstanceUid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SopInstanceUid", &(a->ns5__ImageIdentifier::SopInstanceUid), "xsd:string"))
				{	soap_flag_SopInstanceUid1--;
					continue;
				}
			if (soap_flag_StudyInstanceUid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyInstanceUid", &(a->ns5__ImageIdentifier::StudyInstanceUid), "xsd:string"))
				{	soap_flag_StudyInstanceUid1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ImageIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ImageIdentifier, 0, sizeof(ns5__ImageIdentifier), 0, soap_copy_ns5__ImageIdentifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ImageIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ImageIdentifier);
	if (this->soap_out(soap, tag?tag:"ns5:ImageIdentifier", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ImageIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ImageIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ImageIdentifier * SOAP_FMAC4 soap_get_ns5__ImageIdentifier(struct soap *soap, ns5__ImageIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ImageIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ImageIdentifier * SOAP_FMAC2 soap_instantiate_ns5__ImageIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ImageIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ImageIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ImageIdentifier);
		if (size)
			*size = sizeof(ns5__ImageIdentifier);
		((ns5__ImageIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ImageIdentifier, n);
		if (size)
			*size = n * sizeof(ns5__ImageIdentifier);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__ImageIdentifier*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__ImageIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ImageIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ImageIdentifier %p -> %p\n", q, p));
	*(ns5__ImageIdentifier*)p = *(ns5__ImageIdentifier*)q;
}

void ns5__ArrayOfSeriesIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTons5__SeriesIdentifier(soap, &this->ns5__ArrayOfSeriesIdentifier::SeriesIdentifier);
}

void ns5__ArrayOfSeriesIdentifier::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__SeriesIdentifier(soap, &this->ns5__ArrayOfSeriesIdentifier::SeriesIdentifier);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__ArrayOfSeriesIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ArrayOfSeriesIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ArrayOfSeriesIdentifier(struct soap *soap, const char *tag, int id, const ns5__ArrayOfSeriesIdentifier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ArrayOfSeriesIdentifier), "ns5:ArrayOfSeriesIdentifier"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons5__SeriesIdentifier(soap, "ns5:SeriesIdentifier", -1, &(a->ns5__ArrayOfSeriesIdentifier::SeriesIdentifier), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ArrayOfSeriesIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ArrayOfSeriesIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ArrayOfSeriesIdentifier * SOAP_FMAC4 soap_in_ns5__ArrayOfSeriesIdentifier(struct soap *soap, const char *tag, ns5__ArrayOfSeriesIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ArrayOfSeriesIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ArrayOfSeriesIdentifier, sizeof(ns5__ArrayOfSeriesIdentifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ArrayOfSeriesIdentifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ArrayOfSeriesIdentifier *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__SeriesIdentifier(soap, "ns5:SeriesIdentifier", &(a->ns5__ArrayOfSeriesIdentifier::SeriesIdentifier), "ns5:SeriesIdentifier"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ArrayOfSeriesIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ArrayOfSeriesIdentifier, 0, sizeof(ns5__ArrayOfSeriesIdentifier), 0, soap_copy_ns5__ArrayOfSeriesIdentifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ArrayOfSeriesIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ArrayOfSeriesIdentifier);
	if (this->soap_out(soap, tag?tag:"ns5:ArrayOfSeriesIdentifier", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ArrayOfSeriesIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ArrayOfSeriesIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ArrayOfSeriesIdentifier * SOAP_FMAC4 soap_get_ns5__ArrayOfSeriesIdentifier(struct soap *soap, ns5__ArrayOfSeriesIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ArrayOfSeriesIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ArrayOfSeriesIdentifier * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfSeriesIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ArrayOfSeriesIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ArrayOfSeriesIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ArrayOfSeriesIdentifier);
		if (size)
			*size = sizeof(ns5__ArrayOfSeriesIdentifier);
		((ns5__ArrayOfSeriesIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ArrayOfSeriesIdentifier, n);
		if (size)
			*size = n * sizeof(ns5__ArrayOfSeriesIdentifier);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__ArrayOfSeriesIdentifier*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__ArrayOfSeriesIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ArrayOfSeriesIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ArrayOfSeriesIdentifier %p -> %p\n", q, p));
	*(ns5__ArrayOfSeriesIdentifier*)p = *(ns5__ArrayOfSeriesIdentifier*)q;
}

void ns5__SeriesIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__Identifier::soap_default(soap);
	this->ns5__SeriesIdentifier::Modality = NULL;
	this->ns5__SeriesIdentifier::NumberOfSeriesRelatedInstances = NULL;
	this->ns5__SeriesIdentifier::SeriesDescription = NULL;
	this->ns5__SeriesIdentifier::SeriesInstanceUid = NULL;
	this->ns5__SeriesIdentifier::SeriesNumber = NULL;
	this->ns5__SeriesIdentifier::StudyInstanceUid = NULL;
}

void ns5__SeriesIdentifier::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns5__SeriesIdentifier::Modality);
	soap_serialize_PointerToint(soap, &this->ns5__SeriesIdentifier::NumberOfSeriesRelatedInstances);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SeriesIdentifier::SeriesDescription);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SeriesIdentifier::SeriesInstanceUid);
	soap_serialize_PointerToint(soap, &this->ns5__SeriesIdentifier::SeriesNumber);
	soap_serialize_PointerTostd__string(soap, &this->ns5__SeriesIdentifier::StudyInstanceUid);
	this->ns5__Identifier::soap_serialize(soap);
#endif
}

int ns5__SeriesIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__SeriesIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__SeriesIdentifier(struct soap *soap, const char *tag, int id, const ns5__SeriesIdentifier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__SeriesIdentifier), "ns5:SeriesIdentifier"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns5:InstanceAvailability", -1, &(a->ns5__Identifier::InstanceAvailability), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:RetrieveAeTitle", -1, &(a->ns5__Identifier::RetrieveAeTitle), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SpecificCharacterSet", -1, &(a->ns5__Identifier::SpecificCharacterSet), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:Modality", -1, &(a->ns5__SeriesIdentifier::Modality), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:NumberOfSeriesRelatedInstances", -1, &(a->ns5__SeriesIdentifier::NumberOfSeriesRelatedInstances), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SeriesDescription", -1, &(a->ns5__SeriesIdentifier::SeriesDescription), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SeriesInstanceUid", -1, &(a->ns5__SeriesIdentifier::SeriesInstanceUid), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:SeriesNumber", -1, &(a->ns5__SeriesIdentifier::SeriesNumber), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyInstanceUid", -1, &(a->ns5__SeriesIdentifier::StudyInstanceUid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__SeriesIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__SeriesIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 ns5__SeriesIdentifier * SOAP_FMAC4 soap_in_ns5__SeriesIdentifier(struct soap *soap, const char *tag, ns5__SeriesIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__SeriesIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__SeriesIdentifier, sizeof(ns5__SeriesIdentifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__SeriesIdentifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__SeriesIdentifier *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_InstanceAvailability2 = 1;
	size_t soap_flag_RetrieveAeTitle2 = 1;
	size_t soap_flag_SpecificCharacterSet2 = 1;
	size_t soap_flag_Modality1 = 1;
	size_t soap_flag_NumberOfSeriesRelatedInstances1 = 1;
	size_t soap_flag_SeriesDescription1 = 1;
	size_t soap_flag_SeriesInstanceUid1 = 1;
	size_t soap_flag_SeriesNumber1 = 1;
	size_t soap_flag_StudyInstanceUid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_InstanceAvailability2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:InstanceAvailability", &(a->ns5__Identifier::InstanceAvailability), "xsd:string"))
				{	soap_flag_InstanceAvailability2--;
					continue;
				}
			if (soap_flag_RetrieveAeTitle2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetrieveAeTitle", &(a->ns5__Identifier::RetrieveAeTitle), "xsd:string"))
				{	soap_flag_RetrieveAeTitle2--;
					continue;
				}
			if (soap_flag_SpecificCharacterSet2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SpecificCharacterSet", &(a->ns5__Identifier::SpecificCharacterSet), "xsd:string"))
				{	soap_flag_SpecificCharacterSet2--;
					continue;
				}
			if (soap_flag_Modality1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:Modality", &(a->ns5__SeriesIdentifier::Modality), "xsd:string"))
				{	soap_flag_Modality1--;
					continue;
				}
			if (soap_flag_NumberOfSeriesRelatedInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns5:NumberOfSeriesRelatedInstances", &(a->ns5__SeriesIdentifier::NumberOfSeriesRelatedInstances), "xsd:int"))
				{	soap_flag_NumberOfSeriesRelatedInstances1--;
					continue;
				}
			if (soap_flag_SeriesDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SeriesDescription", &(a->ns5__SeriesIdentifier::SeriesDescription), "xsd:string"))
				{	soap_flag_SeriesDescription1--;
					continue;
				}
			if (soap_flag_SeriesInstanceUid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SeriesInstanceUid", &(a->ns5__SeriesIdentifier::SeriesInstanceUid), "xsd:string"))
				{	soap_flag_SeriesInstanceUid1--;
					continue;
				}
			if (soap_flag_SeriesNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns5:SeriesNumber", &(a->ns5__SeriesIdentifier::SeriesNumber), "xsd:int"))
				{	soap_flag_SeriesNumber1--;
					continue;
				}
			if (soap_flag_StudyInstanceUid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyInstanceUid", &(a->ns5__SeriesIdentifier::StudyInstanceUid), "xsd:string"))
				{	soap_flag_StudyInstanceUid1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__SeriesIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__SeriesIdentifier, 0, sizeof(ns5__SeriesIdentifier), 0, soap_copy_ns5__SeriesIdentifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__SeriesIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__SeriesIdentifier);
	if (this->soap_out(soap, tag?tag:"ns5:SeriesIdentifier", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__SeriesIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__SeriesIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 ns5__SeriesIdentifier * SOAP_FMAC4 soap_get_ns5__SeriesIdentifier(struct soap *soap, ns5__SeriesIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__SeriesIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__SeriesIdentifier * SOAP_FMAC2 soap_instantiate_ns5__SeriesIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__SeriesIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__SeriesIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__SeriesIdentifier);
		if (size)
			*size = sizeof(ns5__SeriesIdentifier);
		((ns5__SeriesIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__SeriesIdentifier, n);
		if (size)
			*size = n * sizeof(ns5__SeriesIdentifier);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__SeriesIdentifier*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__SeriesIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__SeriesIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__SeriesIdentifier %p -> %p\n", q, p));
	*(ns5__SeriesIdentifier*)p = *(ns5__SeriesIdentifier*)q;
}

void ns5__DataValidationFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns5__DataValidationFault::Description = NULL;
}

void ns5__DataValidationFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns5__DataValidationFault::Description);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__DataValidationFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__DataValidationFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DataValidationFault(struct soap *soap, const char *tag, int id, const ns5__DataValidationFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__DataValidationFault), "ns5:DataValidationFault"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns5:Description", -1, &(a->ns5__DataValidationFault::Description), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__DataValidationFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__DataValidationFault(soap, tag, this, type);
}

SOAP_FMAC3 ns5__DataValidationFault * SOAP_FMAC4 soap_in_ns5__DataValidationFault(struct soap *soap, const char *tag, ns5__DataValidationFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__DataValidationFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DataValidationFault, sizeof(ns5__DataValidationFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__DataValidationFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__DataValidationFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:Description", &(a->ns5__DataValidationFault::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__DataValidationFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DataValidationFault, 0, sizeof(ns5__DataValidationFault), 0, soap_copy_ns5__DataValidationFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__DataValidationFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__DataValidationFault);
	if (this->soap_out(soap, tag?tag:"ns5:DataValidationFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__DataValidationFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__DataValidationFault(soap, this, tag, type);
}

SOAP_FMAC3 ns5__DataValidationFault * SOAP_FMAC4 soap_get_ns5__DataValidationFault(struct soap *soap, ns5__DataValidationFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DataValidationFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__DataValidationFault * SOAP_FMAC2 soap_instantiate_ns5__DataValidationFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__DataValidationFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__DataValidationFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__DataValidationFault);
		if (size)
			*size = sizeof(ns5__DataValidationFault);
		((ns5__DataValidationFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__DataValidationFault, n);
		if (size)
			*size = n * sizeof(ns5__DataValidationFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__DataValidationFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__DataValidationFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__DataValidationFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__DataValidationFault %p -> %p\n", q, p));
	*(ns5__DataValidationFault*)p = *(ns5__DataValidationFault*)q;
}

void ns5__QueryFailedFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns5__QueryFailedFault::Description = NULL;
}

void ns5__QueryFailedFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns5__QueryFailedFault::Description);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__QueryFailedFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__QueryFailedFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__QueryFailedFault(struct soap *soap, const char *tag, int id, const ns5__QueryFailedFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__QueryFailedFault), "ns5:QueryFailedFault"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns5:Description", -1, &(a->ns5__QueryFailedFault::Description), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__QueryFailedFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__QueryFailedFault(soap, tag, this, type);
}

SOAP_FMAC3 ns5__QueryFailedFault * SOAP_FMAC4 soap_in_ns5__QueryFailedFault(struct soap *soap, const char *tag, ns5__QueryFailedFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__QueryFailedFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__QueryFailedFault, sizeof(ns5__QueryFailedFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__QueryFailedFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__QueryFailedFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:Description", &(a->ns5__QueryFailedFault::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__QueryFailedFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__QueryFailedFault, 0, sizeof(ns5__QueryFailedFault), 0, soap_copy_ns5__QueryFailedFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__QueryFailedFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__QueryFailedFault);
	if (this->soap_out(soap, tag?tag:"ns5:QueryFailedFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__QueryFailedFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__QueryFailedFault(soap, this, tag, type);
}

SOAP_FMAC3 ns5__QueryFailedFault * SOAP_FMAC4 soap_get_ns5__QueryFailedFault(struct soap *soap, ns5__QueryFailedFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__QueryFailedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__QueryFailedFault * SOAP_FMAC2 soap_instantiate_ns5__QueryFailedFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__QueryFailedFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__QueryFailedFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__QueryFailedFault);
		if (size)
			*size = sizeof(ns5__QueryFailedFault);
		((ns5__QueryFailedFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__QueryFailedFault, n);
		if (size)
			*size = n * sizeof(ns5__QueryFailedFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__QueryFailedFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__QueryFailedFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__QueryFailedFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__QueryFailedFault %p -> %p\n", q, p));
	*(ns5__QueryFailedFault*)p = *(ns5__QueryFailedFault*)q;
}

void ns5__ArrayOfStudyRootStudyIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(soap, &this->ns5__ArrayOfStudyRootStudyIdentifier::StudyRootStudyIdentifier);
}

void ns5__ArrayOfStudyRootStudyIdentifier::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(soap, &this->ns5__ArrayOfStudyRootStudyIdentifier::StudyRootStudyIdentifier);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__ArrayOfStudyRootStudyIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ArrayOfStudyRootStudyIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, const char *tag, int id, const ns5__ArrayOfStudyRootStudyIdentifier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier), "ns5:ArrayOfStudyRootStudyIdentifier"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(soap, "ns5:StudyRootStudyIdentifier", -1, &(a->ns5__ArrayOfStudyRootStudyIdentifier::StudyRootStudyIdentifier), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__ArrayOfStudyRootStudyIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ArrayOfStudyRootStudyIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ArrayOfStudyRootStudyIdentifier * SOAP_FMAC4 soap_in_ns5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, const char *tag, ns5__ArrayOfStudyRootStudyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ArrayOfStudyRootStudyIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier, sizeof(ns5__ArrayOfStudyRootStudyIdentifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ArrayOfStudyRootStudyIdentifier *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(soap, "ns5:StudyRootStudyIdentifier", &(a->ns5__ArrayOfStudyRootStudyIdentifier::StudyRootStudyIdentifier), "ns5:StudyRootStudyIdentifier"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ArrayOfStudyRootStudyIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier, 0, sizeof(ns5__ArrayOfStudyRootStudyIdentifier), 0, soap_copy_ns5__ArrayOfStudyRootStudyIdentifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__ArrayOfStudyRootStudyIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier);
	if (this->soap_out(soap, tag?tag:"ns5:ArrayOfStudyRootStudyIdentifier", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ArrayOfStudyRootStudyIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ArrayOfStudyRootStudyIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ArrayOfStudyRootStudyIdentifier * SOAP_FMAC4 soap_get_ns5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, ns5__ArrayOfStudyRootStudyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ArrayOfStudyRootStudyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ArrayOfStudyRootStudyIdentifier * SOAP_FMAC2 soap_instantiate_ns5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ArrayOfStudyRootStudyIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ArrayOfStudyRootStudyIdentifier);
		if (size)
			*size = sizeof(ns5__ArrayOfStudyRootStudyIdentifier);
		((ns5__ArrayOfStudyRootStudyIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ArrayOfStudyRootStudyIdentifier, n);
		if (size)
			*size = n * sizeof(ns5__ArrayOfStudyRootStudyIdentifier);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__ArrayOfStudyRootStudyIdentifier*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__ArrayOfStudyRootStudyIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ArrayOfStudyRootStudyIdentifier %p -> %p\n", q, p));
	*(ns5__ArrayOfStudyRootStudyIdentifier*)p = *(ns5__ArrayOfStudyRootStudyIdentifier*)q;
}

void ns5__Identifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns5__Identifier::InstanceAvailability = NULL;
	this->ns5__Identifier::RetrieveAeTitle = NULL;
	this->ns5__Identifier::SpecificCharacterSet = NULL;
}

void ns5__Identifier::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns5__Identifier::InstanceAvailability);
	soap_serialize_PointerTostd__string(soap, &this->ns5__Identifier::RetrieveAeTitle);
	soap_serialize_PointerTostd__string(soap, &this->ns5__Identifier::SpecificCharacterSet);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns5__Identifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Identifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Identifier(struct soap *soap, const char *tag, int id, const ns5__Identifier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Identifier), "ns5:Identifier"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns5:InstanceAvailability", -1, &(a->ns5__Identifier::InstanceAvailability), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:RetrieveAeTitle", -1, &(a->ns5__Identifier::RetrieveAeTitle), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SpecificCharacterSet", -1, &(a->ns5__Identifier::SpecificCharacterSet), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__Identifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Identifier(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Identifier * SOAP_FMAC4 soap_in_ns5__Identifier(struct soap *soap, const char *tag, ns5__Identifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Identifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Identifier, sizeof(ns5__Identifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Identifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Identifier *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_InstanceAvailability1 = 1;
	size_t soap_flag_RetrieveAeTitle1 = 1;
	size_t soap_flag_SpecificCharacterSet1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_InstanceAvailability1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:InstanceAvailability", &(a->ns5__Identifier::InstanceAvailability), "xsd:string"))
				{	soap_flag_InstanceAvailability1--;
					continue;
				}
			if (soap_flag_RetrieveAeTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetrieveAeTitle", &(a->ns5__Identifier::RetrieveAeTitle), "xsd:string"))
				{	soap_flag_RetrieveAeTitle1--;
					continue;
				}
			if (soap_flag_SpecificCharacterSet1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SpecificCharacterSet", &(a->ns5__Identifier::SpecificCharacterSet), "xsd:string"))
				{	soap_flag_SpecificCharacterSet1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Identifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Identifier, 0, sizeof(ns5__Identifier), 0, soap_copy_ns5__Identifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__Identifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Identifier);
	if (this->soap_out(soap, tag?tag:"ns5:Identifier", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Identifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Identifier(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Identifier * SOAP_FMAC4 soap_get_ns5__Identifier(struct soap *soap, ns5__Identifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Identifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Identifier * SOAP_FMAC2 soap_instantiate_ns5__Identifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Identifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Identifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns5:StudyIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__StudyIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__StudyIdentifier);
			if (size)
				*size = sizeof(ns5__StudyIdentifier);
			((ns5__StudyIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__StudyIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__StudyIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__StudyIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__StudyIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:SeriesIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__SeriesIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__SeriesIdentifier);
			if (size)
				*size = sizeof(ns5__SeriesIdentifier);
			((ns5__SeriesIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__SeriesIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__SeriesIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__SeriesIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__SeriesIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:ImageIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__ImageIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__ImageIdentifier);
			if (size)
				*size = sizeof(ns5__ImageIdentifier);
			((ns5__ImageIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ImageIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__ImageIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__ImageIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__ImageIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:StudyRootStudyIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__StudyRootStudyIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__StudyRootStudyIdentifier);
			if (size)
				*size = sizeof(ns5__StudyRootStudyIdentifier);
			((ns5__StudyRootStudyIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__StudyRootStudyIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__StudyRootStudyIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__StudyRootStudyIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__StudyRootStudyIdentifier*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Identifier);
		if (size)
			*size = sizeof(ns5__Identifier);
		((ns5__Identifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Identifier, n);
		if (size)
			*size = n * sizeof(ns5__Identifier);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__Identifier*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__Identifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Identifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Identifier %p -> %p\n", q, p));
	*(ns5__Identifier*)p = *(ns5__Identifier*)q;
}

void ns5__StudyIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__Identifier::soap_default(soap);
	this->ns5__StudyIdentifier::AccessionNumber = NULL;
	this->ns5__StudyIdentifier::ModalitiesInStudy = NULL;
	this->ns5__StudyIdentifier::NumberOfStudyRelatedInstances = NULL;
	this->ns5__StudyIdentifier::NumberOfStudyRelatedSeries = NULL;
	this->ns5__StudyIdentifier::ReferringPhysiciansName = NULL;
	this->ns5__StudyIdentifier::SopClassesInStudy = NULL;
	this->ns5__StudyIdentifier::StudyDate = NULL;
	this->ns5__StudyIdentifier::StudyDescription = NULL;
	this->ns5__StudyIdentifier::StudyId = NULL;
	this->ns5__StudyIdentifier::StudyInstanceUid = NULL;
	this->ns5__StudyIdentifier::StudyTime = NULL;
}

void ns5__StudyIdentifier::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyIdentifier::AccessionNumber);
	soap_serialize_PointerTons4__ArrayOfstring(soap, &this->ns5__StudyIdentifier::ModalitiesInStudy);
	soap_serialize_PointerToint(soap, &this->ns5__StudyIdentifier::NumberOfStudyRelatedInstances);
	soap_serialize_PointerToint(soap, &this->ns5__StudyIdentifier::NumberOfStudyRelatedSeries);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyIdentifier::ReferringPhysiciansName);
	soap_serialize_PointerTons4__ArrayOfstring(soap, &this->ns5__StudyIdentifier::SopClassesInStudy);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyIdentifier::StudyDate);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyIdentifier::StudyDescription);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyIdentifier::StudyId);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyIdentifier::StudyInstanceUid);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyIdentifier::StudyTime);
	this->ns5__Identifier::soap_serialize(soap);
#endif
}

int ns5__StudyIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__StudyIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__StudyIdentifier(struct soap *soap, const char *tag, int id, const ns5__StudyIdentifier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__StudyIdentifier), "ns5:StudyIdentifier"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns5:InstanceAvailability", -1, &(a->ns5__Identifier::InstanceAvailability), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:RetrieveAeTitle", -1, &(a->ns5__Identifier::RetrieveAeTitle), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SpecificCharacterSet", -1, &(a->ns5__Identifier::SpecificCharacterSet), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:AccessionNumber", -1, &(a->ns5__StudyIdentifier::AccessionNumber), ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfstring(soap, "ns5:ModalitiesInStudy", -1, &(a->ns5__StudyIdentifier::ModalitiesInStudy), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:NumberOfStudyRelatedInstances", -1, &(a->ns5__StudyIdentifier::NumberOfStudyRelatedInstances), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:NumberOfStudyRelatedSeries", -1, &(a->ns5__StudyIdentifier::NumberOfStudyRelatedSeries), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:ReferringPhysiciansName", -1, &(a->ns5__StudyIdentifier::ReferringPhysiciansName), ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfstring(soap, "ns5:SopClassesInStudy", -1, &(a->ns5__StudyIdentifier::SopClassesInStudy), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyDate", -1, &(a->ns5__StudyIdentifier::StudyDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyDescription", -1, &(a->ns5__StudyIdentifier::StudyDescription), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyId", -1, &(a->ns5__StudyIdentifier::StudyId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyInstanceUid", -1, &(a->ns5__StudyIdentifier::StudyInstanceUid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyTime", -1, &(a->ns5__StudyIdentifier::StudyTime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__StudyIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__StudyIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 ns5__StudyIdentifier * SOAP_FMAC4 soap_in_ns5__StudyIdentifier(struct soap *soap, const char *tag, ns5__StudyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__StudyIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__StudyIdentifier, sizeof(ns5__StudyIdentifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__StudyIdentifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__StudyIdentifier *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_InstanceAvailability2 = 1;
	size_t soap_flag_RetrieveAeTitle2 = 1;
	size_t soap_flag_SpecificCharacterSet2 = 1;
	size_t soap_flag_AccessionNumber1 = 1;
	size_t soap_flag_ModalitiesInStudy1 = 1;
	size_t soap_flag_NumberOfStudyRelatedInstances1 = 1;
	size_t soap_flag_NumberOfStudyRelatedSeries1 = 1;
	size_t soap_flag_ReferringPhysiciansName1 = 1;
	size_t soap_flag_SopClassesInStudy1 = 1;
	size_t soap_flag_StudyDate1 = 1;
	size_t soap_flag_StudyDescription1 = 1;
	size_t soap_flag_StudyId1 = 1;
	size_t soap_flag_StudyInstanceUid1 = 1;
	size_t soap_flag_StudyTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_InstanceAvailability2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:InstanceAvailability", &(a->ns5__Identifier::InstanceAvailability), "xsd:string"))
				{	soap_flag_InstanceAvailability2--;
					continue;
				}
			if (soap_flag_RetrieveAeTitle2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetrieveAeTitle", &(a->ns5__Identifier::RetrieveAeTitle), "xsd:string"))
				{	soap_flag_RetrieveAeTitle2--;
					continue;
				}
			if (soap_flag_SpecificCharacterSet2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SpecificCharacterSet", &(a->ns5__Identifier::SpecificCharacterSet), "xsd:string"))
				{	soap_flag_SpecificCharacterSet2--;
					continue;
				}
			if (soap_flag_AccessionNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:AccessionNumber", &(a->ns5__StudyIdentifier::AccessionNumber), "xsd:string"))
				{	soap_flag_AccessionNumber1--;
					continue;
				}
			if (soap_flag_ModalitiesInStudy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfstring(soap, "ns5:ModalitiesInStudy", &(a->ns5__StudyIdentifier::ModalitiesInStudy), "ns4:ArrayOfstring"))
				{	soap_flag_ModalitiesInStudy1--;
					continue;
				}
			if (soap_flag_NumberOfStudyRelatedInstances1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns5:NumberOfStudyRelatedInstances", &(a->ns5__StudyIdentifier::NumberOfStudyRelatedInstances), "xsd:int"))
				{	soap_flag_NumberOfStudyRelatedInstances1--;
					continue;
				}
			if (soap_flag_NumberOfStudyRelatedSeries1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns5:NumberOfStudyRelatedSeries", &(a->ns5__StudyIdentifier::NumberOfStudyRelatedSeries), "xsd:int"))
				{	soap_flag_NumberOfStudyRelatedSeries1--;
					continue;
				}
			if (soap_flag_ReferringPhysiciansName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:ReferringPhysiciansName", &(a->ns5__StudyIdentifier::ReferringPhysiciansName), "xsd:string"))
				{	soap_flag_ReferringPhysiciansName1--;
					continue;
				}
			if (soap_flag_SopClassesInStudy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfstring(soap, "ns5:SopClassesInStudy", &(a->ns5__StudyIdentifier::SopClassesInStudy), "ns4:ArrayOfstring"))
				{	soap_flag_SopClassesInStudy1--;
					continue;
				}
			if (soap_flag_StudyDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyDate", &(a->ns5__StudyIdentifier::StudyDate), "xsd:string"))
				{	soap_flag_StudyDate1--;
					continue;
				}
			if (soap_flag_StudyDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyDescription", &(a->ns5__StudyIdentifier::StudyDescription), "xsd:string"))
				{	soap_flag_StudyDescription1--;
					continue;
				}
			if (soap_flag_StudyId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyId", &(a->ns5__StudyIdentifier::StudyId), "xsd:string"))
				{	soap_flag_StudyId1--;
					continue;
				}
			if (soap_flag_StudyInstanceUid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyInstanceUid", &(a->ns5__StudyIdentifier::StudyInstanceUid), "xsd:string"))
				{	soap_flag_StudyInstanceUid1--;
					continue;
				}
			if (soap_flag_StudyTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyTime", &(a->ns5__StudyIdentifier::StudyTime), "xsd:string"))
				{	soap_flag_StudyTime1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__StudyIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__StudyIdentifier, 0, sizeof(ns5__StudyIdentifier), 0, soap_copy_ns5__StudyIdentifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__StudyIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__StudyIdentifier);
	if (this->soap_out(soap, tag?tag:"ns5:StudyIdentifier", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__StudyIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__StudyIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 ns5__StudyIdentifier * SOAP_FMAC4 soap_get_ns5__StudyIdentifier(struct soap *soap, ns5__StudyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__StudyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__StudyIdentifier * SOAP_FMAC2 soap_instantiate_ns5__StudyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__StudyIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__StudyIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns5:StudyRootStudyIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__StudyRootStudyIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__StudyRootStudyIdentifier);
			if (size)
				*size = sizeof(ns5__StudyRootStudyIdentifier);
			((ns5__StudyRootStudyIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__StudyRootStudyIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__StudyRootStudyIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__StudyRootStudyIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__StudyRootStudyIdentifier*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__StudyIdentifier);
		if (size)
			*size = sizeof(ns5__StudyIdentifier);
		((ns5__StudyIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__StudyIdentifier, n);
		if (size)
			*size = n * sizeof(ns5__StudyIdentifier);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__StudyIdentifier*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__StudyIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__StudyIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__StudyIdentifier %p -> %p\n", q, p));
	*(ns5__StudyIdentifier*)p = *(ns5__StudyIdentifier*)q;
}

void ns5__StudyRootStudyIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns5__StudyIdentifier::soap_default(soap);
	this->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodeMeaning = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodeValue = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodingSchemeDesignator = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientBreedDescription = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientId = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodeMeaning = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodeValue = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodingSchemeDesignator = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientSpeciesDescription = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientsBirthDate = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientsBirthTime = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientsName = NULL;
	this->ns5__StudyRootStudyIdentifier::PatientsSex = NULL;
	this->ns5__StudyRootStudyIdentifier::ResponsibleOrganization = NULL;
	this->ns5__StudyRootStudyIdentifier::ResponsiblePerson = NULL;
	this->ns5__StudyRootStudyIdentifier::ResponsiblePersonRole = NULL;
}

void ns5__StudyRootStudyIdentifier::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodeMeaning);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodeValue);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodingSchemeDesignator);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientBreedDescription);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientId);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodeMeaning);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodeValue);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodingSchemeDesignator);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientSpeciesDescription);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientsBirthDate);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientsBirthTime);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientsName);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::PatientsSex);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::ResponsibleOrganization);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::ResponsiblePerson);
	soap_serialize_PointerTostd__string(soap, &this->ns5__StudyRootStudyIdentifier::ResponsiblePersonRole);
	this->ns5__StudyIdentifier::soap_serialize(soap);
#endif
}

int ns5__StudyRootStudyIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__StudyRootStudyIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__StudyRootStudyIdentifier(struct soap *soap, const char *tag, int id, const ns5__StudyRootStudyIdentifier *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__StudyRootStudyIdentifier), "ns5:StudyRootStudyIdentifier"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns5:InstanceAvailability", -1, &(a->ns5__Identifier::InstanceAvailability), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:RetrieveAeTitle", -1, &(a->ns5__Identifier::RetrieveAeTitle), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:SpecificCharacterSet", -1, &(a->ns5__Identifier::SpecificCharacterSet), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:AccessionNumber", -1, &(a->ns5__StudyIdentifier::AccessionNumber), ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfstring(soap, "ns5:ModalitiesInStudy", -1, &(a->ns5__StudyIdentifier::ModalitiesInStudy), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:NumberOfStudyRelatedInstances", -1, &(a->ns5__StudyIdentifier::NumberOfStudyRelatedInstances), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:NumberOfStudyRelatedSeries", -1, &(a->ns5__StudyIdentifier::NumberOfStudyRelatedSeries), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:ReferringPhysiciansName", -1, &(a->ns5__StudyIdentifier::ReferringPhysiciansName), ""))
		return soap->error;
	if (soap_out_PointerTons4__ArrayOfstring(soap, "ns5:SopClassesInStudy", -1, &(a->ns5__StudyIdentifier::SopClassesInStudy), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyDate", -1, &(a->ns5__StudyIdentifier::StudyDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyDescription", -1, &(a->ns5__StudyIdentifier::StudyDescription), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyId", -1, &(a->ns5__StudyIdentifier::StudyId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyInstanceUid", -1, &(a->ns5__StudyIdentifier::StudyInstanceUid), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:StudyTime", -1, &(a->ns5__StudyIdentifier::StudyTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientBreedCodeSequenceCodeMeaning", -1, &(a->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodeMeaning), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientBreedCodeSequenceCodeValue", -1, &(a->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodeValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientBreedCodeSequenceCodingSchemeDesignator", -1, &(a->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodingSchemeDesignator), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientBreedDescription", -1, &(a->ns5__StudyRootStudyIdentifier::PatientBreedDescription), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientId", -1, &(a->ns5__StudyRootStudyIdentifier::PatientId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientSpeciesCodeSequenceCodeMeaning", -1, &(a->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodeMeaning), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientSpeciesCodeSequenceCodeValue", -1, &(a->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodeValue), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientSpeciesCodeSequenceCodingSchemeDesignator", -1, &(a->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodingSchemeDesignator), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientSpeciesDescription", -1, &(a->ns5__StudyRootStudyIdentifier::PatientSpeciesDescription), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientsBirthDate", -1, &(a->ns5__StudyRootStudyIdentifier::PatientsBirthDate), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientsBirthTime", -1, &(a->ns5__StudyRootStudyIdentifier::PatientsBirthTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientsName", -1, &(a->ns5__StudyRootStudyIdentifier::PatientsName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:PatientsSex", -1, &(a->ns5__StudyRootStudyIdentifier::PatientsSex), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:ResponsibleOrganization", -1, &(a->ns5__StudyRootStudyIdentifier::ResponsibleOrganization), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:ResponsiblePerson", -1, &(a->ns5__StudyRootStudyIdentifier::ResponsiblePerson), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns5:ResponsiblePersonRole", -1, &(a->ns5__StudyRootStudyIdentifier::ResponsiblePersonRole), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns5__StudyRootStudyIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__StudyRootStudyIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 ns5__StudyRootStudyIdentifier * SOAP_FMAC4 soap_in_ns5__StudyRootStudyIdentifier(struct soap *soap, const char *tag, ns5__StudyRootStudyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__StudyRootStudyIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__StudyRootStudyIdentifier, sizeof(ns5__StudyRootStudyIdentifier), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__StudyRootStudyIdentifier)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__StudyRootStudyIdentifier *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item4 = 1;
	size_t soap_flag_InstanceAvailability3 = 1;
	size_t soap_flag_RetrieveAeTitle3 = 1;
	size_t soap_flag_SpecificCharacterSet3 = 1;
	size_t soap_flag_AccessionNumber2 = 1;
	size_t soap_flag_ModalitiesInStudy2 = 1;
	size_t soap_flag_NumberOfStudyRelatedInstances2 = 1;
	size_t soap_flag_NumberOfStudyRelatedSeries2 = 1;
	size_t soap_flag_ReferringPhysiciansName2 = 1;
	size_t soap_flag_SopClassesInStudy2 = 1;
	size_t soap_flag_StudyDate2 = 1;
	size_t soap_flag_StudyDescription2 = 1;
	size_t soap_flag_StudyId2 = 1;
	size_t soap_flag_StudyInstanceUid2 = 1;
	size_t soap_flag_StudyTime2 = 1;
	size_t soap_flag_PatientBreedCodeSequenceCodeMeaning1 = 1;
	size_t soap_flag_PatientBreedCodeSequenceCodeValue1 = 1;
	size_t soap_flag_PatientBreedCodeSequenceCodingSchemeDesignator1 = 1;
	size_t soap_flag_PatientBreedDescription1 = 1;
	size_t soap_flag_PatientId1 = 1;
	size_t soap_flag_PatientSpeciesCodeSequenceCodeMeaning1 = 1;
	size_t soap_flag_PatientSpeciesCodeSequenceCodeValue1 = 1;
	size_t soap_flag_PatientSpeciesCodeSequenceCodingSchemeDesignator1 = 1;
	size_t soap_flag_PatientSpeciesDescription1 = 1;
	size_t soap_flag_PatientsBirthDate1 = 1;
	size_t soap_flag_PatientsBirthTime1 = 1;
	size_t soap_flag_PatientsName1 = 1;
	size_t soap_flag_PatientsSex1 = 1;
	size_t soap_flag_ResponsibleOrganization1 = 1;
	size_t soap_flag_ResponsiblePerson1 = 1;
	size_t soap_flag_ResponsiblePersonRole1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_InstanceAvailability3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:InstanceAvailability", &(a->ns5__Identifier::InstanceAvailability), "xsd:string"))
				{	soap_flag_InstanceAvailability3--;
					continue;
				}
			if (soap_flag_RetrieveAeTitle3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:RetrieveAeTitle", &(a->ns5__Identifier::RetrieveAeTitle), "xsd:string"))
				{	soap_flag_RetrieveAeTitle3--;
					continue;
				}
			if (soap_flag_SpecificCharacterSet3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:SpecificCharacterSet", &(a->ns5__Identifier::SpecificCharacterSet), "xsd:string"))
				{	soap_flag_SpecificCharacterSet3--;
					continue;
				}
			if (soap_flag_AccessionNumber2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:AccessionNumber", &(a->ns5__StudyIdentifier::AccessionNumber), "xsd:string"))
				{	soap_flag_AccessionNumber2--;
					continue;
				}
			if (soap_flag_ModalitiesInStudy2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfstring(soap, "ns5:ModalitiesInStudy", &(a->ns5__StudyIdentifier::ModalitiesInStudy), "ns4:ArrayOfstring"))
				{	soap_flag_ModalitiesInStudy2--;
					continue;
				}
			if (soap_flag_NumberOfStudyRelatedInstances2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns5:NumberOfStudyRelatedInstances", &(a->ns5__StudyIdentifier::NumberOfStudyRelatedInstances), "xsd:int"))
				{	soap_flag_NumberOfStudyRelatedInstances2--;
					continue;
				}
			if (soap_flag_NumberOfStudyRelatedSeries2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns5:NumberOfStudyRelatedSeries", &(a->ns5__StudyIdentifier::NumberOfStudyRelatedSeries), "xsd:int"))
				{	soap_flag_NumberOfStudyRelatedSeries2--;
					continue;
				}
			if (soap_flag_ReferringPhysiciansName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:ReferringPhysiciansName", &(a->ns5__StudyIdentifier::ReferringPhysiciansName), "xsd:string"))
				{	soap_flag_ReferringPhysiciansName2--;
					continue;
				}
			if (soap_flag_SopClassesInStudy2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfstring(soap, "ns5:SopClassesInStudy", &(a->ns5__StudyIdentifier::SopClassesInStudy), "ns4:ArrayOfstring"))
				{	soap_flag_SopClassesInStudy2--;
					continue;
				}
			if (soap_flag_StudyDate2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyDate", &(a->ns5__StudyIdentifier::StudyDate), "xsd:string"))
				{	soap_flag_StudyDate2--;
					continue;
				}
			if (soap_flag_StudyDescription2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyDescription", &(a->ns5__StudyIdentifier::StudyDescription), "xsd:string"))
				{	soap_flag_StudyDescription2--;
					continue;
				}
			if (soap_flag_StudyId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyId", &(a->ns5__StudyIdentifier::StudyId), "xsd:string"))
				{	soap_flag_StudyId2--;
					continue;
				}
			if (soap_flag_StudyInstanceUid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyInstanceUid", &(a->ns5__StudyIdentifier::StudyInstanceUid), "xsd:string"))
				{	soap_flag_StudyInstanceUid2--;
					continue;
				}
			if (soap_flag_StudyTime2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:StudyTime", &(a->ns5__StudyIdentifier::StudyTime), "xsd:string"))
				{	soap_flag_StudyTime2--;
					continue;
				}
			if (soap_flag_PatientBreedCodeSequenceCodeMeaning1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientBreedCodeSequenceCodeMeaning", &(a->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodeMeaning), "xsd:string"))
				{	soap_flag_PatientBreedCodeSequenceCodeMeaning1--;
					continue;
				}
			if (soap_flag_PatientBreedCodeSequenceCodeValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientBreedCodeSequenceCodeValue", &(a->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodeValue), "xsd:string"))
				{	soap_flag_PatientBreedCodeSequenceCodeValue1--;
					continue;
				}
			if (soap_flag_PatientBreedCodeSequenceCodingSchemeDesignator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientBreedCodeSequenceCodingSchemeDesignator", &(a->ns5__StudyRootStudyIdentifier::PatientBreedCodeSequenceCodingSchemeDesignator), "xsd:string"))
				{	soap_flag_PatientBreedCodeSequenceCodingSchemeDesignator1--;
					continue;
				}
			if (soap_flag_PatientBreedDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientBreedDescription", &(a->ns5__StudyRootStudyIdentifier::PatientBreedDescription), "xsd:string"))
				{	soap_flag_PatientBreedDescription1--;
					continue;
				}
			if (soap_flag_PatientId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientId", &(a->ns5__StudyRootStudyIdentifier::PatientId), "xsd:string"))
				{	soap_flag_PatientId1--;
					continue;
				}
			if (soap_flag_PatientSpeciesCodeSequenceCodeMeaning1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientSpeciesCodeSequenceCodeMeaning", &(a->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodeMeaning), "xsd:string"))
				{	soap_flag_PatientSpeciesCodeSequenceCodeMeaning1--;
					continue;
				}
			if (soap_flag_PatientSpeciesCodeSequenceCodeValue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientSpeciesCodeSequenceCodeValue", &(a->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodeValue), "xsd:string"))
				{	soap_flag_PatientSpeciesCodeSequenceCodeValue1--;
					continue;
				}
			if (soap_flag_PatientSpeciesCodeSequenceCodingSchemeDesignator1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientSpeciesCodeSequenceCodingSchemeDesignator", &(a->ns5__StudyRootStudyIdentifier::PatientSpeciesCodeSequenceCodingSchemeDesignator), "xsd:string"))
				{	soap_flag_PatientSpeciesCodeSequenceCodingSchemeDesignator1--;
					continue;
				}
			if (soap_flag_PatientSpeciesDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientSpeciesDescription", &(a->ns5__StudyRootStudyIdentifier::PatientSpeciesDescription), "xsd:string"))
				{	soap_flag_PatientSpeciesDescription1--;
					continue;
				}
			if (soap_flag_PatientsBirthDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientsBirthDate", &(a->ns5__StudyRootStudyIdentifier::PatientsBirthDate), "xsd:string"))
				{	soap_flag_PatientsBirthDate1--;
					continue;
				}
			if (soap_flag_PatientsBirthTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientsBirthTime", &(a->ns5__StudyRootStudyIdentifier::PatientsBirthTime), "xsd:string"))
				{	soap_flag_PatientsBirthTime1--;
					continue;
				}
			if (soap_flag_PatientsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientsName", &(a->ns5__StudyRootStudyIdentifier::PatientsName), "xsd:string"))
				{	soap_flag_PatientsName1--;
					continue;
				}
			if (soap_flag_PatientsSex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:PatientsSex", &(a->ns5__StudyRootStudyIdentifier::PatientsSex), "xsd:string"))
				{	soap_flag_PatientsSex1--;
					continue;
				}
			if (soap_flag_ResponsibleOrganization1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:ResponsibleOrganization", &(a->ns5__StudyRootStudyIdentifier::ResponsibleOrganization), "xsd:string"))
				{	soap_flag_ResponsibleOrganization1--;
					continue;
				}
			if (soap_flag_ResponsiblePerson1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:ResponsiblePerson", &(a->ns5__StudyRootStudyIdentifier::ResponsiblePerson), "xsd:string"))
				{	soap_flag_ResponsiblePerson1--;
					continue;
				}
			if (soap_flag_ResponsiblePersonRole1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns5:ResponsiblePersonRole", &(a->ns5__StudyRootStudyIdentifier::ResponsiblePersonRole), "xsd:string"))
				{	soap_flag_ResponsiblePersonRole1--;
					continue;
				}
			if (soap_flag___item4 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item4--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__StudyRootStudyIdentifier *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__StudyRootStudyIdentifier, 0, sizeof(ns5__StudyRootStudyIdentifier), 0, soap_copy_ns5__StudyRootStudyIdentifier);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns5__StudyRootStudyIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__StudyRootStudyIdentifier);
	if (this->soap_out(soap, tag?tag:"ns5:StudyRootStudyIdentifier", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__StudyRootStudyIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__StudyRootStudyIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 ns5__StudyRootStudyIdentifier * SOAP_FMAC4 soap_get_ns5__StudyRootStudyIdentifier(struct soap *soap, ns5__StudyRootStudyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__StudyRootStudyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__StudyRootStudyIdentifier * SOAP_FMAC2 soap_instantiate_ns5__StudyRootStudyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__StudyRootStudyIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__StudyRootStudyIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__StudyRootStudyIdentifier);
		if (size)
			*size = sizeof(ns5__StudyRootStudyIdentifier);
		((ns5__StudyRootStudyIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__StudyRootStudyIdentifier, n);
		if (size)
			*size = n * sizeof(ns5__StudyRootStudyIdentifier);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns5__StudyRootStudyIdentifier*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns5__StudyRootStudyIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__StudyRootStudyIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__StudyRootStudyIdentifier %p -> %p\n", q, p));
	*(ns5__StudyRootStudyIdentifier*)p = *(ns5__StudyRootStudyIdentifier*)q;
}

void ns4__ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns4__ArrayOfstring::string);
}

void ns4__ArrayOfstring::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns4__ArrayOfstring::string);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns4__ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ArrayOfstring(struct soap *soap, const char *tag, int id, const ns4__ArrayOfstring *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ArrayOfstring), "ns4:ArrayOfstring"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "ns4:string", -1, &(a->ns4__ArrayOfstring::string), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ArrayOfstring * SOAP_FMAC4 soap_in_ns4__ArrayOfstring(struct soap *soap, const char *tag, ns4__ArrayOfstring *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ArrayOfstring, sizeof(ns4__ArrayOfstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ArrayOfstring)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ArrayOfstring *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "ns4:string", &(a->ns4__ArrayOfstring::string), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ArrayOfstring, 0, sizeof(ns4__ArrayOfstring), 0, soap_copy_ns4__ArrayOfstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns4__ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ArrayOfstring);
	if (this->soap_out(soap, tag?tag:"ns4:ArrayOfstring", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns4__ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ArrayOfstring * SOAP_FMAC4 soap_get_ns4__ArrayOfstring(struct soap *soap, ns4__ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns4__ArrayOfstring * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ArrayOfstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns4__ArrayOfstring);
		if (size)
			*size = sizeof(ns4__ArrayOfstring);
		((ns4__ArrayOfstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__ArrayOfstring, n);
		if (size)
			*size = n * sizeof(ns4__ArrayOfstring);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns4__ArrayOfstring*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns4__ArrayOfstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ArrayOfstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ArrayOfstring %p -> %p\n", q, p));
	*(ns4__ArrayOfstring*)p = *(ns4__ArrayOfstring*)q;
}

void _ns2__CloseViewerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns2__CloseViewerResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns2__CloseViewerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__CloseViewerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__CloseViewerResponse(struct soap *soap, const char *tag, int id, const _ns2__CloseViewerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__CloseViewerResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__CloseViewerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__CloseViewerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__CloseViewerResponse * SOAP_FMAC4 soap_in__ns2__CloseViewerResponse(struct soap *soap, const char *tag, _ns2__CloseViewerResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__CloseViewerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__CloseViewerResponse, sizeof(_ns2__CloseViewerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__CloseViewerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__CloseViewerResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__CloseViewerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__CloseViewerResponse, 0, sizeof(_ns2__CloseViewerResponse), 0, soap_copy__ns2__CloseViewerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__CloseViewerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__CloseViewerResponse);
	if (this->soap_out(soap, tag?tag:"ns2:CloseViewerResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__CloseViewerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__CloseViewerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__CloseViewerResponse * SOAP_FMAC4 soap_get__ns2__CloseViewerResponse(struct soap *soap, _ns2__CloseViewerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__CloseViewerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__CloseViewerResponse * SOAP_FMAC2 soap_instantiate__ns2__CloseViewerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__CloseViewerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__CloseViewerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__CloseViewerResponse);
		if (size)
			*size = sizeof(_ns2__CloseViewerResponse);
		((_ns2__CloseViewerResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__CloseViewerResponse, n);
		if (size)
			*size = n * sizeof(_ns2__CloseViewerResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__CloseViewerResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__CloseViewerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__CloseViewerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__CloseViewerResponse %p -> %p\n", q, p));
	*(_ns2__CloseViewerResponse*)p = *(_ns2__CloseViewerResponse*)q;
}

void _ns2__CloseViewer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__CloseViewer::request = NULL;
	/* transient soap skipped */
}

void _ns2__CloseViewer::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__CloseViewerRequest(soap, &this->_ns2__CloseViewer::request);
	/* transient soap skipped */
#endif
}

int _ns2__CloseViewer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__CloseViewer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__CloseViewer(struct soap *soap, const char *tag, int id, const _ns2__CloseViewer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__CloseViewer), type))
		return soap->error;
	if (soap_out_PointerTons2__CloseViewerRequest(soap, "ns2:request", -1, &(a->_ns2__CloseViewer::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__CloseViewer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__CloseViewer(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__CloseViewer * SOAP_FMAC4 soap_in__ns2__CloseViewer(struct soap *soap, const char *tag, _ns2__CloseViewer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__CloseViewer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__CloseViewer, sizeof(_ns2__CloseViewer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__CloseViewer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__CloseViewer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CloseViewerRequest(soap, "ns2:request", &(a->_ns2__CloseViewer::request), "ns2:CloseViewerRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__CloseViewer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__CloseViewer, 0, sizeof(_ns2__CloseViewer), 0, soap_copy__ns2__CloseViewer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__CloseViewer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__CloseViewer);
	if (this->soap_out(soap, tag?tag:"ns2:CloseViewer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__CloseViewer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__CloseViewer(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__CloseViewer * SOAP_FMAC4 soap_get__ns2__CloseViewer(struct soap *soap, _ns2__CloseViewer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__CloseViewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__CloseViewer * SOAP_FMAC2 soap_instantiate__ns2__CloseViewer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__CloseViewer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__CloseViewer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__CloseViewer);
		if (size)
			*size = sizeof(_ns2__CloseViewer);
		((_ns2__CloseViewer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__CloseViewer, n);
		if (size)
			*size = n * sizeof(_ns2__CloseViewer);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__CloseViewer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__CloseViewer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__CloseViewer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__CloseViewer %p -> %p\n", q, p));
	*(_ns2__CloseViewer*)p = *(_ns2__CloseViewer*)q;
}

void _ns2__ActivateViewerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns2__ActivateViewerResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns2__ActivateViewerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__ActivateViewerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ActivateViewerResponse(struct soap *soap, const char *tag, int id, const _ns2__ActivateViewerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ActivateViewerResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__ActivateViewerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__ActivateViewerResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__ActivateViewerResponse * SOAP_FMAC4 soap_in__ns2__ActivateViewerResponse(struct soap *soap, const char *tag, _ns2__ActivateViewerResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__ActivateViewerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ActivateViewerResponse, sizeof(_ns2__ActivateViewerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__ActivateViewerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__ActivateViewerResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__ActivateViewerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ActivateViewerResponse, 0, sizeof(_ns2__ActivateViewerResponse), 0, soap_copy__ns2__ActivateViewerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__ActivateViewerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__ActivateViewerResponse);
	if (this->soap_out(soap, tag?tag:"ns2:ActivateViewerResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__ActivateViewerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__ActivateViewerResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__ActivateViewerResponse * SOAP_FMAC4 soap_get__ns2__ActivateViewerResponse(struct soap *soap, _ns2__ActivateViewerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ActivateViewerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__ActivateViewerResponse * SOAP_FMAC2 soap_instantiate__ns2__ActivateViewerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__ActivateViewerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__ActivateViewerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__ActivateViewerResponse);
		if (size)
			*size = sizeof(_ns2__ActivateViewerResponse);
		((_ns2__ActivateViewerResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__ActivateViewerResponse, n);
		if (size)
			*size = n * sizeof(_ns2__ActivateViewerResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__ActivateViewerResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__ActivateViewerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__ActivateViewerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__ActivateViewerResponse %p -> %p\n", q, p));
	*(_ns2__ActivateViewerResponse*)p = *(_ns2__ActivateViewerResponse*)q;
}

void _ns2__ActivateViewer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__ActivateViewer::request = NULL;
	/* transient soap skipped */
}

void _ns2__ActivateViewer::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ActivateViewerRequest(soap, &this->_ns2__ActivateViewer::request);
	/* transient soap skipped */
#endif
}

int _ns2__ActivateViewer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__ActivateViewer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__ActivateViewer(struct soap *soap, const char *tag, int id, const _ns2__ActivateViewer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__ActivateViewer), type))
		return soap->error;
	if (soap_out_PointerTons2__ActivateViewerRequest(soap, "ns2:request", -1, &(a->_ns2__ActivateViewer::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__ActivateViewer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__ActivateViewer(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__ActivateViewer * SOAP_FMAC4 soap_in__ns2__ActivateViewer(struct soap *soap, const char *tag, _ns2__ActivateViewer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__ActivateViewer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__ActivateViewer, sizeof(_ns2__ActivateViewer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__ActivateViewer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__ActivateViewer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ActivateViewerRequest(soap, "ns2:request", &(a->_ns2__ActivateViewer::request), "ns2:ActivateViewerRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__ActivateViewer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__ActivateViewer, 0, sizeof(_ns2__ActivateViewer), 0, soap_copy__ns2__ActivateViewer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__ActivateViewer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__ActivateViewer);
	if (this->soap_out(soap, tag?tag:"ns2:ActivateViewer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__ActivateViewer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__ActivateViewer(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__ActivateViewer * SOAP_FMAC4 soap_get__ns2__ActivateViewer(struct soap *soap, _ns2__ActivateViewer *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__ActivateViewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__ActivateViewer * SOAP_FMAC2 soap_instantiate__ns2__ActivateViewer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__ActivateViewer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__ActivateViewer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__ActivateViewer);
		if (size)
			*size = sizeof(_ns2__ActivateViewer);
		((_ns2__ActivateViewer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__ActivateViewer, n);
		if (size)
			*size = n * sizeof(_ns2__ActivateViewer);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__ActivateViewer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__ActivateViewer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__ActivateViewer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__ActivateViewer %p -> %p\n", q, p));
	*(_ns2__ActivateViewer*)p = *(_ns2__ActivateViewer*)q;
}

void _ns2__OpenStudiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__OpenStudiesResponse::OpenStudiesResult = NULL;
	/* transient soap skipped */
}

void _ns2__OpenStudiesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__OpenStudiesResult(soap, &this->_ns2__OpenStudiesResponse::OpenStudiesResult);
	/* transient soap skipped */
#endif
}

int _ns2__OpenStudiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__OpenStudiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__OpenStudiesResponse(struct soap *soap, const char *tag, int id, const _ns2__OpenStudiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__OpenStudiesResponse), type))
		return soap->error;
	if (a->OpenStudiesResult)
		soap_element_result(soap, "ns2:OpenStudiesResult");
	if (soap_out_PointerTons2__OpenStudiesResult(soap, "ns2:OpenStudiesResult", -1, &(a->_ns2__OpenStudiesResponse::OpenStudiesResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__OpenStudiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__OpenStudiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__OpenStudiesResponse * SOAP_FMAC4 soap_in__ns2__OpenStudiesResponse(struct soap *soap, const char *tag, _ns2__OpenStudiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__OpenStudiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__OpenStudiesResponse, sizeof(_ns2__OpenStudiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__OpenStudiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__OpenStudiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OpenStudiesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OpenStudiesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OpenStudiesResult(soap, "ns2:OpenStudiesResult", &(a->_ns2__OpenStudiesResponse::OpenStudiesResult), "ns2:OpenStudiesResult"))
				{	soap_flag_OpenStudiesResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns2:OpenStudiesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__OpenStudiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__OpenStudiesResponse, 0, sizeof(_ns2__OpenStudiesResponse), 0, soap_copy__ns2__OpenStudiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__OpenStudiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__OpenStudiesResponse);
	if (this->soap_out(soap, tag?tag:"ns2:OpenStudiesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__OpenStudiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__OpenStudiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__OpenStudiesResponse * SOAP_FMAC4 soap_get__ns2__OpenStudiesResponse(struct soap *soap, _ns2__OpenStudiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__OpenStudiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__OpenStudiesResponse * SOAP_FMAC2 soap_instantiate__ns2__OpenStudiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__OpenStudiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__OpenStudiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__OpenStudiesResponse);
		if (size)
			*size = sizeof(_ns2__OpenStudiesResponse);
		((_ns2__OpenStudiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__OpenStudiesResponse, n);
		if (size)
			*size = n * sizeof(_ns2__OpenStudiesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__OpenStudiesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__OpenStudiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__OpenStudiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__OpenStudiesResponse %p -> %p\n", q, p));
	*(_ns2__OpenStudiesResponse*)p = *(_ns2__OpenStudiesResponse*)q;
}

void _ns2__OpenStudies::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__OpenStudies::request = NULL;
	/* transient soap skipped */
}

void _ns2__OpenStudies::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__OpenStudiesRequest(soap, &this->_ns2__OpenStudies::request);
	/* transient soap skipped */
#endif
}

int _ns2__OpenStudies::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__OpenStudies(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__OpenStudies(struct soap *soap, const char *tag, int id, const _ns2__OpenStudies *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__OpenStudies), type))
		return soap->error;
	if (soap_out_PointerTons2__OpenStudiesRequest(soap, "ns2:request", -1, &(a->_ns2__OpenStudies::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__OpenStudies::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__OpenStudies(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__OpenStudies * SOAP_FMAC4 soap_in__ns2__OpenStudies(struct soap *soap, const char *tag, _ns2__OpenStudies *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__OpenStudies *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__OpenStudies, sizeof(_ns2__OpenStudies), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__OpenStudies)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__OpenStudies *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OpenStudiesRequest(soap, "ns2:request", &(a->_ns2__OpenStudies::request), "ns2:OpenStudiesRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__OpenStudies *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__OpenStudies, 0, sizeof(_ns2__OpenStudies), 0, soap_copy__ns2__OpenStudies);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__OpenStudies::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__OpenStudies);
	if (this->soap_out(soap, tag?tag:"ns2:OpenStudies", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__OpenStudies::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__OpenStudies(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__OpenStudies * SOAP_FMAC4 soap_get__ns2__OpenStudies(struct soap *soap, _ns2__OpenStudies *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__OpenStudies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__OpenStudies * SOAP_FMAC2 soap_instantiate__ns2__OpenStudies(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__OpenStudies(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__OpenStudies, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__OpenStudies);
		if (size)
			*size = sizeof(_ns2__OpenStudies);
		((_ns2__OpenStudies*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__OpenStudies, n);
		if (size)
			*size = n * sizeof(_ns2__OpenStudies);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__OpenStudies*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__OpenStudies*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__OpenStudies(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__OpenStudies %p -> %p\n", q, p));
	*(_ns2__OpenStudies*)p = *(_ns2__OpenStudies*)q;
}

void _ns2__GetViewerInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetViewerInfoResponse::GetViewerInfoResult = NULL;
	/* transient soap skipped */
}

void _ns2__GetViewerInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__GetViewerInfoResult(soap, &this->_ns2__GetViewerInfoResponse::GetViewerInfoResult);
	/* transient soap skipped */
#endif
}

int _ns2__GetViewerInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetViewerInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetViewerInfoResponse(struct soap *soap, const char *tag, int id, const _ns2__GetViewerInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetViewerInfoResponse), type))
		return soap->error;
	if (a->GetViewerInfoResult)
		soap_element_result(soap, "ns2:GetViewerInfoResult");
	if (soap_out_PointerTons2__GetViewerInfoResult(soap, "ns2:GetViewerInfoResult", -1, &(a->_ns2__GetViewerInfoResponse::GetViewerInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetViewerInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__GetViewerInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetViewerInfoResponse * SOAP_FMAC4 soap_in__ns2__GetViewerInfoResponse(struct soap *soap, const char *tag, _ns2__GetViewerInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetViewerInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetViewerInfoResponse, sizeof(_ns2__GetViewerInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__GetViewerInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__GetViewerInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetViewerInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetViewerInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GetViewerInfoResult(soap, "ns2:GetViewerInfoResult", &(a->_ns2__GetViewerInfoResponse::GetViewerInfoResult), "ns2:GetViewerInfoResult"))
				{	soap_flag_GetViewerInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns2:GetViewerInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetViewerInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetViewerInfoResponse, 0, sizeof(_ns2__GetViewerInfoResponse), 0, soap_copy__ns2__GetViewerInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__GetViewerInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__GetViewerInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns2:GetViewerInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetViewerInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetViewerInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetViewerInfoResponse * SOAP_FMAC4 soap_get__ns2__GetViewerInfoResponse(struct soap *soap, _ns2__GetViewerInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetViewerInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__GetViewerInfoResponse * SOAP_FMAC2 soap_instantiate__ns2__GetViewerInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetViewerInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__GetViewerInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__GetViewerInfoResponse);
		if (size)
			*size = sizeof(_ns2__GetViewerInfoResponse);
		((_ns2__GetViewerInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__GetViewerInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns2__GetViewerInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__GetViewerInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__GetViewerInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__GetViewerInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__GetViewerInfoResponse %p -> %p\n", q, p));
	*(_ns2__GetViewerInfoResponse*)p = *(_ns2__GetViewerInfoResponse*)q;
}

void _ns2__GetViewerInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetViewerInfo::request = NULL;
	/* transient soap skipped */
}

void _ns2__GetViewerInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__GetViewerInfoRequest(soap, &this->_ns2__GetViewerInfo::request);
	/* transient soap skipped */
#endif
}

int _ns2__GetViewerInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetViewerInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetViewerInfo(struct soap *soap, const char *tag, int id, const _ns2__GetViewerInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetViewerInfo), type))
		return soap->error;
	if (soap_out_PointerTons2__GetViewerInfoRequest(soap, "ns2:request", -1, &(a->_ns2__GetViewerInfo::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetViewerInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__GetViewerInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetViewerInfo * SOAP_FMAC4 soap_in__ns2__GetViewerInfo(struct soap *soap, const char *tag, _ns2__GetViewerInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetViewerInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetViewerInfo, sizeof(_ns2__GetViewerInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__GetViewerInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__GetViewerInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GetViewerInfoRequest(soap, "ns2:request", &(a->_ns2__GetViewerInfo::request), "ns2:GetViewerInfoRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetViewerInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetViewerInfo, 0, sizeof(_ns2__GetViewerInfo), 0, soap_copy__ns2__GetViewerInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__GetViewerInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__GetViewerInfo);
	if (this->soap_out(soap, tag?tag:"ns2:GetViewerInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetViewerInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetViewerInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetViewerInfo * SOAP_FMAC4 soap_get__ns2__GetViewerInfo(struct soap *soap, _ns2__GetViewerInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetViewerInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__GetViewerInfo * SOAP_FMAC2 soap_instantiate__ns2__GetViewerInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetViewerInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__GetViewerInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__GetViewerInfo);
		if (size)
			*size = sizeof(_ns2__GetViewerInfo);
		((_ns2__GetViewerInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__GetViewerInfo, n);
		if (size)
			*size = n * sizeof(_ns2__GetViewerInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__GetViewerInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__GetViewerInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__GetViewerInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__GetViewerInfo %p -> %p\n", q, p));
	*(_ns2__GetViewerInfo*)p = *(_ns2__GetViewerInfo*)q;
}

void _ns2__GetActiveViewersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetActiveViewersResponse::GetActiveViewersResult = NULL;
	/* transient soap skipped */
}

void _ns2__GetActiveViewersResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__GetActiveViewersResult(soap, &this->_ns2__GetActiveViewersResponse::GetActiveViewersResult);
	/* transient soap skipped */
#endif
}

int _ns2__GetActiveViewersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetActiveViewersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetActiveViewersResponse(struct soap *soap, const char *tag, int id, const _ns2__GetActiveViewersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetActiveViewersResponse), type))
		return soap->error;
	if (a->GetActiveViewersResult)
		soap_element_result(soap, "ns2:GetActiveViewersResult");
	if (soap_out_PointerTons2__GetActiveViewersResult(soap, "ns2:GetActiveViewersResult", -1, &(a->_ns2__GetActiveViewersResponse::GetActiveViewersResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetActiveViewersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__GetActiveViewersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetActiveViewersResponse * SOAP_FMAC4 soap_in__ns2__GetActiveViewersResponse(struct soap *soap, const char *tag, _ns2__GetActiveViewersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetActiveViewersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetActiveViewersResponse, sizeof(_ns2__GetActiveViewersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__GetActiveViewersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__GetActiveViewersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetActiveViewersResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetActiveViewersResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GetActiveViewersResult(soap, "ns2:GetActiveViewersResult", &(a->_ns2__GetActiveViewersResponse::GetActiveViewersResult), "ns2:GetActiveViewersResult"))
				{	soap_flag_GetActiveViewersResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns2:GetActiveViewersResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetActiveViewersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetActiveViewersResponse, 0, sizeof(_ns2__GetActiveViewersResponse), 0, soap_copy__ns2__GetActiveViewersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__GetActiveViewersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__GetActiveViewersResponse);
	if (this->soap_out(soap, tag?tag:"ns2:GetActiveViewersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetActiveViewersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetActiveViewersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetActiveViewersResponse * SOAP_FMAC4 soap_get__ns2__GetActiveViewersResponse(struct soap *soap, _ns2__GetActiveViewersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetActiveViewersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__GetActiveViewersResponse * SOAP_FMAC2 soap_instantiate__ns2__GetActiveViewersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetActiveViewersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__GetActiveViewersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__GetActiveViewersResponse);
		if (size)
			*size = sizeof(_ns2__GetActiveViewersResponse);
		((_ns2__GetActiveViewersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__GetActiveViewersResponse, n);
		if (size)
			*size = n * sizeof(_ns2__GetActiveViewersResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__GetActiveViewersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__GetActiveViewersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__GetActiveViewersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__GetActiveViewersResponse %p -> %p\n", q, p));
	*(_ns2__GetActiveViewersResponse*)p = *(_ns2__GetActiveViewersResponse*)q;
}

void _ns2__GetActiveViewers::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns2__GetActiveViewers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns2__GetActiveViewers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetActiveViewers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetActiveViewers(struct soap *soap, const char *tag, int id, const _ns2__GetActiveViewers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetActiveViewers), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetActiveViewers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__GetActiveViewers(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetActiveViewers * SOAP_FMAC4 soap_in__ns2__GetActiveViewers(struct soap *soap, const char *tag, _ns2__GetActiveViewers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetActiveViewers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetActiveViewers, sizeof(_ns2__GetActiveViewers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__GetActiveViewers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__GetActiveViewers *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetActiveViewers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetActiveViewers, 0, sizeof(_ns2__GetActiveViewers), 0, soap_copy__ns2__GetActiveViewers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__GetActiveViewers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__GetActiveViewers);
	if (this->soap_out(soap, tag?tag:"ns2:GetActiveViewers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetActiveViewers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetActiveViewers(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetActiveViewers * SOAP_FMAC4 soap_get__ns2__GetActiveViewers(struct soap *soap, _ns2__GetActiveViewers *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetActiveViewers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__GetActiveViewers * SOAP_FMAC2 soap_instantiate__ns2__GetActiveViewers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetActiveViewers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__GetActiveViewers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__GetActiveViewers);
		if (size)
			*size = sizeof(_ns2__GetActiveViewers);
		((_ns2__GetActiveViewers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__GetActiveViewers, n);
		if (size)
			*size = n * sizeof(_ns2__GetActiveViewers);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__GetActiveViewers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__GetActiveViewers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__GetActiveViewers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__GetActiveViewers %p -> %p\n", q, p));
	*(_ns2__GetActiveViewers*)p = *(_ns2__GetActiveViewers*)q;
}

void _ns2__GetViewersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetViewersResponse::GetViewersResult = NULL;
	/* transient soap skipped */
}

void _ns2__GetViewersResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__GetViewersResult(soap, &this->_ns2__GetViewersResponse::GetViewersResult);
	/* transient soap skipped */
#endif
}

int _ns2__GetViewersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetViewersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetViewersResponse(struct soap *soap, const char *tag, int id, const _ns2__GetViewersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetViewersResponse), type))
		return soap->error;
	if (a->GetViewersResult)
		soap_element_result(soap, "ns2:GetViewersResult");
	if (soap_out_PointerTons2__GetViewersResult(soap, "ns2:GetViewersResult", -1, &(a->_ns2__GetViewersResponse::GetViewersResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetViewersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__GetViewersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetViewersResponse * SOAP_FMAC4 soap_in__ns2__GetViewersResponse(struct soap *soap, const char *tag, _ns2__GetViewersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetViewersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetViewersResponse, sizeof(_ns2__GetViewersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__GetViewersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__GetViewersResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetViewersResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetViewersResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GetViewersResult(soap, "ns2:GetViewersResult", &(a->_ns2__GetViewersResponse::GetViewersResult), "ns2:GetViewersResult"))
				{	soap_flag_GetViewersResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns2:GetViewersResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetViewersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetViewersResponse, 0, sizeof(_ns2__GetViewersResponse), 0, soap_copy__ns2__GetViewersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__GetViewersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__GetViewersResponse);
	if (this->soap_out(soap, tag?tag:"ns2:GetViewersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetViewersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetViewersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetViewersResponse * SOAP_FMAC4 soap_get__ns2__GetViewersResponse(struct soap *soap, _ns2__GetViewersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetViewersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__GetViewersResponse * SOAP_FMAC2 soap_instantiate__ns2__GetViewersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetViewersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__GetViewersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__GetViewersResponse);
		if (size)
			*size = sizeof(_ns2__GetViewersResponse);
		((_ns2__GetViewersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__GetViewersResponse, n);
		if (size)
			*size = n * sizeof(_ns2__GetViewersResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__GetViewersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__GetViewersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__GetViewersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__GetViewersResponse %p -> %p\n", q, p));
	*(_ns2__GetViewersResponse*)p = *(_ns2__GetViewersResponse*)q;
}

void _ns2__GetViewers::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__GetViewers::request = NULL;
	/* transient soap skipped */
}

void _ns2__GetViewers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__GetViewersRequest(soap, &this->_ns2__GetViewers::request);
	/* transient soap skipped */
#endif
}

int _ns2__GetViewers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__GetViewers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__GetViewers(struct soap *soap, const char *tag, int id, const _ns2__GetViewers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__GetViewers), type))
		return soap->error;
	if (soap_out_PointerTons2__GetViewersRequest(soap, "ns2:request", -1, &(a->_ns2__GetViewers::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__GetViewers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__GetViewers(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__GetViewers * SOAP_FMAC4 soap_in__ns2__GetViewers(struct soap *soap, const char *tag, _ns2__GetViewers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__GetViewers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__GetViewers, sizeof(_ns2__GetViewers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__GetViewers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__GetViewers *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__GetViewersRequest(soap, "ns2:request", &(a->_ns2__GetViewers::request), "ns2:GetViewersRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__GetViewers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__GetViewers, 0, sizeof(_ns2__GetViewers), 0, soap_copy__ns2__GetViewers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__GetViewers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__GetViewers);
	if (this->soap_out(soap, tag?tag:"ns2:GetViewers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__GetViewers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__GetViewers(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__GetViewers * SOAP_FMAC4 soap_get__ns2__GetViewers(struct soap *soap, _ns2__GetViewers *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__GetViewers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__GetViewers * SOAP_FMAC2 soap_instantiate__ns2__GetViewers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__GetViewers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__GetViewers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__GetViewers);
		if (size)
			*size = sizeof(_ns2__GetViewers);
		((_ns2__GetViewers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__GetViewers, n);
		if (size)
			*size = n * sizeof(_ns2__GetViewers);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__GetViewers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__GetViewers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__GetViewers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__GetViewers %p -> %p\n", q, p));
	*(_ns2__GetViewers*)p = *(_ns2__GetViewers*)q;
}

void _ns2__OpenFilesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__OpenFilesResponse::OpenFilesResult = NULL;
	/* transient soap skipped */
}

void _ns2__OpenFilesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__OpenFilesResult(soap, &this->_ns2__OpenFilesResponse::OpenFilesResult);
	/* transient soap skipped */
#endif
}

int _ns2__OpenFilesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__OpenFilesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__OpenFilesResponse(struct soap *soap, const char *tag, int id, const _ns2__OpenFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__OpenFilesResponse), type))
		return soap->error;
	if (a->OpenFilesResult)
		soap_element_result(soap, "ns2:OpenFilesResult");
	if (soap_out_PointerTons2__OpenFilesResult(soap, "ns2:OpenFilesResult", -1, &(a->_ns2__OpenFilesResponse::OpenFilesResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__OpenFilesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__OpenFilesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__OpenFilesResponse * SOAP_FMAC4 soap_in__ns2__OpenFilesResponse(struct soap *soap, const char *tag, _ns2__OpenFilesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__OpenFilesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__OpenFilesResponse, sizeof(_ns2__OpenFilesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__OpenFilesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__OpenFilesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_OpenFilesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OpenFilesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OpenFilesResult(soap, "ns2:OpenFilesResult", &(a->_ns2__OpenFilesResponse::OpenFilesResult), "ns2:OpenFilesResult"))
				{	soap_flag_OpenFilesResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns2:OpenFilesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__OpenFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__OpenFilesResponse, 0, sizeof(_ns2__OpenFilesResponse), 0, soap_copy__ns2__OpenFilesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__OpenFilesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__OpenFilesResponse);
	if (this->soap_out(soap, tag?tag:"ns2:OpenFilesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__OpenFilesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__OpenFilesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__OpenFilesResponse * SOAP_FMAC4 soap_get__ns2__OpenFilesResponse(struct soap *soap, _ns2__OpenFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__OpenFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__OpenFilesResponse * SOAP_FMAC2 soap_instantiate__ns2__OpenFilesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__OpenFilesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__OpenFilesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__OpenFilesResponse);
		if (size)
			*size = sizeof(_ns2__OpenFilesResponse);
		((_ns2__OpenFilesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__OpenFilesResponse, n);
		if (size)
			*size = n * sizeof(_ns2__OpenFilesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__OpenFilesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__OpenFilesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__OpenFilesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__OpenFilesResponse %p -> %p\n", q, p));
	*(_ns2__OpenFilesResponse*)p = *(_ns2__OpenFilesResponse*)q;
}

void _ns2__OpenFiles::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns2__OpenFiles::request = NULL;
	/* transient soap skipped */
}

void _ns2__OpenFiles::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__OpenFilesRequest(soap, &this->_ns2__OpenFiles::request);
	/* transient soap skipped */
#endif
}

int _ns2__OpenFiles::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns2__OpenFiles(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__OpenFiles(struct soap *soap, const char *tag, int id, const _ns2__OpenFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__OpenFiles), type))
		return soap->error;
	if (soap_out_PointerTons2__OpenFilesRequest(soap, "ns2:request", -1, &(a->_ns2__OpenFiles::request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns2__OpenFiles::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns2__OpenFiles(soap, tag, this, type);
}

SOAP_FMAC3 _ns2__OpenFiles * SOAP_FMAC4 soap_in__ns2__OpenFiles(struct soap *soap, const char *tag, _ns2__OpenFiles *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns2__OpenFiles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__OpenFiles, sizeof(_ns2__OpenFiles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns2__OpenFiles)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns2__OpenFiles *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OpenFilesRequest(soap, "ns2:request", &(a->_ns2__OpenFiles::request), "ns2:OpenFilesRequest"))
				{	soap_flag_request1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns2__OpenFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__OpenFiles, 0, sizeof(_ns2__OpenFiles), 0, soap_copy__ns2__OpenFiles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns2__OpenFiles::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns2__OpenFiles);
	if (this->soap_out(soap, tag?tag:"ns2:OpenFiles", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns2__OpenFiles::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns2__OpenFiles(soap, this, tag, type);
}

SOAP_FMAC3 _ns2__OpenFiles * SOAP_FMAC4 soap_get__ns2__OpenFiles(struct soap *soap, _ns2__OpenFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__OpenFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns2__OpenFiles * SOAP_FMAC2 soap_instantiate__ns2__OpenFiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns2__OpenFiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns2__OpenFiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns2__OpenFiles);
		if (size)
			*size = sizeof(_ns2__OpenFiles);
		((_ns2__OpenFiles*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns2__OpenFiles, n);
		if (size)
			*size = n * sizeof(_ns2__OpenFiles);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns2__OpenFiles*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns2__OpenFiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns2__OpenFiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns2__OpenFiles %p -> %p\n", q, p));
	*(_ns2__OpenFiles*)p = *(_ns2__OpenFiles*)q;
}

void ns2__CloseViewerRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__CloseViewerRequest::Viewer = NULL;
}

void ns2__CloseViewerRequest::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Viewer(soap, &this->ns2__CloseViewerRequest::Viewer);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__CloseViewerRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CloseViewerRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CloseViewerRequest(struct soap *soap, const char *tag, int id, const ns2__CloseViewerRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CloseViewerRequest), "ns2:CloseViewerRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__Viewer(soap, "ns2:Viewer", -1, &(a->ns2__CloseViewerRequest::Viewer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__CloseViewerRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CloseViewerRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CloseViewerRequest * SOAP_FMAC4 soap_in_ns2__CloseViewerRequest(struct soap *soap, const char *tag, ns2__CloseViewerRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CloseViewerRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CloseViewerRequest, sizeof(ns2__CloseViewerRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CloseViewerRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CloseViewerRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Viewer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Viewer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Viewer(soap, "ns2:Viewer", &(a->ns2__CloseViewerRequest::Viewer), "ns2:Viewer"))
				{	soap_flag_Viewer1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CloseViewerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CloseViewerRequest, 0, sizeof(ns2__CloseViewerRequest), 0, soap_copy_ns2__CloseViewerRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__CloseViewerRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CloseViewerRequest);
	if (this->soap_out(soap, tag?tag:"ns2:CloseViewerRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CloseViewerRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CloseViewerRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CloseViewerRequest * SOAP_FMAC4 soap_get_ns2__CloseViewerRequest(struct soap *soap, ns2__CloseViewerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CloseViewerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CloseViewerRequest * SOAP_FMAC2 soap_instantiate_ns2__CloseViewerRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CloseViewerRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CloseViewerRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CloseViewerRequest);
		if (size)
			*size = sizeof(ns2__CloseViewerRequest);
		((ns2__CloseViewerRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__CloseViewerRequest, n);
		if (size)
			*size = n * sizeof(ns2__CloseViewerRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__CloseViewerRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__CloseViewerRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CloseViewerRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CloseViewerRequest %p -> %p\n", q, p));
	*(ns2__CloseViewerRequest*)p = *(ns2__CloseViewerRequest*)q;
}

void ns2__ActivateViewerRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__ActivateViewerRequest::Viewer = NULL;
}

void ns2__ActivateViewerRequest::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Viewer(soap, &this->ns2__ActivateViewerRequest::Viewer);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__ActivateViewerRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ActivateViewerRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ActivateViewerRequest(struct soap *soap, const char *tag, int id, const ns2__ActivateViewerRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ActivateViewerRequest), "ns2:ActivateViewerRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__Viewer(soap, "ns2:Viewer", -1, &(a->ns2__ActivateViewerRequest::Viewer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ActivateViewerRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ActivateViewerRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ActivateViewerRequest * SOAP_FMAC4 soap_in_ns2__ActivateViewerRequest(struct soap *soap, const char *tag, ns2__ActivateViewerRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ActivateViewerRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ActivateViewerRequest, sizeof(ns2__ActivateViewerRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ActivateViewerRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ActivateViewerRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Viewer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Viewer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Viewer(soap, "ns2:Viewer", &(a->ns2__ActivateViewerRequest::Viewer), "ns2:Viewer"))
				{	soap_flag_Viewer1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ActivateViewerRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ActivateViewerRequest, 0, sizeof(ns2__ActivateViewerRequest), 0, soap_copy_ns2__ActivateViewerRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ActivateViewerRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ActivateViewerRequest);
	if (this->soap_out(soap, tag?tag:"ns2:ActivateViewerRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ActivateViewerRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ActivateViewerRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ActivateViewerRequest * SOAP_FMAC4 soap_get_ns2__ActivateViewerRequest(struct soap *soap, ns2__ActivateViewerRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ActivateViewerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ActivateViewerRequest * SOAP_FMAC2 soap_instantiate_ns2__ActivateViewerRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ActivateViewerRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ActivateViewerRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ActivateViewerRequest);
		if (size)
			*size = sizeof(ns2__ActivateViewerRequest);
		((ns2__ActivateViewerRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ActivateViewerRequest, n);
		if (size)
			*size = n * sizeof(ns2__ActivateViewerRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ActivateViewerRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ActivateViewerRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ActivateViewerRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ActivateViewerRequest %p -> %p\n", q, p));
	*(ns2__ActivateViewerRequest*)p = *(ns2__ActivateViewerRequest*)q;
}

void ns2__OpenStudiesFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__OpenStudiesFault::FailureDescription = NULL;
}

void ns2__OpenStudiesFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__OpenStudiesFault::FailureDescription);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__OpenStudiesFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OpenStudiesFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OpenStudiesFault(struct soap *soap, const char *tag, int id, const ns2__OpenStudiesFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OpenStudiesFault), "ns2:OpenStudiesFault"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns2:FailureDescription", -1, &(a->ns2__OpenStudiesFault::FailureDescription), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OpenStudiesFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OpenStudiesFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OpenStudiesFault * SOAP_FMAC4 soap_in_ns2__OpenStudiesFault(struct soap *soap, const char *tag, ns2__OpenStudiesFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OpenStudiesFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OpenStudiesFault, sizeof(ns2__OpenStudiesFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OpenStudiesFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OpenStudiesFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FailureDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_FailureDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:FailureDescription", &(a->ns2__OpenStudiesFault::FailureDescription), "xsd:string"))
				{	soap_flag_FailureDescription1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OpenStudiesFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OpenStudiesFault, 0, sizeof(ns2__OpenStudiesFault), 0, soap_copy_ns2__OpenStudiesFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OpenStudiesFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OpenStudiesFault);
	if (this->soap_out(soap, tag?tag:"ns2:OpenStudiesFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OpenStudiesFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OpenStudiesFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OpenStudiesFault * SOAP_FMAC4 soap_get_ns2__OpenStudiesFault(struct soap *soap, ns2__OpenStudiesFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OpenStudiesFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OpenStudiesFault * SOAP_FMAC2 soap_instantiate_ns2__OpenStudiesFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OpenStudiesFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OpenStudiesFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OpenStudiesFault);
		if (size)
			*size = sizeof(ns2__OpenStudiesFault);
		((ns2__OpenStudiesFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenStudiesFault, n);
		if (size)
			*size = n * sizeof(ns2__OpenStudiesFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OpenStudiesFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OpenStudiesFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OpenStudiesFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OpenStudiesFault %p -> %p\n", q, p));
	*(ns2__OpenStudiesFault*)p = *(ns2__OpenStudiesFault*)q;
}

void ns2__OpenStudiesResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__OpenStudiesResult::Viewer = NULL;
}

void ns2__OpenStudiesResult::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Viewer(soap, &this->ns2__OpenStudiesResult::Viewer);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__OpenStudiesResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OpenStudiesResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OpenStudiesResult(struct soap *soap, const char *tag, int id, const ns2__OpenStudiesResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OpenStudiesResult), "ns2:OpenStudiesResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__Viewer(soap, "ns2:Viewer", -1, &(a->ns2__OpenStudiesResult::Viewer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OpenStudiesResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OpenStudiesResult(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OpenStudiesResult * SOAP_FMAC4 soap_in_ns2__OpenStudiesResult(struct soap *soap, const char *tag, ns2__OpenStudiesResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OpenStudiesResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OpenStudiesResult, sizeof(ns2__OpenStudiesResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OpenStudiesResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OpenStudiesResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Viewer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Viewer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Viewer(soap, "ns2:Viewer", &(a->ns2__OpenStudiesResult::Viewer), "ns2:Viewer"))
				{	soap_flag_Viewer1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OpenStudiesResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OpenStudiesResult, 0, sizeof(ns2__OpenStudiesResult), 0, soap_copy_ns2__OpenStudiesResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OpenStudiesResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OpenStudiesResult);
	if (this->soap_out(soap, tag?tag:"ns2:OpenStudiesResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OpenStudiesResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OpenStudiesResult(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OpenStudiesResult * SOAP_FMAC4 soap_get_ns2__OpenStudiesResult(struct soap *soap, ns2__OpenStudiesResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OpenStudiesResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OpenStudiesResult * SOAP_FMAC2 soap_instantiate_ns2__OpenStudiesResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OpenStudiesResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OpenStudiesResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OpenStudiesResult);
		if (size)
			*size = sizeof(ns2__OpenStudiesResult);
		((ns2__OpenStudiesResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenStudiesResult, n);
		if (size)
			*size = n * sizeof(ns2__OpenStudiesResult);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OpenStudiesResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OpenStudiesResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OpenStudiesResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OpenStudiesResult %p -> %p\n", q, p));
	*(ns2__OpenStudiesResult*)p = *(ns2__OpenStudiesResult*)q;
}

void ns2__OpenStudyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__OpenStudyInfo::SourceAETitle = NULL;
	this->ns2__OpenStudyInfo::StudyInstanceUid = NULL;
}

void ns2__OpenStudyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__OpenStudyInfo::SourceAETitle);
	soap_serialize_PointerTostd__string(soap, &this->ns2__OpenStudyInfo::StudyInstanceUid);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__OpenStudyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OpenStudyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OpenStudyInfo(struct soap *soap, const char *tag, int id, const ns2__OpenStudyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OpenStudyInfo), "ns2:OpenStudyInfo"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns2:SourceAETitle", -1, &(a->ns2__OpenStudyInfo::SourceAETitle), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns2:StudyInstanceUid", -1, &(a->ns2__OpenStudyInfo::StudyInstanceUid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OpenStudyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OpenStudyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OpenStudyInfo * SOAP_FMAC4 soap_in_ns2__OpenStudyInfo(struct soap *soap, const char *tag, ns2__OpenStudyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OpenStudyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OpenStudyInfo, sizeof(ns2__OpenStudyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OpenStudyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OpenStudyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_SourceAETitle1 = 1;
	size_t soap_flag_StudyInstanceUid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_SourceAETitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:SourceAETitle", &(a->ns2__OpenStudyInfo::SourceAETitle), "xsd:string"))
				{	soap_flag_SourceAETitle1--;
					continue;
				}
			if (soap_flag_StudyInstanceUid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:StudyInstanceUid", &(a->ns2__OpenStudyInfo::StudyInstanceUid), "xsd:string"))
				{	soap_flag_StudyInstanceUid1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OpenStudyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OpenStudyInfo, 0, sizeof(ns2__OpenStudyInfo), 0, soap_copy_ns2__OpenStudyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OpenStudyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OpenStudyInfo);
	if (this->soap_out(soap, tag?tag:"ns2:OpenStudyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OpenStudyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OpenStudyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OpenStudyInfo * SOAP_FMAC4 soap_get_ns2__OpenStudyInfo(struct soap *soap, ns2__OpenStudyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OpenStudyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OpenStudyInfo * SOAP_FMAC2 soap_instantiate_ns2__OpenStudyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OpenStudyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OpenStudyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OpenStudyInfo);
		if (size)
			*size = sizeof(ns2__OpenStudyInfo);
		((ns2__OpenStudyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenStudyInfo, n);
		if (size)
			*size = n * sizeof(ns2__OpenStudyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OpenStudyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OpenStudyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OpenStudyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OpenStudyInfo %p -> %p\n", q, p));
	*(ns2__OpenStudyInfo*)p = *(ns2__OpenStudyInfo*)q;
}

void ns2__ArrayOfOpenStudyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTons2__OpenStudyInfo(soap, &this->ns2__ArrayOfOpenStudyInfo::OpenStudyInfo);
}

void ns2__ArrayOfOpenStudyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__OpenStudyInfo(soap, &this->ns2__ArrayOfOpenStudyInfo::OpenStudyInfo);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__ArrayOfOpenStudyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ArrayOfOpenStudyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ArrayOfOpenStudyInfo(struct soap *soap, const char *tag, int id, const ns2__ArrayOfOpenStudyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ArrayOfOpenStudyInfo), "ns2:ArrayOfOpenStudyInfo"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__OpenStudyInfo(soap, "ns2:OpenStudyInfo", -1, &(a->ns2__ArrayOfOpenStudyInfo::OpenStudyInfo), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ArrayOfOpenStudyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ArrayOfOpenStudyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ArrayOfOpenStudyInfo * SOAP_FMAC4 soap_in_ns2__ArrayOfOpenStudyInfo(struct soap *soap, const char *tag, ns2__ArrayOfOpenStudyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ArrayOfOpenStudyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ArrayOfOpenStudyInfo, sizeof(ns2__ArrayOfOpenStudyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ArrayOfOpenStudyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ArrayOfOpenStudyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__OpenStudyInfo(soap, "ns2:OpenStudyInfo", &(a->ns2__ArrayOfOpenStudyInfo::OpenStudyInfo), "ns2:OpenStudyInfo"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ArrayOfOpenStudyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ArrayOfOpenStudyInfo, 0, sizeof(ns2__ArrayOfOpenStudyInfo), 0, soap_copy_ns2__ArrayOfOpenStudyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ArrayOfOpenStudyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ArrayOfOpenStudyInfo);
	if (this->soap_out(soap, tag?tag:"ns2:ArrayOfOpenStudyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ArrayOfOpenStudyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ArrayOfOpenStudyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ArrayOfOpenStudyInfo * SOAP_FMAC4 soap_get_ns2__ArrayOfOpenStudyInfo(struct soap *soap, ns2__ArrayOfOpenStudyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ArrayOfOpenStudyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ArrayOfOpenStudyInfo * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfOpenStudyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ArrayOfOpenStudyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ArrayOfOpenStudyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ArrayOfOpenStudyInfo);
		if (size)
			*size = sizeof(ns2__ArrayOfOpenStudyInfo);
		((ns2__ArrayOfOpenStudyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ArrayOfOpenStudyInfo, n);
		if (size)
			*size = n * sizeof(ns2__ArrayOfOpenStudyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ArrayOfOpenStudyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ArrayOfOpenStudyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ArrayOfOpenStudyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ArrayOfOpenStudyInfo %p -> %p\n", q, p));
	*(ns2__ArrayOfOpenStudyInfo*)p = *(ns2__ArrayOfOpenStudyInfo*)q;
}

void ns2__OpenStudiesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__OpenStudiesRequest::ActivateIfAlreadyOpen = NULL;
	this->ns2__OpenStudiesRequest::LoadPriors = NULL;
	this->ns2__OpenStudiesRequest::ReportFaultToUser = NULL;
	this->ns2__OpenStudiesRequest::StudiesToOpen = NULL;
}

void ns2__OpenStudiesRequest::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobool(soap, &this->ns2__OpenStudiesRequest::ActivateIfAlreadyOpen);
	soap_serialize_PointerTobool(soap, &this->ns2__OpenStudiesRequest::LoadPriors);
	soap_serialize_PointerTobool(soap, &this->ns2__OpenStudiesRequest::ReportFaultToUser);
	soap_serialize_PointerTons2__ArrayOfOpenStudyInfo(soap, &this->ns2__OpenStudiesRequest::StudiesToOpen);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__OpenStudiesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OpenStudiesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OpenStudiesRequest(struct soap *soap, const char *tag, int id, const ns2__OpenStudiesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OpenStudiesRequest), "ns2:OpenStudiesRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobool(soap, "ns2:ActivateIfAlreadyOpen", -1, &(a->ns2__OpenStudiesRequest::ActivateIfAlreadyOpen), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns2:LoadPriors", -1, &(a->ns2__OpenStudiesRequest::LoadPriors), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns2:ReportFaultToUser", -1, &(a->ns2__OpenStudiesRequest::ReportFaultToUser), ""))
		return soap->error;
	if (soap_out_PointerTons2__ArrayOfOpenStudyInfo(soap, "ns2:StudiesToOpen", -1, &(a->ns2__OpenStudiesRequest::StudiesToOpen), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OpenStudiesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OpenStudiesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OpenStudiesRequest * SOAP_FMAC4 soap_in_ns2__OpenStudiesRequest(struct soap *soap, const char *tag, ns2__OpenStudiesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OpenStudiesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OpenStudiesRequest, sizeof(ns2__OpenStudiesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OpenStudiesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OpenStudiesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ActivateIfAlreadyOpen1 = 1;
	size_t soap_flag_LoadPriors1 = 1;
	size_t soap_flag_ReportFaultToUser1 = 1;
	size_t soap_flag_StudiesToOpen1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ActivateIfAlreadyOpen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:ActivateIfAlreadyOpen", &(a->ns2__OpenStudiesRequest::ActivateIfAlreadyOpen), "xsd:boolean"))
				{	soap_flag_ActivateIfAlreadyOpen1--;
					continue;
				}
			if (soap_flag_LoadPriors1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:LoadPriors", &(a->ns2__OpenStudiesRequest::LoadPriors), "xsd:boolean"))
				{	soap_flag_LoadPriors1--;
					continue;
				}
			if (soap_flag_ReportFaultToUser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:ReportFaultToUser", &(a->ns2__OpenStudiesRequest::ReportFaultToUser), "xsd:boolean"))
				{	soap_flag_ReportFaultToUser1--;
					continue;
				}
			if (soap_flag_StudiesToOpen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ArrayOfOpenStudyInfo(soap, "ns2:StudiesToOpen", &(a->ns2__OpenStudiesRequest::StudiesToOpen), "ns2:ArrayOfOpenStudyInfo"))
				{	soap_flag_StudiesToOpen1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OpenStudiesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OpenStudiesRequest, 0, sizeof(ns2__OpenStudiesRequest), 0, soap_copy_ns2__OpenStudiesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OpenStudiesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OpenStudiesRequest);
	if (this->soap_out(soap, tag?tag:"ns2:OpenStudiesRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OpenStudiesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OpenStudiesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OpenStudiesRequest * SOAP_FMAC4 soap_get_ns2__OpenStudiesRequest(struct soap *soap, ns2__OpenStudiesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OpenStudiesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OpenStudiesRequest * SOAP_FMAC2 soap_instantiate_ns2__OpenStudiesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OpenStudiesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OpenStudiesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OpenStudiesRequest);
		if (size)
			*size = sizeof(ns2__OpenStudiesRequest);
		((ns2__OpenStudiesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenStudiesRequest, n);
		if (size)
			*size = n * sizeof(ns2__OpenStudiesRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OpenStudiesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OpenStudiesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OpenStudiesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OpenStudiesRequest %p -> %p\n", q, p));
	*(ns2__OpenStudiesRequest*)p = *(ns2__OpenStudiesRequest*)q;
}

void ns2__ViewerNotFoundFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__ViewerNotFoundFault::FailureDescription = NULL;
}

void ns2__ViewerNotFoundFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__ViewerNotFoundFault::FailureDescription);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__ViewerNotFoundFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ViewerNotFoundFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ViewerNotFoundFault(struct soap *soap, const char *tag, int id, const ns2__ViewerNotFoundFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ViewerNotFoundFault), "ns2:ViewerNotFoundFault"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns2:FailureDescription", -1, &(a->ns2__ViewerNotFoundFault::FailureDescription), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ViewerNotFoundFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ViewerNotFoundFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ViewerNotFoundFault * SOAP_FMAC4 soap_in_ns2__ViewerNotFoundFault(struct soap *soap, const char *tag, ns2__ViewerNotFoundFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ViewerNotFoundFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ViewerNotFoundFault, sizeof(ns2__ViewerNotFoundFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ViewerNotFoundFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ViewerNotFoundFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FailureDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_FailureDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:FailureDescription", &(a->ns2__ViewerNotFoundFault::FailureDescription), "xsd:string"))
				{	soap_flag_FailureDescription1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ViewerNotFoundFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ViewerNotFoundFault, 0, sizeof(ns2__ViewerNotFoundFault), 0, soap_copy_ns2__ViewerNotFoundFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ViewerNotFoundFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ViewerNotFoundFault);
	if (this->soap_out(soap, tag?tag:"ns2:ViewerNotFoundFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ViewerNotFoundFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ViewerNotFoundFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ViewerNotFoundFault * SOAP_FMAC4 soap_get_ns2__ViewerNotFoundFault(struct soap *soap, ns2__ViewerNotFoundFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ViewerNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ViewerNotFoundFault * SOAP_FMAC2 soap_instantiate_ns2__ViewerNotFoundFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ViewerNotFoundFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ViewerNotFoundFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ViewerNotFoundFault);
		if (size)
			*size = sizeof(ns2__ViewerNotFoundFault);
		((ns2__ViewerNotFoundFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ViewerNotFoundFault, n);
		if (size)
			*size = n * sizeof(ns2__ViewerNotFoundFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ViewerNotFoundFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ViewerNotFoundFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ViewerNotFoundFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ViewerNotFoundFault %p -> %p\n", q, p));
	*(ns2__ViewerNotFoundFault*)p = *(ns2__ViewerNotFoundFault*)q;
}

void ns2__GetViewerInfoResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__GetViewerInfoResult::AdditionalStudyInstanceUids = NULL;
}

void ns2__GetViewerInfoResult::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfstring(soap, &this->ns2__GetViewerInfoResult::AdditionalStudyInstanceUids);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__GetViewerInfoResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GetViewerInfoResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GetViewerInfoResult(struct soap *soap, const char *tag, int id, const ns2__GetViewerInfoResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GetViewerInfoResult), "ns2:GetViewerInfoResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ArrayOfstring(soap, "ns2:AdditionalStudyInstanceUids", -1, &(a->ns2__GetViewerInfoResult::AdditionalStudyInstanceUids), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__GetViewerInfoResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GetViewerInfoResult(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GetViewerInfoResult * SOAP_FMAC4 soap_in_ns2__GetViewerInfoResult(struct soap *soap, const char *tag, ns2__GetViewerInfoResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__GetViewerInfoResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GetViewerInfoResult, sizeof(ns2__GetViewerInfoResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__GetViewerInfoResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__GetViewerInfoResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AdditionalStudyInstanceUids1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_AdditionalStudyInstanceUids1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfstring(soap, "ns2:AdditionalStudyInstanceUids", &(a->ns2__GetViewerInfoResult::AdditionalStudyInstanceUids), "ns4:ArrayOfstring"))
				{	soap_flag_AdditionalStudyInstanceUids1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__GetViewerInfoResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GetViewerInfoResult, 0, sizeof(ns2__GetViewerInfoResult), 0, soap_copy_ns2__GetViewerInfoResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__GetViewerInfoResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__GetViewerInfoResult);
	if (this->soap_out(soap, tag?tag:"ns2:GetViewerInfoResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GetViewerInfoResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GetViewerInfoResult(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GetViewerInfoResult * SOAP_FMAC4 soap_get_ns2__GetViewerInfoResult(struct soap *soap, ns2__GetViewerInfoResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GetViewerInfoResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__GetViewerInfoResult * SOAP_FMAC2 soap_instantiate_ns2__GetViewerInfoResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GetViewerInfoResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__GetViewerInfoResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetViewerInfoResult);
		if (size)
			*size = sizeof(ns2__GetViewerInfoResult);
		((ns2__GetViewerInfoResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetViewerInfoResult, n);
		if (size)
			*size = n * sizeof(ns2__GetViewerInfoResult);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__GetViewerInfoResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__GetViewerInfoResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__GetViewerInfoResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__GetViewerInfoResult %p -> %p\n", q, p));
	*(ns2__GetViewerInfoResult*)p = *(ns2__GetViewerInfoResult*)q;
}

void ns2__GetViewerInfoRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__GetViewerInfoRequest::Viewer = NULL;
}

void ns2__GetViewerInfoRequest::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Viewer(soap, &this->ns2__GetViewerInfoRequest::Viewer);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__GetViewerInfoRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GetViewerInfoRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GetViewerInfoRequest(struct soap *soap, const char *tag, int id, const ns2__GetViewerInfoRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GetViewerInfoRequest), "ns2:GetViewerInfoRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__Viewer(soap, "ns2:Viewer", -1, &(a->ns2__GetViewerInfoRequest::Viewer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__GetViewerInfoRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GetViewerInfoRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GetViewerInfoRequest * SOAP_FMAC4 soap_in_ns2__GetViewerInfoRequest(struct soap *soap, const char *tag, ns2__GetViewerInfoRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__GetViewerInfoRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GetViewerInfoRequest, sizeof(ns2__GetViewerInfoRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__GetViewerInfoRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__GetViewerInfoRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Viewer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Viewer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Viewer(soap, "ns2:Viewer", &(a->ns2__GetViewerInfoRequest::Viewer), "ns2:Viewer"))
				{	soap_flag_Viewer1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__GetViewerInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GetViewerInfoRequest, 0, sizeof(ns2__GetViewerInfoRequest), 0, soap_copy_ns2__GetViewerInfoRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__GetViewerInfoRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__GetViewerInfoRequest);
	if (this->soap_out(soap, tag?tag:"ns2:GetViewerInfoRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GetViewerInfoRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GetViewerInfoRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GetViewerInfoRequest * SOAP_FMAC4 soap_get_ns2__GetViewerInfoRequest(struct soap *soap, ns2__GetViewerInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GetViewerInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__GetViewerInfoRequest * SOAP_FMAC2 soap_instantiate_ns2__GetViewerInfoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GetViewerInfoRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__GetViewerInfoRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetViewerInfoRequest);
		if (size)
			*size = sizeof(ns2__GetViewerInfoRequest);
		((ns2__GetViewerInfoRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetViewerInfoRequest, n);
		if (size)
			*size = n * sizeof(ns2__GetViewerInfoRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__GetViewerInfoRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__GetViewerInfoRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__GetViewerInfoRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__GetViewerInfoRequest %p -> %p\n", q, p));
	*(ns2__GetViewerInfoRequest*)p = *(ns2__GetViewerInfoRequest*)q;
}

void ns2__NoActiveViewersFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns2__NoActiveViewersFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__NoActiveViewersFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NoActiveViewersFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NoActiveViewersFault(struct soap *soap, const char *tag, int id, const ns2__NoActiveViewersFault *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns2:NoActiveViewersFault");
}

void *ns2__NoActiveViewersFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NoActiveViewersFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NoActiveViewersFault * SOAP_FMAC4 soap_in_ns2__NoActiveViewersFault(struct soap *soap, const char *tag, ns2__NoActiveViewersFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__NoActiveViewersFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NoActiveViewersFault, sizeof(ns2__NoActiveViewersFault), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NoActiveViewersFault)
			return (ns2__NoActiveViewersFault *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns2__NoActiveViewersFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NoActiveViewersFault);
	if (this->soap_out(soap, tag?tag:"ns2:NoActiveViewersFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NoActiveViewersFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NoActiveViewersFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NoActiveViewersFault * SOAP_FMAC4 soap_get_ns2__NoActiveViewersFault(struct soap *soap, ns2__NoActiveViewersFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NoActiveViewersFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NoActiveViewersFault * SOAP_FMAC2 soap_instantiate_ns2__NoActiveViewersFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NoActiveViewersFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NoActiveViewersFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NoActiveViewersFault);
		if (size)
			*size = sizeof(ns2__NoActiveViewersFault);
		((ns2__NoActiveViewersFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__NoActiveViewersFault, n);
		if (size)
			*size = n * sizeof(ns2__NoActiveViewersFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__NoActiveViewersFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__NoActiveViewersFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NoActiveViewersFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NoActiveViewersFault %p -> %p\n", q, p));
	*(ns2__NoActiveViewersFault*)p = *(ns2__NoActiveViewersFault*)q;
}

void ns2__GetActiveViewersResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__GetActiveViewersResult::ActiveViewers = NULL;
}

void ns2__GetActiveViewersResult::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ArrayOfViewer(soap, &this->ns2__GetActiveViewersResult::ActiveViewers);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__GetActiveViewersResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GetActiveViewersResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GetActiveViewersResult(struct soap *soap, const char *tag, int id, const ns2__GetActiveViewersResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GetActiveViewersResult), "ns2:GetActiveViewersResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__ArrayOfViewer(soap, "ns2:ActiveViewers", -1, &(a->ns2__GetActiveViewersResult::ActiveViewers), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__GetActiveViewersResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GetActiveViewersResult(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GetActiveViewersResult * SOAP_FMAC4 soap_in_ns2__GetActiveViewersResult(struct soap *soap, const char *tag, ns2__GetActiveViewersResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__GetActiveViewersResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GetActiveViewersResult, sizeof(ns2__GetActiveViewersResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__GetActiveViewersResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__GetActiveViewersResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ActiveViewers1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ActiveViewers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ArrayOfViewer(soap, "ns2:ActiveViewers", &(a->ns2__GetActiveViewersResult::ActiveViewers), "ns2:ArrayOfViewer"))
				{	soap_flag_ActiveViewers1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__GetActiveViewersResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GetActiveViewersResult, 0, sizeof(ns2__GetActiveViewersResult), 0, soap_copy_ns2__GetActiveViewersResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__GetActiveViewersResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__GetActiveViewersResult);
	if (this->soap_out(soap, tag?tag:"ns2:GetActiveViewersResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GetActiveViewersResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GetActiveViewersResult(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GetActiveViewersResult * SOAP_FMAC4 soap_get_ns2__GetActiveViewersResult(struct soap *soap, ns2__GetActiveViewersResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GetActiveViewersResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__GetActiveViewersResult * SOAP_FMAC2 soap_instantiate_ns2__GetActiveViewersResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GetActiveViewersResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__GetActiveViewersResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetActiveViewersResult);
		if (size)
			*size = sizeof(ns2__GetActiveViewersResult);
		((ns2__GetActiveViewersResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetActiveViewersResult, n);
		if (size)
			*size = n * sizeof(ns2__GetActiveViewersResult);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__GetActiveViewersResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__GetActiveViewersResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__GetActiveViewersResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__GetActiveViewersResult %p -> %p\n", q, p));
	*(ns2__GetActiveViewersResult*)p = *(ns2__GetActiveViewersResult*)q;
}

void ns2__NoViewersFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns2__NoViewersFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__NoViewersFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NoViewersFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NoViewersFault(struct soap *soap, const char *tag, int id, const ns2__NoViewersFault *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns2:NoViewersFault");
}

void *ns2__NoViewersFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NoViewersFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NoViewersFault * SOAP_FMAC4 soap_in_ns2__NoViewersFault(struct soap *soap, const char *tag, ns2__NoViewersFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__NoViewersFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NoViewersFault, sizeof(ns2__NoViewersFault), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NoViewersFault)
			return (ns2__NoViewersFault *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns2__NoViewersFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NoViewersFault);
	if (this->soap_out(soap, tag?tag:"ns2:NoViewersFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NoViewersFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NoViewersFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NoViewersFault * SOAP_FMAC4 soap_get_ns2__NoViewersFault(struct soap *soap, ns2__NoViewersFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NoViewersFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NoViewersFault * SOAP_FMAC2 soap_instantiate_ns2__NoViewersFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NoViewersFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NoViewersFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NoViewersFault);
		if (size)
			*size = sizeof(ns2__NoViewersFault);
		((ns2__NoViewersFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__NoViewersFault, n);
		if (size)
			*size = n * sizeof(ns2__NoViewersFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__NoViewersFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__NoViewersFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NoViewersFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NoViewersFault %p -> %p\n", q, p));
	*(ns2__NoViewersFault*)p = *(ns2__NoViewersFault*)q;
}

void ns2__ArrayOfViewer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTons2__Viewer(soap, &this->ns2__ArrayOfViewer::Viewer);
}

void ns2__ArrayOfViewer::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons2__Viewer(soap, &this->ns2__ArrayOfViewer::Viewer);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__ArrayOfViewer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ArrayOfViewer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ArrayOfViewer(struct soap *soap, const char *tag, int id, const ns2__ArrayOfViewer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ArrayOfViewer), "ns2:ArrayOfViewer"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons2__Viewer(soap, "ns2:Viewer", -1, &(a->ns2__ArrayOfViewer::Viewer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__ArrayOfViewer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ArrayOfViewer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ArrayOfViewer * SOAP_FMAC4 soap_in_ns2__ArrayOfViewer(struct soap *soap, const char *tag, ns2__ArrayOfViewer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ArrayOfViewer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ArrayOfViewer, sizeof(ns2__ArrayOfViewer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ArrayOfViewer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ArrayOfViewer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__Viewer(soap, "ns2:Viewer", &(a->ns2__ArrayOfViewer::Viewer), "ns2:Viewer"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ArrayOfViewer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ArrayOfViewer, 0, sizeof(ns2__ArrayOfViewer), 0, soap_copy_ns2__ArrayOfViewer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ArrayOfViewer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ArrayOfViewer);
	if (this->soap_out(soap, tag?tag:"ns2:ArrayOfViewer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ArrayOfViewer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ArrayOfViewer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ArrayOfViewer * SOAP_FMAC4 soap_get_ns2__ArrayOfViewer(struct soap *soap, ns2__ArrayOfViewer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ArrayOfViewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ArrayOfViewer * SOAP_FMAC2 soap_instantiate_ns2__ArrayOfViewer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ArrayOfViewer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ArrayOfViewer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ArrayOfViewer);
		if (size)
			*size = sizeof(ns2__ArrayOfViewer);
		((ns2__ArrayOfViewer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ArrayOfViewer, n);
		if (size)
			*size = n * sizeof(ns2__ArrayOfViewer);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ArrayOfViewer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ArrayOfViewer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ArrayOfViewer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ArrayOfViewer %p -> %p\n", q, p));
	*(ns2__ArrayOfViewer*)p = *(ns2__ArrayOfViewer*)q;
}

void ns2__GetViewersResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__GetViewersResult::Viewers = NULL;
}

void ns2__GetViewersResult::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ArrayOfViewer(soap, &this->ns2__GetViewersResult::Viewers);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__GetViewersResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GetViewersResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GetViewersResult(struct soap *soap, const char *tag, int id, const ns2__GetViewersResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__GetViewersResult), "ns2:GetViewersResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__ArrayOfViewer(soap, "ns2:Viewers", -1, &(a->ns2__GetViewersResult::Viewers), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__GetViewersResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GetViewersResult(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GetViewersResult * SOAP_FMAC4 soap_in_ns2__GetViewersResult(struct soap *soap, const char *tag, ns2__GetViewersResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__GetViewersResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GetViewersResult, sizeof(ns2__GetViewersResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__GetViewersResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__GetViewersResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Viewers1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Viewers1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ArrayOfViewer(soap, "ns2:Viewers", &(a->ns2__GetViewersResult::Viewers), "ns2:ArrayOfViewer"))
				{	soap_flag_Viewers1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__GetViewersResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__GetViewersResult, 0, sizeof(ns2__GetViewersResult), 0, soap_copy_ns2__GetViewersResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__GetViewersResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__GetViewersResult);
	if (this->soap_out(soap, tag?tag:"ns2:GetViewersResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GetViewersResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GetViewersResult(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GetViewersResult * SOAP_FMAC4 soap_get_ns2__GetViewersResult(struct soap *soap, ns2__GetViewersResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GetViewersResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__GetViewersResult * SOAP_FMAC2 soap_instantiate_ns2__GetViewersResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GetViewersResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__GetViewersResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetViewersResult);
		if (size)
			*size = sizeof(ns2__GetViewersResult);
		((ns2__GetViewersResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetViewersResult, n);
		if (size)
			*size = n * sizeof(ns2__GetViewersResult);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__GetViewersResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__GetViewersResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__GetViewersResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__GetViewersResult %p -> %p\n", q, p));
	*(ns2__GetViewersResult*)p = *(ns2__GetViewersResult*)q;
}

void ns2__GetViewersRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void ns2__GetViewersRequest::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__GetViewersRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__GetViewersRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__GetViewersRequest(struct soap *soap, const char *tag, int id, const ns2__GetViewersRequest *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns2:GetViewersRequest");
}

void *ns2__GetViewersRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__GetViewersRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns2__GetViewersRequest * SOAP_FMAC4 soap_in_ns2__GetViewersRequest(struct soap *soap, const char *tag, ns2__GetViewersRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns2__GetViewersRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__GetViewersRequest, sizeof(ns2__GetViewersRequest), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__GetViewersRequest)
			return (ns2__GetViewersRequest *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int ns2__GetViewersRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__GetViewersRequest);
	if (this->soap_out(soap, tag?tag:"ns2:GetViewersRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__GetViewersRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__GetViewersRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns2__GetViewersRequest * SOAP_FMAC4 soap_get_ns2__GetViewersRequest(struct soap *soap, ns2__GetViewersRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__GetViewersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__GetViewersRequest * SOAP_FMAC2 soap_instantiate_ns2__GetViewersRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__GetViewersRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__GetViewersRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__GetViewersRequest);
		if (size)
			*size = sizeof(ns2__GetViewersRequest);
		((ns2__GetViewersRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetViewersRequest, n);
		if (size)
			*size = n * sizeof(ns2__GetViewersRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__GetViewersRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__GetViewersRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__GetViewersRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__GetViewersRequest %p -> %p\n", q, p));
	*(ns2__GetViewersRequest*)p = *(ns2__GetViewersRequest*)q;
}

void ns2__OpenFilesFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__OpenFilesFault::FailureDescription = NULL;
}

void ns2__OpenFilesFault::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns2__OpenFilesFault::FailureDescription);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__OpenFilesFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OpenFilesFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OpenFilesFault(struct soap *soap, const char *tag, int id, const ns2__OpenFilesFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OpenFilesFault), "ns2:OpenFilesFault"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "ns2:FailureDescription", -1, &(a->ns2__OpenFilesFault::FailureDescription), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OpenFilesFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OpenFilesFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OpenFilesFault * SOAP_FMAC4 soap_in_ns2__OpenFilesFault(struct soap *soap, const char *tag, ns2__OpenFilesFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OpenFilesFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OpenFilesFault, sizeof(ns2__OpenFilesFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OpenFilesFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OpenFilesFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FailureDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_FailureDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns2:FailureDescription", &(a->ns2__OpenFilesFault::FailureDescription), "xsd:string"))
				{	soap_flag_FailureDescription1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OpenFilesFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OpenFilesFault, 0, sizeof(ns2__OpenFilesFault), 0, soap_copy_ns2__OpenFilesFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OpenFilesFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OpenFilesFault);
	if (this->soap_out(soap, tag?tag:"ns2:OpenFilesFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OpenFilesFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OpenFilesFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OpenFilesFault * SOAP_FMAC4 soap_get_ns2__OpenFilesFault(struct soap *soap, ns2__OpenFilesFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OpenFilesFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OpenFilesFault * SOAP_FMAC2 soap_instantiate_ns2__OpenFilesFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OpenFilesFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OpenFilesFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OpenFilesFault);
		if (size)
			*size = sizeof(ns2__OpenFilesFault);
		((ns2__OpenFilesFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenFilesFault, n);
		if (size)
			*size = n * sizeof(ns2__OpenFilesFault);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OpenFilesFault*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OpenFilesFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OpenFilesFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OpenFilesFault %p -> %p\n", q, p));
	*(ns2__OpenFilesFault*)p = *(ns2__OpenFilesFault*)q;
}

void ns2__Viewer::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_ns3__guid(soap, &this->ns2__Viewer::Identifier);
	this->ns2__Viewer::PrimaryStudyIdentifier = NULL;
}

void ns2__Viewer::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_ns3__guid(soap, &this->ns2__Viewer::Identifier);
	soap_serialize_PointerTons5__StudyRootStudyIdentifier(soap, &this->ns2__Viewer::PrimaryStudyIdentifier);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__Viewer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Viewer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Viewer(struct soap *soap, const char *tag, int id, const ns2__Viewer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Viewer), "ns2:Viewer"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_ns3__guid(soap, "ns2:Identifier", -1, &(a->ns2__Viewer::Identifier), ""))
		return soap->error;
	if (soap_out_PointerTons5__StudyRootStudyIdentifier(soap, "ns2:PrimaryStudyIdentifier", -1, &(a->ns2__Viewer::PrimaryStudyIdentifier), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__Viewer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Viewer(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Viewer * SOAP_FMAC4 soap_in_ns2__Viewer(struct soap *soap, const char *tag, ns2__Viewer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Viewer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Viewer, sizeof(ns2__Viewer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Viewer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Viewer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Identifier1 = 1;
	size_t soap_flag_PrimaryStudyIdentifier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Identifier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns3__guid(soap, "ns2:Identifier", &(a->ns2__Viewer::Identifier), "ns3:guid"))
				{	soap_flag_Identifier1--;
					continue;
				}
			if (soap_flag_PrimaryStudyIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__StudyRootStudyIdentifier(soap, "ns2:PrimaryStudyIdentifier", &(a->ns2__Viewer::PrimaryStudyIdentifier), "ns5:StudyRootStudyIdentifier"))
				{	soap_flag_PrimaryStudyIdentifier1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Viewer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Viewer, 0, sizeof(ns2__Viewer), 0, soap_copy_ns2__Viewer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Identifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__Viewer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Viewer);
	if (this->soap_out(soap, tag?tag:"ns2:Viewer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Viewer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Viewer(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Viewer * SOAP_FMAC4 soap_get_ns2__Viewer(struct soap *soap, ns2__Viewer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Viewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Viewer * SOAP_FMAC2 soap_instantiate_ns2__Viewer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Viewer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Viewer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Viewer);
		if (size)
			*size = sizeof(ns2__Viewer);
		((ns2__Viewer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Viewer, n);
		if (size)
			*size = n * sizeof(ns2__Viewer);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Viewer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Viewer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Viewer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Viewer %p -> %p\n", q, p));
	*(ns2__Viewer*)p = *(ns2__Viewer*)q;
}

void ns2__OpenFilesResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__OpenFilesResult::Viewer = NULL;
}

void ns2__OpenFilesResult::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Viewer(soap, &this->ns2__OpenFilesResult::Viewer);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__OpenFilesResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OpenFilesResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OpenFilesResult(struct soap *soap, const char *tag, int id, const ns2__OpenFilesResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OpenFilesResult), "ns2:OpenFilesResult"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons2__Viewer(soap, "ns2:Viewer", -1, &(a->ns2__OpenFilesResult::Viewer), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OpenFilesResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OpenFilesResult(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OpenFilesResult * SOAP_FMAC4 soap_in_ns2__OpenFilesResult(struct soap *soap, const char *tag, ns2__OpenFilesResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OpenFilesResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OpenFilesResult, sizeof(ns2__OpenFilesResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OpenFilesResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OpenFilesResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Viewer1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Viewer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Viewer(soap, "ns2:Viewer", &(a->ns2__OpenFilesResult::Viewer), "ns2:Viewer"))
				{	soap_flag_Viewer1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OpenFilesResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OpenFilesResult, 0, sizeof(ns2__OpenFilesResult), 0, soap_copy_ns2__OpenFilesResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OpenFilesResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OpenFilesResult);
	if (this->soap_out(soap, tag?tag:"ns2:OpenFilesResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OpenFilesResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OpenFilesResult(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OpenFilesResult * SOAP_FMAC4 soap_get_ns2__OpenFilesResult(struct soap *soap, ns2__OpenFilesResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OpenFilesResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OpenFilesResult * SOAP_FMAC2 soap_instantiate_ns2__OpenFilesResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OpenFilesResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OpenFilesResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OpenFilesResult);
		if (size)
			*size = sizeof(ns2__OpenFilesResult);
		((ns2__OpenFilesResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenFilesResult, n);
		if (size)
			*size = n * sizeof(ns2__OpenFilesResult);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OpenFilesResult*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OpenFilesResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OpenFilesResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OpenFilesResult %p -> %p\n", q, p));
	*(ns2__OpenFilesResult*)p = *(ns2__OpenFilesResult*)q;
}

void ns2__OpenFilesRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->ns2__OpenFilesRequest::Files = NULL;
	this->ns2__OpenFilesRequest::ReportFaultToUser = NULL;
	this->ns2__OpenFilesRequest::WaitForFilesToOpen = NULL;
}

void ns2__OpenFilesRequest::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ArrayOfstring(soap, &this->ns2__OpenFilesRequest::Files);
	soap_serialize_PointerTobool(soap, &this->ns2__OpenFilesRequest::ReportFaultToUser);
	soap_serialize_PointerTobool(soap, &this->ns2__OpenFilesRequest::WaitForFilesToOpen);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int ns2__OpenFilesRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__OpenFilesRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__OpenFilesRequest(struct soap *soap, const char *tag, int id, const ns2__OpenFilesRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__OpenFilesRequest), "ns2:OpenFilesRequest"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons4__ArrayOfstring(soap, "ns2:Files", -1, &(a->ns2__OpenFilesRequest::Files), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns2:ReportFaultToUser", -1, &(a->ns2__OpenFilesRequest::ReportFaultToUser), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ns2:WaitForFilesToOpen", -1, &(a->ns2__OpenFilesRequest::WaitForFilesToOpen), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__OpenFilesRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__OpenFilesRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns2__OpenFilesRequest * SOAP_FMAC4 soap_in_ns2__OpenFilesRequest(struct soap *soap, const char *tag, ns2__OpenFilesRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__OpenFilesRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__OpenFilesRequest, sizeof(ns2__OpenFilesRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__OpenFilesRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__OpenFilesRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Files1 = 1;
	size_t soap_flag_ReportFaultToUser1 = 1;
	size_t soap_flag_WaitForFilesToOpen1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Files1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ArrayOfstring(soap, "ns2:Files", &(a->ns2__OpenFilesRequest::Files), "ns4:ArrayOfstring"))
				{	soap_flag_Files1--;
					continue;
				}
			if (soap_flag_ReportFaultToUser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:ReportFaultToUser", &(a->ns2__OpenFilesRequest::ReportFaultToUser), "xsd:boolean"))
				{	soap_flag_ReportFaultToUser1--;
					continue;
				}
			if (soap_flag_WaitForFilesToOpen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ns2:WaitForFilesToOpen", &(a->ns2__OpenFilesRequest::WaitForFilesToOpen), "xsd:boolean"))
				{	soap_flag_WaitForFilesToOpen1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__OpenFilesRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__OpenFilesRequest, 0, sizeof(ns2__OpenFilesRequest), 0, soap_copy_ns2__OpenFilesRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__OpenFilesRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__OpenFilesRequest);
	if (this->soap_out(soap, tag?tag:"ns2:OpenFilesRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__OpenFilesRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__OpenFilesRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns2__OpenFilesRequest * SOAP_FMAC4 soap_get_ns2__OpenFilesRequest(struct soap *soap, ns2__OpenFilesRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__OpenFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__OpenFilesRequest * SOAP_FMAC2 soap_instantiate_ns2__OpenFilesRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__OpenFilesRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__OpenFilesRequest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__OpenFilesRequest);
		if (size)
			*size = sizeof(ns2__OpenFilesRequest);
		((ns2__OpenFilesRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenFilesRequest, n);
		if (size)
			*size = n * sizeof(ns2__OpenFilesRequest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__OpenFilesRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__OpenFilesRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__OpenFilesRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__OpenFilesRequest %p -> %p\n", q, p));
	*(ns2__OpenFilesRequest*)p = *(ns2__OpenFilesRequest*)q;
}

void xsd__unsignedShort::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_unsignedShort(soap, &this->xsd__unsignedShort::__item);
}

void xsd__unsignedShort::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__unsignedShort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort(struct soap *soap, const char *tag, int id, const xsd__unsignedShort *a, const char *type)
{
	return soap_out_unsignedShort(soap, tag, id, &(a->xsd__unsignedShort::__item), "xsd:unsignedShort");
}

void *xsd__unsignedShort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedShort(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedShort * SOAP_FMAC4 soap_in_xsd__unsignedShort(struct soap *soap, const char *tag, xsd__unsignedShort *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedShort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedShort, sizeof(xsd__unsignedShort), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedShort)
			return (xsd__unsignedShort *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedShort(soap, tag, &(a->xsd__unsignedShort::__item), "xsd:unsignedShort"))
		return NULL;
	return a;
}

int xsd__unsignedShort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedShort);
	if (this->soap_out(soap, tag?tag:"xsd:unsignedShort", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedShort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedShort(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedShort * SOAP_FMAC4 soap_get_xsd__unsignedShort(struct soap *soap, xsd__unsignedShort *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedShort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__unsignedShort * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__unsignedShort);
		if (size)
			*size = sizeof(xsd__unsignedShort);
		((xsd__unsignedShort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__unsignedShort, n);
		if (size)
			*size = n * sizeof(xsd__unsignedShort);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__unsignedShort*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__unsignedShort*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedShort %p -> %p\n", q, p));
	*(xsd__unsignedShort*)p = *(xsd__unsignedShort*)q;
}

void xsd__unsignedLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_unsignedLONG64(soap, &this->xsd__unsignedLong::__item);
}

void xsd__unsignedLong::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__unsignedLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const xsd__unsignedLong *a, const char *type)
{
	return soap_out_unsignedLONG64(soap, tag, id, &(a->xsd__unsignedLong::__item), "xsd:unsignedLong");
}

void *xsd__unsignedLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, xsd__unsignedLong *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedLong, sizeof(xsd__unsignedLong), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedLong)
			return (xsd__unsignedLong *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedLONG64(soap, tag, &(a->xsd__unsignedLong::__item), "xsd:unsignedLong"))
		return NULL;
	return a;
}

int xsd__unsignedLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong);
	if (this->soap_out(soap, tag?tag:"xsd:unsignedLong", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, xsd__unsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__unsignedLong);
		if (size)
			*size = sizeof(xsd__unsignedLong);
		((xsd__unsignedLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__unsignedLong, n);
		if (size)
			*size = n * sizeof(xsd__unsignedLong);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__unsignedLong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedLong %p -> %p\n", q, p));
	*(xsd__unsignedLong*)p = *(xsd__unsignedLong*)q;
}

void xsd__unsignedInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_unsignedInt(soap, &this->xsd__unsignedInt::__item);
}

void xsd__unsignedInt::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__unsignedInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const xsd__unsignedInt *a, const char *type)
{
	return soap_out_unsignedInt(soap, tag, id, &(a->xsd__unsignedInt::__item), "xsd:unsignedInt");
}

void *xsd__unsignedInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedInt(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, xsd__unsignedInt *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedInt, sizeof(xsd__unsignedInt), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedInt)
			return (xsd__unsignedInt *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedInt(soap, tag, &(a->xsd__unsignedInt::__item), "xsd:unsignedInt"))
		return NULL;
	return a;
}

int xsd__unsignedInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (this->soap_out(soap, tag?tag:"xsd:unsignedInt", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedInt(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, xsd__unsignedInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__unsignedInt * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__unsignedInt);
		if (size)
			*size = sizeof(xsd__unsignedInt);
		((xsd__unsignedInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__unsignedInt, n);
		if (size)
			*size = n * sizeof(xsd__unsignedInt);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__unsignedInt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedInt %p -> %p\n", q, p));
	*(xsd__unsignedInt*)p = *(xsd__unsignedInt*)q;
}

void xsd__unsignedByte_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__unsignedByte(soap, &this->xsd__unsignedByte_::__item);
}

void xsd__unsignedByte_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__unsignedByte_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedByte_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte_(struct soap *soap, const char *tag, int id, const xsd__unsignedByte_ *a, const char *type)
{
	return soap_out_xsd__unsignedByte(soap, tag, id, &(a->xsd__unsignedByte_::__item), "xsd:unsignedByte");
}

void *xsd__unsignedByte_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedByte_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_in_xsd__unsignedByte_(struct soap *soap, const char *tag, xsd__unsignedByte_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedByte_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedByte_, sizeof(xsd__unsignedByte_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedByte_)
			return (xsd__unsignedByte_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__unsignedByte(soap, tag, &(a->xsd__unsignedByte_::__item), "xsd:unsignedByte"))
		return NULL;
	return a;
}

int xsd__unsignedByte_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte_);
	if (this->soap_out(soap, tag?tag:"xsd:unsignedByte", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__unsignedByte_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedByte_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedByte_ * SOAP_FMAC4 soap_get_xsd__unsignedByte_(struct soap *soap, xsd__unsignedByte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__unsignedByte_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedByte_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedByte_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__unsignedByte_);
		if (size)
			*size = sizeof(xsd__unsignedByte_);
		((xsd__unsignedByte_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__unsignedByte_, n);
		if (size)
			*size = n * sizeof(xsd__unsignedByte_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__unsignedByte_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__unsignedByte_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedByte_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedByte_ %p -> %p\n", q, p));
	*(xsd__unsignedByte_*)p = *(xsd__unsignedByte_*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->xsd__string::__item);
}

void xsd__string::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__string::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->xsd__string::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag?tag:"xsd:string", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__string);
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__string, n);
		if (size)
			*size = n * sizeof(xsd__string);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__short::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_short(soap, &this->xsd__short::__item);
}

void xsd__short::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__short::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__short(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short(struct soap *soap, const char *tag, int id, const xsd__short *a, const char *type)
{
	return soap_out_short(soap, tag, id, &(a->xsd__short::__item), "xsd:short");
}

void *xsd__short::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__short(soap, tag, this, type);
}

SOAP_FMAC3 xsd__short * SOAP_FMAC4 soap_in_xsd__short(struct soap *soap, const char *tag, xsd__short *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__short *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__short, sizeof(xsd__short), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__short)
			return (xsd__short *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_short(soap, tag, &(a->xsd__short::__item), "xsd:short"))
		return NULL;
	return a;
}

int xsd__short::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__short);
	if (this->soap_out(soap, tag?tag:"xsd:short", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__short::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__short(soap, this, tag, type);
}

SOAP_FMAC3 xsd__short * SOAP_FMAC4 soap_get_xsd__short(struct soap *soap, xsd__short *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__short * SOAP_FMAC2 soap_instantiate_xsd__short(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__short(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__short, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__short);
		if (size)
			*size = sizeof(xsd__short);
		((xsd__short*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__short, n);
		if (size)
			*size = n * sizeof(xsd__short);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__short*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__short*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__short(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__short %p -> %p\n", q, p));
	*(xsd__short*)p = *(xsd__short*)q;
}

void xsd__long::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_LONG64(soap, &this->xsd__long::__item);
}

void xsd__long::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a, const char *type)
{
	return soap_out_LONG64(soap, tag, id, &(a->xsd__long::__item), "xsd:long");
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long)
			return (xsd__long *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_LONG64(soap, tag, &(a->xsd__long::__item), "xsd:long"))
		return NULL;
	return a;
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (this->soap_out(soap, tag?tag:"xsd:long", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__long);
		if (size)
			*size = sizeof(xsd__long);
		((xsd__long*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__long, n);
		if (size)
			*size = n * sizeof(xsd__long);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__long*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__long*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
	*(xsd__long*)p = *(xsd__long*)q;
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->xsd__int::__item);
}

void xsd__int::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__int::__item, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
		return NULL;
	return a;
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag?tag:"xsd:int", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__int);
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__int, n);
		if (size)
			*size = n * sizeof(xsd__int);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__int*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__float::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->xsd__float::__item);
}

void xsd__float::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__float::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float(struct soap *soap, const char *tag, int id, const xsd__float *a, const char *type)
{
	return soap_out_float(soap, tag, id, &(a->xsd__float::__item), "xsd:float");
}

void *xsd__float::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__float(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_in_xsd__float(struct soap *soap, const char *tag, xsd__float *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__float *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float, sizeof(xsd__float), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__float)
			return (xsd__float *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_float(soap, tag, &(a->xsd__float::__item), "xsd:float"))
		return NULL;
	return a;
}

int xsd__float::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__float);
	if (this->soap_out(soap, tag?tag:"xsd:float", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__float::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_get_xsd__float(struct soap *soap, xsd__float *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__float, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__float);
		if (size)
			*size = sizeof(xsd__float);
		((xsd__float*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__float, n);
		if (size)
			*size = n * sizeof(xsd__float);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__float*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__float*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__float(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__float %p -> %p\n", q, p));
	*(xsd__float*)p = *(xsd__float*)q;
}

void xsd__duration_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__duration(soap, &this->xsd__duration_::__item);
}

void xsd__duration_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__duration(soap, &this->xsd__duration_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__duration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__duration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration_(struct soap *soap, const char *tag, int id, const xsd__duration_ *a, const char *type)
{
	return soap_out_xsd__duration(soap, tag, id, &(a->xsd__duration_::__item), "xsd:duration");
}

void *xsd__duration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__duration_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_in_xsd__duration_(struct soap *soap, const char *tag, xsd__duration_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__duration_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration_, sizeof(xsd__duration_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__duration_)
			return (xsd__duration_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__duration(soap, tag, &(a->xsd__duration_::__item), "xsd:duration"))
		return NULL;
	return a;
}

int xsd__duration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__duration_);
	if (this->soap_out(soap, tag?tag:"xsd:duration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__duration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__duration_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration_ * SOAP_FMAC4 soap_get_xsd__duration_(struct soap *soap, xsd__duration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__duration_ * SOAP_FMAC2 soap_instantiate_xsd__duration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__duration_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__duration_);
		if (size)
			*size = sizeof(xsd__duration_);
		((xsd__duration_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__duration_, n);
		if (size)
			*size = n * sizeof(xsd__duration_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__duration_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__duration_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__duration_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__duration_ %p -> %p\n", q, p));
	*(xsd__duration_*)p = *(xsd__duration_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__duration, 0, sizeof(std::string), 0, soap_copy_xsd__duration);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__duration);
	if (soap_out_xsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__double::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_double(soap, &this->xsd__double::__item);
}

void xsd__double::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a, const char *type)
{
	return soap_out_double(soap, tag, id, &(a->xsd__double::__item), "xsd:double");
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double, sizeof(xsd__double), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double)
			return (xsd__double *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_double(soap, tag, &(a->xsd__double::__item), "xsd:double"))
		return NULL;
	return a;
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (this->soap_out(soap, tag?tag:"xsd:double", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__double);
		if (size)
			*size = sizeof(xsd__double);
		((xsd__double*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__double, n);
		if (size)
			*size = n * sizeof(xsd__double);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__double*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__double*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
	*(xsd__double*)p = *(xsd__double*)q;
}

void xsd__decimal_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__decimal(soap, &this->xsd__decimal_::__item);
}

void xsd__decimal_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__decimal(soap, &this->xsd__decimal_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__decimal_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__decimal_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal_(struct soap *soap, const char *tag, int id, const xsd__decimal_ *a, const char *type)
{
	return soap_out_xsd__decimal(soap, tag, id, &(a->xsd__decimal_::__item), "xsd:decimal");
}

void *xsd__decimal_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__decimal_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_in_xsd__decimal_(struct soap *soap, const char *tag, xsd__decimal_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__decimal_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__decimal_, sizeof(xsd__decimal_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__decimal_)
			return (xsd__decimal_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__decimal(soap, tag, &(a->xsd__decimal_::__item), "xsd:decimal"))
		return NULL;
	return a;
}

int xsd__decimal_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__decimal_);
	if (this->soap_out(soap, tag?tag:"xsd:decimal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__decimal_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__decimal_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_get_xsd__decimal_(struct soap *soap, xsd__decimal_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__decimal_ * SOAP_FMAC2 soap_instantiate_xsd__decimal_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__decimal_);
		if (size)
			*size = sizeof(xsd__decimal_);
		((xsd__decimal_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__decimal_, n);
		if (size)
			*size = n * sizeof(xsd__decimal_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__decimal_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__decimal_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__decimal_ %p -> %p\n", q, p));
	*(xsd__decimal_*)p = *(xsd__decimal_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag?tag:"xsd:decimal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_time(soap, &this->xsd__dateTime::__item);
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
		return NULL;
	return a;
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag?tag:"xsd:dateTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime);
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__dateTime, n);
		if (size)
			*size = n * sizeof(xsd__dateTime);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__dateTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__byte_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__byte(soap, &this->xsd__byte_::__item);
}

void xsd__byte_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__byte_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__byte_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte_(struct soap *soap, const char *tag, int id, const xsd__byte_ *a, const char *type)
{
	return soap_out_xsd__byte(soap, tag, id, &(a->xsd__byte_::__item), "xsd:byte");
}

void *xsd__byte_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__byte_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_in_xsd__byte_(struct soap *soap, const char *tag, xsd__byte_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__byte_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__byte_, sizeof(xsd__byte_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__byte_)
			return (xsd__byte_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__byte(soap, tag, &(a->xsd__byte_::__item), "xsd:byte"))
		return NULL;
	return a;
}

int xsd__byte_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__byte_);
	if (this->soap_out(soap, tag?tag:"xsd:byte", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__byte_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__byte_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__byte_ * SOAP_FMAC4 soap_get_xsd__byte_(struct soap *soap, xsd__byte_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__byte_ * SOAP_FMAC2 soap_instantiate_xsd__byte_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__byte_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__byte_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__byte_);
		if (size)
			*size = sizeof(xsd__byte_);
		((xsd__byte_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__byte_, n);
		if (size)
			*size = n * sizeof(xsd__byte_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__byte_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__byte_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__byte_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__byte_ %p -> %p\n", q, p));
	*(xsd__byte_*)p = *(xsd__byte_*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->xsd__boolean::__item);
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__boolean::__item, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag?tag:"xsd:boolean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__boolean, n);
		if (size)
			*size = n * sizeof(xsd__boolean);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__boolean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__base64Binary_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__base64Binary_::__item.xsd__base64Binary::soap_default(soap);
}

void xsd__base64Binary_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__base64Binary_::__item.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__base64Binary_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary_(struct soap *soap, const char *tag, int id, const xsd__base64Binary_ *a, const char *type)
{
	return (a->xsd__base64Binary_::__item).soap_out(soap, tag, id, "xsd:base64Binary");
}

void *xsd__base64Binary_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_in_xsd__base64Binary_(struct soap *soap, const char *tag, xsd__base64Binary_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__base64Binary_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary_, sizeof(xsd__base64Binary_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__base64Binary_)
			return (xsd__base64Binary_ *)a->soap_in(soap, tag, type);
	}
	if (!(a->xsd__base64Binary_::__item).soap_in(soap, tag, "xsd:base64Binary"))
		return NULL;
	return a;
}

int xsd__base64Binary_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__base64Binary_);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary_ * SOAP_FMAC4 soap_get_xsd__base64Binary_(struct soap *soap, xsd__base64Binary_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary_);
		if (size)
			*size = sizeof(xsd__base64Binary_);
		((xsd__base64Binary_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary_, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary_ %p -> %p\n", q, p));
	*(xsd__base64Binary_*)p = *(xsd__base64Binary_*)q;
}

void xsd__anyURI_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
}

void xsd__anyURI_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__anyURI_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI_(struct soap *soap, const char *tag, int id, const xsd__anyURI_ *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &(a->xsd__anyURI_::__item), "xsd:anyURI");
}

void *xsd__anyURI_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyURI_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_in_xsd__anyURI_(struct soap *soap, const char *tag, xsd__anyURI_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyURI_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI_, sizeof(xsd__anyURI_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyURI_)
			return (xsd__anyURI_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__anyURI(soap, tag, &(a->xsd__anyURI_::__item), "xsd:anyURI"))
		return NULL;
	return a;
}

int xsd__anyURI_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyURI_);
	if (this->soap_out(soap, tag?tag:"xsd:anyURI", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyURI_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_get_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__anyURI_ * SOAP_FMAC2 soap_instantiate_xsd__anyURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyURI_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__anyURI_);
		if (size)
			*size = sizeof(xsd__anyURI_);
		((xsd__anyURI_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__anyURI_, n);
		if (size)
			*size = n * sizeof(xsd__anyURI_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__anyURI_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__anyURI_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyURI_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyURI_ %p -> %p\n", q, p));
	*(xsd__anyURI_*)p = *(xsd__anyURI_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__QName_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__QName(soap, &this->xsd__QName_::__item);
}

void xsd__QName_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__QName(soap, &this->xsd__QName_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__QName_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName_(struct soap *soap, const char *tag, int id, const xsd__QName_ *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "xsd:QName");
}

void *xsd__QName_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__QName_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_in_xsd__QName_(struct soap *soap, const char *tag, xsd__QName_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__QName_, sizeof(xsd__QName_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__QName_)
			return (xsd__QName_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__QName(soap, tag, &(a->xsd__QName_::__item), "xsd:QName"))
		return NULL;
	return a;
}

int xsd__QName_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__QName_);
	if (this->soap_out(soap, tag?tag:"xsd:QName", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__QName_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_get_xsd__QName_(struct soap *soap, xsd__QName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__QName_ * SOAP_FMAC2 soap_instantiate_xsd__QName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__QName_);
		if (size)
			*size = sizeof(xsd__QName_);
		((xsd__QName_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__QName_, n);
		if (size)
			*size = n * sizeof(xsd__QName_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__QName_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__QName_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName_ %p -> %p\n", q, p));
	*(xsd__QName_*)p = *(xsd__QName_*)q;
}

void xsd__IDREF_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__IDREF(soap, &this->xsd__IDREF_::__item);
}

void xsd__IDREF_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__IDREF(soap, &this->xsd__IDREF_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__IDREF_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__IDREF_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREF_(struct soap *soap, const char *tag, int id, const xsd__IDREF_ *a, const char *type)
{
	return soap_out_xsd__IDREF(soap, tag, id, &(a->xsd__IDREF_::__item), "xsd:IDREF");
}

void *xsd__IDREF_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__IDREF_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__IDREF_ * SOAP_FMAC4 soap_in_xsd__IDREF_(struct soap *soap, const char *tag, xsd__IDREF_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__IDREF_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__IDREF_, sizeof(xsd__IDREF_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__IDREF_)
			return (xsd__IDREF_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__IDREF(soap, tag, &(a->xsd__IDREF_::__item), "xsd:IDREF"))
		return NULL;
	return a;
}

int xsd__IDREF_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__IDREF_);
	if (this->soap_out(soap, tag?tag:"xsd:IDREF", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__IDREF_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__IDREF_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__IDREF_ * SOAP_FMAC4 soap_get_xsd__IDREF_(struct soap *soap, xsd__IDREF_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREF_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__IDREF_ * SOAP_FMAC2 soap_instantiate_xsd__IDREF_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__IDREF_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__IDREF_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__IDREF_);
		if (size)
			*size = sizeof(xsd__IDREF_);
		((xsd__IDREF_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__IDREF_, n);
		if (size)
			*size = n * sizeof(xsd__IDREF_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__IDREF_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__IDREF_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__IDREF_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__IDREF_ %p -> %p\n", q, p));
	*(xsd__IDREF_*)p = *(xsd__IDREF_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__IDREF(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__IDREF(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__IDREF), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__IDREF(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__IDREF, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__IDREF, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__IDREF, 0, sizeof(std::string), 0, soap_copy_xsd__IDREF);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__IDREF(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__IDREF);
	if (soap_out_xsd__IDREF(soap, tag?tag:"xsd:IDREF", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__IDREF(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__IDREF(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__ID_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__ID(soap, &this->xsd__ID_::__item);
}

void xsd__ID_::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__ID(soap, &this->xsd__ID_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__ID_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__ID_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID_(struct soap *soap, const char *tag, int id, const xsd__ID_ *a, const char *type)
{
	return soap_out_xsd__ID(soap, tag, id, &(a->xsd__ID_::__item), "xsd:ID");
}

void *xsd__ID_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__ID_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__ID_ * SOAP_FMAC4 soap_in_xsd__ID_(struct soap *soap, const char *tag, xsd__ID_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__ID_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__ID_, sizeof(xsd__ID_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__ID_)
			return (xsd__ID_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__ID(soap, tag, &(a->xsd__ID_::__item), "xsd:ID"))
		return NULL;
	return a;
}

int xsd__ID_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__ID_);
	if (this->soap_out(soap, tag?tag:"xsd:ID", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__ID_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__ID_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__ID_ * SOAP_FMAC4 soap_get_xsd__ID_(struct soap *soap, xsd__ID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__ID_ * SOAP_FMAC2 soap_instantiate_xsd__ID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ID_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__ID_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__ID_);
		if (size)
			*size = sizeof(xsd__ID_);
		((xsd__ID_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__ID_, n);
		if (size)
			*size = n * sizeof(xsd__ID_);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__ID_*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__ID_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__ID_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__ID_ %p -> %p\n", q, p));
	*(xsd__ID_*)p = *(xsd__ID_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__ID, 0, sizeof(std::string), 0, soap_copy_xsd__ID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag?tag:"xsd:ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag?tag:"xsd:anyType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:ID"))
	{	cp->type = SOAP_TYPE_xsd__ID_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__ID_);
			if (size)
				*size = sizeof(xsd__ID_);
			((xsd__ID_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__ID_, n);
			if (size)
				*size = n * sizeof(xsd__ID_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__ID_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__ID_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:IDREF"))
	{	cp->type = SOAP_TYPE_xsd__IDREF_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__IDREF_);
			if (size)
				*size = sizeof(xsd__IDREF_);
			((xsd__IDREF_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__IDREF_, n);
			if (size)
				*size = n * sizeof(xsd__IDREF_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__IDREF_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__IDREF_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:QName"))
	{	cp->type = SOAP_TYPE_xsd__QName_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__QName_);
			if (size)
				*size = sizeof(xsd__QName_);
			((xsd__QName_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__QName_, n);
			if (size)
				*size = n * sizeof(xsd__QName_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__QName_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__QName_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:anyURI"))
	{	cp->type = SOAP_TYPE_xsd__anyURI_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__anyURI_);
			if (size)
				*size = sizeof(xsd__anyURI_);
			((xsd__anyURI_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__anyURI_, n);
			if (size)
				*size = n * sizeof(xsd__anyURI_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__anyURI_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__anyURI_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:base64Binary"))
	{	cp->type = SOAP_TYPE_xsd__base64Binary_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary_);
			if (size)
				*size = sizeof(xsd__base64Binary_);
			((xsd__base64Binary_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary_, n);
			if (size)
				*size = n * sizeof(xsd__base64Binary_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__base64Binary_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__base64Binary_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__boolean);
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__boolean, n);
			if (size)
				*size = n * sizeof(xsd__boolean);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__byte_);
			if (size)
				*size = sizeof(xsd__byte_);
			((xsd__byte_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__byte_, n);
			if (size)
				*size = n * sizeof(xsd__byte_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__byte_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__byte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__dateTime);
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__dateTime, n);
			if (size)
				*size = n * sizeof(xsd__dateTime);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:decimal"))
	{	cp->type = SOAP_TYPE_xsd__decimal_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__decimal_);
			if (size)
				*size = sizeof(xsd__decimal_);
			((xsd__decimal_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__decimal_, n);
			if (size)
				*size = n * sizeof(xsd__decimal_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__decimal_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__decimal_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__double);
			if (size)
				*size = sizeof(xsd__double);
			((xsd__double*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__double, n);
			if (size)
				*size = n * sizeof(xsd__double);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__double*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__double*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:duration"))
	{	cp->type = SOAP_TYPE_xsd__duration_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__duration_);
			if (size)
				*size = sizeof(xsd__duration_);
			((xsd__duration_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__duration_, n);
			if (size)
				*size = n * sizeof(xsd__duration_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__duration_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__duration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:float"))
	{	cp->type = SOAP_TYPE_xsd__float;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__float);
			if (size)
				*size = sizeof(xsd__float);
			((xsd__float*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__float, n);
			if (size)
				*size = n * sizeof(xsd__float);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__float*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__float*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__int);
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__int, n);
			if (size)
				*size = n * sizeof(xsd__int);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__int*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__long);
			if (size)
				*size = sizeof(xsd__long);
			((xsd__long*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__long, n);
			if (size)
				*size = n * sizeof(xsd__long);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__long*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__long*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__short);
			if (size)
				*size = sizeof(xsd__short);
			((xsd__short*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__short, n);
			if (size)
				*size = n * sizeof(xsd__short);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__short*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__short*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__string);
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__string, n);
			if (size)
				*size = n * sizeof(xsd__string);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__string*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte_;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__unsignedByte_);
			if (size)
				*size = sizeof(xsd__unsignedByte_);
			((xsd__unsignedByte_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__unsignedByte_, n);
			if (size)
				*size = n * sizeof(xsd__unsignedByte_);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__unsignedByte_*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__unsignedByte_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__unsignedInt);
			if (size)
				*size = sizeof(xsd__unsignedInt);
			((xsd__unsignedInt*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__unsignedInt, n);
			if (size)
				*size = n * sizeof(xsd__unsignedInt);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__unsignedInt*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__unsignedLong);
			if (size)
				*size = sizeof(xsd__unsignedLong);
			((xsd__unsignedLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__unsignedLong, n);
			if (size)
				*size = n * sizeof(xsd__unsignedLong);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__unsignedLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(xsd__unsignedShort);
			if (size)
				*size = sizeof(xsd__unsignedShort);
			((xsd__unsignedShort*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__unsignedShort, n);
			if (size)
				*size = n * sizeof(xsd__unsignedShort);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((xsd__unsignedShort*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (xsd__unsignedShort*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:char"))
	{	cp->type = SOAP_TYPE_ns3__char__;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__char__);
			if (size)
				*size = sizeof(ns3__char__);
			((ns3__char__*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__char__, n);
			if (size)
				*size = n * sizeof(ns3__char__);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns3__char__*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns3__char__*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:duration"))
	{	cp->type = SOAP_TYPE_ns3__duration__;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__duration__);
			if (size)
				*size = sizeof(ns3__duration__);
			((ns3__duration__*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__duration__, n);
			if (size)
				*size = n * sizeof(ns3__duration__);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns3__duration__*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns3__duration__*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:guid"))
	{	cp->type = SOAP_TYPE_ns3__guid__;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns3__guid__);
			if (size)
				*size = sizeof(ns3__guid__);
			((ns3__guid__*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns3__guid__, n);
			if (size)
				*size = n * sizeof(ns3__guid__);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns3__guid__*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns3__guid__*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:OpenFilesRequest"))
	{	cp->type = SOAP_TYPE_ns2__OpenFilesRequest;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__OpenFilesRequest);
			if (size)
				*size = sizeof(ns2__OpenFilesRequest);
			((ns2__OpenFilesRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenFilesRequest, n);
			if (size)
				*size = n * sizeof(ns2__OpenFilesRequest);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__OpenFilesRequest*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__OpenFilesRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:OpenFilesResult"))
	{	cp->type = SOAP_TYPE_ns2__OpenFilesResult;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__OpenFilesResult);
			if (size)
				*size = sizeof(ns2__OpenFilesResult);
			((ns2__OpenFilesResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenFilesResult, n);
			if (size)
				*size = n * sizeof(ns2__OpenFilesResult);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__OpenFilesResult*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__OpenFilesResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:Viewer"))
	{	cp->type = SOAP_TYPE_ns2__Viewer;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__Viewer);
			if (size)
				*size = sizeof(ns2__Viewer);
			((ns2__Viewer*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Viewer, n);
			if (size)
				*size = n * sizeof(ns2__Viewer);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__Viewer*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__Viewer*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:OpenFilesFault"))
	{	cp->type = SOAP_TYPE_ns2__OpenFilesFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__OpenFilesFault);
			if (size)
				*size = sizeof(ns2__OpenFilesFault);
			((ns2__OpenFilesFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenFilesFault, n);
			if (size)
				*size = n * sizeof(ns2__OpenFilesFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__OpenFilesFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__OpenFilesFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:GetViewersRequest"))
	{	cp->type = SOAP_TYPE_ns2__GetViewersRequest;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__GetViewersRequest);
			if (size)
				*size = sizeof(ns2__GetViewersRequest);
			((ns2__GetViewersRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetViewersRequest, n);
			if (size)
				*size = n * sizeof(ns2__GetViewersRequest);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__GetViewersRequest*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__GetViewersRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:GetViewersResult"))
	{	cp->type = SOAP_TYPE_ns2__GetViewersResult;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__GetViewersResult);
			if (size)
				*size = sizeof(ns2__GetViewersResult);
			((ns2__GetViewersResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetViewersResult, n);
			if (size)
				*size = n * sizeof(ns2__GetViewersResult);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__GetViewersResult*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__GetViewersResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ArrayOfViewer"))
	{	cp->type = SOAP_TYPE_ns2__ArrayOfViewer;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ArrayOfViewer);
			if (size)
				*size = sizeof(ns2__ArrayOfViewer);
			((ns2__ArrayOfViewer*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ArrayOfViewer, n);
			if (size)
				*size = n * sizeof(ns2__ArrayOfViewer);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__ArrayOfViewer*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__ArrayOfViewer*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:NoViewersFault"))
	{	cp->type = SOAP_TYPE_ns2__NoViewersFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__NoViewersFault);
			if (size)
				*size = sizeof(ns2__NoViewersFault);
			((ns2__NoViewersFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__NoViewersFault, n);
			if (size)
				*size = n * sizeof(ns2__NoViewersFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__NoViewersFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__NoViewersFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:GetActiveViewersResult"))
	{	cp->type = SOAP_TYPE_ns2__GetActiveViewersResult;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__GetActiveViewersResult);
			if (size)
				*size = sizeof(ns2__GetActiveViewersResult);
			((ns2__GetActiveViewersResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetActiveViewersResult, n);
			if (size)
				*size = n * sizeof(ns2__GetActiveViewersResult);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__GetActiveViewersResult*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__GetActiveViewersResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:NoActiveViewersFault"))
	{	cp->type = SOAP_TYPE_ns2__NoActiveViewersFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__NoActiveViewersFault);
			if (size)
				*size = sizeof(ns2__NoActiveViewersFault);
			((ns2__NoActiveViewersFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__NoActiveViewersFault, n);
			if (size)
				*size = n * sizeof(ns2__NoActiveViewersFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__NoActiveViewersFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__NoActiveViewersFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:GetViewerInfoRequest"))
	{	cp->type = SOAP_TYPE_ns2__GetViewerInfoRequest;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__GetViewerInfoRequest);
			if (size)
				*size = sizeof(ns2__GetViewerInfoRequest);
			((ns2__GetViewerInfoRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetViewerInfoRequest, n);
			if (size)
				*size = n * sizeof(ns2__GetViewerInfoRequest);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__GetViewerInfoRequest*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__GetViewerInfoRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:GetViewerInfoResult"))
	{	cp->type = SOAP_TYPE_ns2__GetViewerInfoResult;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__GetViewerInfoResult);
			if (size)
				*size = sizeof(ns2__GetViewerInfoResult);
			((ns2__GetViewerInfoResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__GetViewerInfoResult, n);
			if (size)
				*size = n * sizeof(ns2__GetViewerInfoResult);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__GetViewerInfoResult*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__GetViewerInfoResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ViewerNotFoundFault"))
	{	cp->type = SOAP_TYPE_ns2__ViewerNotFoundFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ViewerNotFoundFault);
			if (size)
				*size = sizeof(ns2__ViewerNotFoundFault);
			((ns2__ViewerNotFoundFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ViewerNotFoundFault, n);
			if (size)
				*size = n * sizeof(ns2__ViewerNotFoundFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__ViewerNotFoundFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__ViewerNotFoundFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:OpenStudiesRequest"))
	{	cp->type = SOAP_TYPE_ns2__OpenStudiesRequest;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__OpenStudiesRequest);
			if (size)
				*size = sizeof(ns2__OpenStudiesRequest);
			((ns2__OpenStudiesRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenStudiesRequest, n);
			if (size)
				*size = n * sizeof(ns2__OpenStudiesRequest);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__OpenStudiesRequest*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__OpenStudiesRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ArrayOfOpenStudyInfo"))
	{	cp->type = SOAP_TYPE_ns2__ArrayOfOpenStudyInfo;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ArrayOfOpenStudyInfo);
			if (size)
				*size = sizeof(ns2__ArrayOfOpenStudyInfo);
			((ns2__ArrayOfOpenStudyInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ArrayOfOpenStudyInfo, n);
			if (size)
				*size = n * sizeof(ns2__ArrayOfOpenStudyInfo);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__ArrayOfOpenStudyInfo*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__ArrayOfOpenStudyInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:OpenStudyInfo"))
	{	cp->type = SOAP_TYPE_ns2__OpenStudyInfo;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__OpenStudyInfo);
			if (size)
				*size = sizeof(ns2__OpenStudyInfo);
			((ns2__OpenStudyInfo*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenStudyInfo, n);
			if (size)
				*size = n * sizeof(ns2__OpenStudyInfo);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__OpenStudyInfo*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__OpenStudyInfo*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:OpenStudiesResult"))
	{	cp->type = SOAP_TYPE_ns2__OpenStudiesResult;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__OpenStudiesResult);
			if (size)
				*size = sizeof(ns2__OpenStudiesResult);
			((ns2__OpenStudiesResult*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenStudiesResult, n);
			if (size)
				*size = n * sizeof(ns2__OpenStudiesResult);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__OpenStudiesResult*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__OpenStudiesResult*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:OpenStudiesFault"))
	{	cp->type = SOAP_TYPE_ns2__OpenStudiesFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__OpenStudiesFault);
			if (size)
				*size = sizeof(ns2__OpenStudiesFault);
			((ns2__OpenStudiesFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__OpenStudiesFault, n);
			if (size)
				*size = n * sizeof(ns2__OpenStudiesFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__OpenStudiesFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__OpenStudiesFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:ActivateViewerRequest"))
	{	cp->type = SOAP_TYPE_ns2__ActivateViewerRequest;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__ActivateViewerRequest);
			if (size)
				*size = sizeof(ns2__ActivateViewerRequest);
			((ns2__ActivateViewerRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ActivateViewerRequest, n);
			if (size)
				*size = n * sizeof(ns2__ActivateViewerRequest);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__ActivateViewerRequest*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__ActivateViewerRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:CloseViewerRequest"))
	{	cp->type = SOAP_TYPE_ns2__CloseViewerRequest;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__CloseViewerRequest);
			if (size)
				*size = sizeof(ns2__CloseViewerRequest);
			((ns2__CloseViewerRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__CloseViewerRequest, n);
			if (size)
				*size = n * sizeof(ns2__CloseViewerRequest);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns2__CloseViewerRequest*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns2__CloseViewerRequest*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns4:ArrayOfstring"))
	{	cp->type = SOAP_TYPE_ns4__ArrayOfstring;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns4__ArrayOfstring);
			if (size)
				*size = sizeof(ns4__ArrayOfstring);
			((ns4__ArrayOfstring*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns4__ArrayOfstring, n);
			if (size)
				*size = n * sizeof(ns4__ArrayOfstring);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns4__ArrayOfstring*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns4__ArrayOfstring*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:Identifier"))
	{	cp->type = SOAP_TYPE_ns5__Identifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__Identifier);
			if (size)
				*size = sizeof(ns5__Identifier);
			((ns5__Identifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__Identifier, n);
			if (size)
				*size = n * sizeof(ns5__Identifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__Identifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__Identifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:ArrayOfStudyRootStudyIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__ArrayOfStudyRootStudyIdentifier);
			if (size)
				*size = sizeof(ns5__ArrayOfStudyRootStudyIdentifier);
			((ns5__ArrayOfStudyRootStudyIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ArrayOfStudyRootStudyIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__ArrayOfStudyRootStudyIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__ArrayOfStudyRootStudyIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__ArrayOfStudyRootStudyIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:QueryFailedFault"))
	{	cp->type = SOAP_TYPE_ns5__QueryFailedFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__QueryFailedFault);
			if (size)
				*size = sizeof(ns5__QueryFailedFault);
			((ns5__QueryFailedFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__QueryFailedFault, n);
			if (size)
				*size = n * sizeof(ns5__QueryFailedFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__QueryFailedFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__QueryFailedFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:DataValidationFault"))
	{	cp->type = SOAP_TYPE_ns5__DataValidationFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__DataValidationFault);
			if (size)
				*size = sizeof(ns5__DataValidationFault);
			((ns5__DataValidationFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__DataValidationFault, n);
			if (size)
				*size = n * sizeof(ns5__DataValidationFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__DataValidationFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__DataValidationFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:ArrayOfSeriesIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__ArrayOfSeriesIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__ArrayOfSeriesIdentifier);
			if (size)
				*size = sizeof(ns5__ArrayOfSeriesIdentifier);
			((ns5__ArrayOfSeriesIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ArrayOfSeriesIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__ArrayOfSeriesIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__ArrayOfSeriesIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__ArrayOfSeriesIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:ArrayOfImageIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__ArrayOfImageIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__ArrayOfImageIdentifier);
			if (size)
				*size = sizeof(ns5__ArrayOfImageIdentifier);
			((ns5__ArrayOfImageIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ArrayOfImageIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__ArrayOfImageIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__ArrayOfImageIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__ArrayOfImageIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:StudyNearlineFault"))
	{	cp->type = SOAP_TYPE_ns6__StudyNearlineFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns6__StudyNearlineFault);
			if (size)
				*size = sizeof(ns6__StudyNearlineFault);
			((ns6__StudyNearlineFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__StudyNearlineFault, n);
			if (size)
				*size = n * sizeof(ns6__StudyNearlineFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns6__StudyNearlineFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns6__StudyNearlineFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:StudyNotFoundFault"))
	{	cp->type = SOAP_TYPE_ns6__StudyNotFoundFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns6__StudyNotFoundFault);
			if (size)
				*size = sizeof(ns6__StudyNotFoundFault);
			((ns6__StudyNotFoundFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__StudyNotFoundFault, n);
			if (size)
				*size = n * sizeof(ns6__StudyNotFoundFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns6__StudyNotFoundFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns6__StudyNotFoundFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:StudyInUseFault"))
	{	cp->type = SOAP_TYPE_ns6__StudyInUseFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns6__StudyInUseFault);
			if (size)
				*size = sizeof(ns6__StudyInUseFault);
			((ns6__StudyInUseFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__StudyInUseFault, n);
			if (size)
				*size = n * sizeof(ns6__StudyInUseFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns6__StudyInUseFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns6__StudyInUseFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns6:StudyOfflineFault"))
	{	cp->type = SOAP_TYPE_ns6__StudyOfflineFault;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns6__StudyOfflineFault);
			if (size)
				*size = sizeof(ns6__StudyOfflineFault);
			((ns6__StudyOfflineFault*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns6__StudyOfflineFault, n);
			if (size)
				*size = n * sizeof(ns6__StudyOfflineFault);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns6__StudyOfflineFault*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns6__StudyOfflineFault*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:StudyIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__StudyIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__StudyIdentifier);
			if (size)
				*size = sizeof(ns5__StudyIdentifier);
			((ns5__StudyIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__StudyIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__StudyIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__StudyIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__StudyIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:SeriesIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__SeriesIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__SeriesIdentifier);
			if (size)
				*size = sizeof(ns5__SeriesIdentifier);
			((ns5__SeriesIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__SeriesIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__SeriesIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__SeriesIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__SeriesIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:ImageIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__ImageIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__ImageIdentifier);
			if (size)
				*size = sizeof(ns5__ImageIdentifier);
			((ns5__ImageIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__ImageIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__ImageIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__ImageIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__ImageIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:StudyRootStudyIdentifier"))
	{	cp->type = SOAP_TYPE_ns5__StudyRootStudyIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns5__StudyRootStudyIdentifier);
			if (size)
				*size = sizeof(ns5__StudyRootStudyIdentifier);
			((ns5__StudyRootStudyIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns5__StudyRootStudyIdentifier, n);
			if (size)
				*size = n * sizeof(ns5__StudyRootStudyIdentifier);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns5__StudyRootStudyIdentifier*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns5__StudyRootStudyIdentifier*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__anyType);
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__anyType, n);
		if (size)
			*size = n * sizeof(xsd__anyType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__anyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__ImageQuery__(struct soap *soap, struct __ns5__ImageQuery__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__ImageQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__ImageQuery__(struct soap *soap, const struct __ns5__ImageQuery__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__ImageQuery(soap, &a->ns5__ImageQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__ImageQuery__(struct soap *soap, const char *tag, int id, const struct __ns5__ImageQuery__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__ImageQuery(soap, "ns5:ImageQuery", -1, &a->ns5__ImageQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__ImageQuery__ * SOAP_FMAC4 soap_in___ns5__ImageQuery__(struct soap *soap, const char *tag, struct __ns5__ImageQuery__ *a, const char *type)
{
	size_t soap_flag_ns5__ImageQuery = 1;
	short soap_flag;
	a = (struct __ns5__ImageQuery__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__ImageQuery__, sizeof(struct __ns5__ImageQuery__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__ImageQuery__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__ImageQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__ImageQuery(soap, "ns5:ImageQuery", &a->ns5__ImageQuery, ""))
				{	soap_flag_ns5__ImageQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__ImageQuery__(struct soap *soap, const struct __ns5__ImageQuery__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__ImageQuery__(soap, tag?tag:"-ns5:ImageQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__ImageQuery__ * SOAP_FMAC4 soap_get___ns5__ImageQuery__(struct soap *soap, struct __ns5__ImageQuery__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__ImageQuery__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__ImageQuery__ * SOAP_FMAC2 soap_instantiate___ns5__ImageQuery__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__ImageQuery__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__ImageQuery__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__ImageQuery__);
		if (size)
			*size = sizeof(struct __ns5__ImageQuery__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__ImageQuery__, n);
		if (size)
			*size = n * sizeof(struct __ns5__ImageQuery__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__ImageQuery__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__ImageQuery__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__ImageQuery__ %p -> %p\n", q, p));
	*(struct __ns5__ImageQuery__*)p = *(struct __ns5__ImageQuery__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__SeriesQuery__(struct soap *soap, struct __ns5__SeriesQuery__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__SeriesQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__SeriesQuery__(struct soap *soap, const struct __ns5__SeriesQuery__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__SeriesQuery(soap, &a->ns5__SeriesQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__SeriesQuery__(struct soap *soap, const char *tag, int id, const struct __ns5__SeriesQuery__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__SeriesQuery(soap, "ns5:SeriesQuery", -1, &a->ns5__SeriesQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__SeriesQuery__ * SOAP_FMAC4 soap_in___ns5__SeriesQuery__(struct soap *soap, const char *tag, struct __ns5__SeriesQuery__ *a, const char *type)
{
	size_t soap_flag_ns5__SeriesQuery = 1;
	short soap_flag;
	a = (struct __ns5__SeriesQuery__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__SeriesQuery__, sizeof(struct __ns5__SeriesQuery__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__SeriesQuery__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__SeriesQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__SeriesQuery(soap, "ns5:SeriesQuery", &a->ns5__SeriesQuery, ""))
				{	soap_flag_ns5__SeriesQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__SeriesQuery__(struct soap *soap, const struct __ns5__SeriesQuery__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__SeriesQuery__(soap, tag?tag:"-ns5:SeriesQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__SeriesQuery__ * SOAP_FMAC4 soap_get___ns5__SeriesQuery__(struct soap *soap, struct __ns5__SeriesQuery__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__SeriesQuery__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__SeriesQuery__ * SOAP_FMAC2 soap_instantiate___ns5__SeriesQuery__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__SeriesQuery__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__SeriesQuery__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__SeriesQuery__);
		if (size)
			*size = sizeof(struct __ns5__SeriesQuery__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__SeriesQuery__, n);
		if (size)
			*size = n * sizeof(struct __ns5__SeriesQuery__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__SeriesQuery__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__SeriesQuery__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__SeriesQuery__ %p -> %p\n", q, p));
	*(struct __ns5__SeriesQuery__*)p = *(struct __ns5__SeriesQuery__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__StudyQuery__(struct soap *soap, struct __ns5__StudyQuery__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__StudyQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__StudyQuery__(struct soap *soap, const struct __ns5__StudyQuery__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__StudyQuery(soap, &a->ns5__StudyQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__StudyQuery__(struct soap *soap, const char *tag, int id, const struct __ns5__StudyQuery__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__StudyQuery(soap, "ns5:StudyQuery", -1, &a->ns5__StudyQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__StudyQuery__ * SOAP_FMAC4 soap_in___ns5__StudyQuery__(struct soap *soap, const char *tag, struct __ns5__StudyQuery__ *a, const char *type)
{
	size_t soap_flag_ns5__StudyQuery = 1;
	short soap_flag;
	a = (struct __ns5__StudyQuery__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__StudyQuery__, sizeof(struct __ns5__StudyQuery__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__StudyQuery__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__StudyQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__StudyQuery(soap, "ns5:StudyQuery", &a->ns5__StudyQuery, ""))
				{	soap_flag_ns5__StudyQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__StudyQuery__(struct soap *soap, const struct __ns5__StudyQuery__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__StudyQuery__(soap, tag?tag:"-ns5:StudyQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__StudyQuery__ * SOAP_FMAC4 soap_get___ns5__StudyQuery__(struct soap *soap, struct __ns5__StudyQuery__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__StudyQuery__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__StudyQuery__ * SOAP_FMAC2 soap_instantiate___ns5__StudyQuery__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__StudyQuery__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__StudyQuery__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__StudyQuery__);
		if (size)
			*size = sizeof(struct __ns5__StudyQuery__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__StudyQuery__, n);
		if (size)
			*size = n * sizeof(struct __ns5__StudyQuery__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__StudyQuery__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__StudyQuery__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__StudyQuery__ %p -> %p\n", q, p));
	*(struct __ns5__StudyQuery__*)p = *(struct __ns5__StudyQuery__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__ImageQuery_(struct soap *soap, struct __ns5__ImageQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__ImageQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__ImageQuery_(struct soap *soap, const struct __ns5__ImageQuery_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__ImageQuery(soap, &a->ns5__ImageQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__ImageQuery_(struct soap *soap, const char *tag, int id, const struct __ns5__ImageQuery_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__ImageQuery(soap, "ns5:ImageQuery", -1, &a->ns5__ImageQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__ImageQuery_ * SOAP_FMAC4 soap_in___ns5__ImageQuery_(struct soap *soap, const char *tag, struct __ns5__ImageQuery_ *a, const char *type)
{
	size_t soap_flag_ns5__ImageQuery = 1;
	short soap_flag;
	a = (struct __ns5__ImageQuery_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__ImageQuery_, sizeof(struct __ns5__ImageQuery_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__ImageQuery_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__ImageQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__ImageQuery(soap, "ns5:ImageQuery", &a->ns5__ImageQuery, ""))
				{	soap_flag_ns5__ImageQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__ImageQuery_(struct soap *soap, const struct __ns5__ImageQuery_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__ImageQuery_(soap, tag?tag:"-ns5:ImageQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__ImageQuery_ * SOAP_FMAC4 soap_get___ns5__ImageQuery_(struct soap *soap, struct __ns5__ImageQuery_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__ImageQuery_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__ImageQuery_ * SOAP_FMAC2 soap_instantiate___ns5__ImageQuery_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__ImageQuery_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__ImageQuery_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__ImageQuery_);
		if (size)
			*size = sizeof(struct __ns5__ImageQuery_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__ImageQuery_, n);
		if (size)
			*size = n * sizeof(struct __ns5__ImageQuery_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__ImageQuery_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__ImageQuery_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__ImageQuery_ %p -> %p\n", q, p));
	*(struct __ns5__ImageQuery_*)p = *(struct __ns5__ImageQuery_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__SeriesQuery_(struct soap *soap, struct __ns5__SeriesQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__SeriesQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__SeriesQuery_(struct soap *soap, const struct __ns5__SeriesQuery_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__SeriesQuery(soap, &a->ns5__SeriesQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__SeriesQuery_(struct soap *soap, const char *tag, int id, const struct __ns5__SeriesQuery_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__SeriesQuery(soap, "ns5:SeriesQuery", -1, &a->ns5__SeriesQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__SeriesQuery_ * SOAP_FMAC4 soap_in___ns5__SeriesQuery_(struct soap *soap, const char *tag, struct __ns5__SeriesQuery_ *a, const char *type)
{
	size_t soap_flag_ns5__SeriesQuery = 1;
	short soap_flag;
	a = (struct __ns5__SeriesQuery_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__SeriesQuery_, sizeof(struct __ns5__SeriesQuery_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__SeriesQuery_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__SeriesQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__SeriesQuery(soap, "ns5:SeriesQuery", &a->ns5__SeriesQuery, ""))
				{	soap_flag_ns5__SeriesQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__SeriesQuery_(struct soap *soap, const struct __ns5__SeriesQuery_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__SeriesQuery_(soap, tag?tag:"-ns5:SeriesQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__SeriesQuery_ * SOAP_FMAC4 soap_get___ns5__SeriesQuery_(struct soap *soap, struct __ns5__SeriesQuery_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__SeriesQuery_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__SeriesQuery_ * SOAP_FMAC2 soap_instantiate___ns5__SeriesQuery_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__SeriesQuery_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__SeriesQuery_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__SeriesQuery_);
		if (size)
			*size = sizeof(struct __ns5__SeriesQuery_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__SeriesQuery_, n);
		if (size)
			*size = n * sizeof(struct __ns5__SeriesQuery_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__SeriesQuery_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__SeriesQuery_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__SeriesQuery_ %p -> %p\n", q, p));
	*(struct __ns5__SeriesQuery_*)p = *(struct __ns5__SeriesQuery_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__StudyQuery_(struct soap *soap, struct __ns5__StudyQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__StudyQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__StudyQuery_(struct soap *soap, const struct __ns5__StudyQuery_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__StudyQuery(soap, &a->ns5__StudyQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__StudyQuery_(struct soap *soap, const char *tag, int id, const struct __ns5__StudyQuery_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__StudyQuery(soap, "ns5:StudyQuery", -1, &a->ns5__StudyQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__StudyQuery_ * SOAP_FMAC4 soap_in___ns5__StudyQuery_(struct soap *soap, const char *tag, struct __ns5__StudyQuery_ *a, const char *type)
{
	size_t soap_flag_ns5__StudyQuery = 1;
	short soap_flag;
	a = (struct __ns5__StudyQuery_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__StudyQuery_, sizeof(struct __ns5__StudyQuery_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__StudyQuery_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__StudyQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__StudyQuery(soap, "ns5:StudyQuery", &a->ns5__StudyQuery, ""))
				{	soap_flag_ns5__StudyQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__StudyQuery_(struct soap *soap, const struct __ns5__StudyQuery_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__StudyQuery_(soap, tag?tag:"-ns5:StudyQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__StudyQuery_ * SOAP_FMAC4 soap_get___ns5__StudyQuery_(struct soap *soap, struct __ns5__StudyQuery_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__StudyQuery_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__StudyQuery_ * SOAP_FMAC2 soap_instantiate___ns5__StudyQuery_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__StudyQuery_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__StudyQuery_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__StudyQuery_);
		if (size)
			*size = sizeof(struct __ns5__StudyQuery_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__StudyQuery_, n);
		if (size)
			*size = n * sizeof(struct __ns5__StudyQuery_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__StudyQuery_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__StudyQuery_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__StudyQuery_ %p -> %p\n", q, p));
	*(struct __ns5__StudyQuery_*)p = *(struct __ns5__StudyQuery_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__ImageQuery(struct soap *soap, struct __ns5__ImageQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__ImageQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__ImageQuery(struct soap *soap, const struct __ns5__ImageQuery *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__ImageQuery(soap, &a->ns5__ImageQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__ImageQuery(struct soap *soap, const char *tag, int id, const struct __ns5__ImageQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__ImageQuery(soap, "ns5:ImageQuery", -1, &a->ns5__ImageQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__ImageQuery * SOAP_FMAC4 soap_in___ns5__ImageQuery(struct soap *soap, const char *tag, struct __ns5__ImageQuery *a, const char *type)
{
	size_t soap_flag_ns5__ImageQuery = 1;
	short soap_flag;
	a = (struct __ns5__ImageQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__ImageQuery, sizeof(struct __ns5__ImageQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__ImageQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__ImageQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__ImageQuery(soap, "ns5:ImageQuery", &a->ns5__ImageQuery, ""))
				{	soap_flag_ns5__ImageQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__ImageQuery(struct soap *soap, const struct __ns5__ImageQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__ImageQuery(soap, tag?tag:"-ns5:ImageQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__ImageQuery * SOAP_FMAC4 soap_get___ns5__ImageQuery(struct soap *soap, struct __ns5__ImageQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__ImageQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__ImageQuery * SOAP_FMAC2 soap_instantiate___ns5__ImageQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__ImageQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__ImageQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__ImageQuery);
		if (size)
			*size = sizeof(struct __ns5__ImageQuery);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__ImageQuery, n);
		if (size)
			*size = n * sizeof(struct __ns5__ImageQuery);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__ImageQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__ImageQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__ImageQuery %p -> %p\n", q, p));
	*(struct __ns5__ImageQuery*)p = *(struct __ns5__ImageQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__SeriesQuery(struct soap *soap, struct __ns5__SeriesQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__SeriesQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__SeriesQuery(struct soap *soap, const struct __ns5__SeriesQuery *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__SeriesQuery(soap, &a->ns5__SeriesQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__SeriesQuery(struct soap *soap, const char *tag, int id, const struct __ns5__SeriesQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__SeriesQuery(soap, "ns5:SeriesQuery", -1, &a->ns5__SeriesQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__SeriesQuery * SOAP_FMAC4 soap_in___ns5__SeriesQuery(struct soap *soap, const char *tag, struct __ns5__SeriesQuery *a, const char *type)
{
	size_t soap_flag_ns5__SeriesQuery = 1;
	short soap_flag;
	a = (struct __ns5__SeriesQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__SeriesQuery, sizeof(struct __ns5__SeriesQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__SeriesQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__SeriesQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__SeriesQuery(soap, "ns5:SeriesQuery", &a->ns5__SeriesQuery, ""))
				{	soap_flag_ns5__SeriesQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__SeriesQuery(struct soap *soap, const struct __ns5__SeriesQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__SeriesQuery(soap, tag?tag:"-ns5:SeriesQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__SeriesQuery * SOAP_FMAC4 soap_get___ns5__SeriesQuery(struct soap *soap, struct __ns5__SeriesQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__SeriesQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__SeriesQuery * SOAP_FMAC2 soap_instantiate___ns5__SeriesQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__SeriesQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__SeriesQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__SeriesQuery);
		if (size)
			*size = sizeof(struct __ns5__SeriesQuery);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__SeriesQuery, n);
		if (size)
			*size = n * sizeof(struct __ns5__SeriesQuery);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__SeriesQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__SeriesQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__SeriesQuery %p -> %p\n", q, p));
	*(struct __ns5__SeriesQuery*)p = *(struct __ns5__SeriesQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns5__StudyQuery(struct soap *soap, struct __ns5__StudyQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns5__StudyQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns5__StudyQuery(struct soap *soap, const struct __ns5__StudyQuery *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns5__StudyQuery(soap, &a->ns5__StudyQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns5__StudyQuery(struct soap *soap, const char *tag, int id, const struct __ns5__StudyQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns5__StudyQuery(soap, "ns5:StudyQuery", -1, &a->ns5__StudyQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__StudyQuery * SOAP_FMAC4 soap_in___ns5__StudyQuery(struct soap *soap, const char *tag, struct __ns5__StudyQuery *a, const char *type)
{
	size_t soap_flag_ns5__StudyQuery = 1;
	short soap_flag;
	a = (struct __ns5__StudyQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns5__StudyQuery, sizeof(struct __ns5__StudyQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns5__StudyQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__StudyQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns5__StudyQuery(soap, "ns5:StudyQuery", &a->ns5__StudyQuery, ""))
				{	soap_flag_ns5__StudyQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns5__StudyQuery(struct soap *soap, const struct __ns5__StudyQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns5__StudyQuery(soap, tag?tag:"-ns5:StudyQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns5__StudyQuery * SOAP_FMAC4 soap_get___ns5__StudyQuery(struct soap *soap, struct __ns5__StudyQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns5__StudyQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns5__StudyQuery * SOAP_FMAC2 soap_instantiate___ns5__StudyQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns5__StudyQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns5__StudyQuery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns5__StudyQuery);
		if (size)
			*size = sizeof(struct __ns5__StudyQuery);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns5__StudyQuery, n);
		if (size)
			*size = n * sizeof(struct __ns5__StudyQuery);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns5__StudyQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns5__StudyQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns5__StudyQuery %p -> %p\n", q, p));
	*(struct __ns5__StudyQuery*)p = *(struct __ns5__StudyQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__CloseViewer__(struct soap *soap, struct __ns2__CloseViewer__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__CloseViewer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__CloseViewer__(struct soap *soap, const struct __ns2__CloseViewer__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__CloseViewer(soap, &a->ns2__CloseViewer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__CloseViewer__(struct soap *soap, const char *tag, int id, const struct __ns2__CloseViewer__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__CloseViewer(soap, "ns2:CloseViewer", -1, &a->ns2__CloseViewer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CloseViewer__ * SOAP_FMAC4 soap_in___ns2__CloseViewer__(struct soap *soap, const char *tag, struct __ns2__CloseViewer__ *a, const char *type)
{
	size_t soap_flag_ns2__CloseViewer = 1;
	short soap_flag;
	a = (struct __ns2__CloseViewer__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__CloseViewer__, sizeof(struct __ns2__CloseViewer__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__CloseViewer__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__CloseViewer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__CloseViewer(soap, "ns2:CloseViewer", &a->ns2__CloseViewer, ""))
				{	soap_flag_ns2__CloseViewer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__CloseViewer__(struct soap *soap, const struct __ns2__CloseViewer__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__CloseViewer__(soap, tag?tag:"-ns2:CloseViewer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CloseViewer__ * SOAP_FMAC4 soap_get___ns2__CloseViewer__(struct soap *soap, struct __ns2__CloseViewer__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__CloseViewer__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__CloseViewer__ * SOAP_FMAC2 soap_instantiate___ns2__CloseViewer__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__CloseViewer__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__CloseViewer__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__CloseViewer__);
		if (size)
			*size = sizeof(struct __ns2__CloseViewer__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__CloseViewer__, n);
		if (size)
			*size = n * sizeof(struct __ns2__CloseViewer__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__CloseViewer__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__CloseViewer__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__CloseViewer__ %p -> %p\n", q, p));
	*(struct __ns2__CloseViewer__*)p = *(struct __ns2__CloseViewer__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__ActivateViewer__(struct soap *soap, struct __ns2__ActivateViewer__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__ActivateViewer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__ActivateViewer__(struct soap *soap, const struct __ns2__ActivateViewer__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__ActivateViewer(soap, &a->ns2__ActivateViewer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ActivateViewer__(struct soap *soap, const char *tag, int id, const struct __ns2__ActivateViewer__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__ActivateViewer(soap, "ns2:ActivateViewer", -1, &a->ns2__ActivateViewer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ActivateViewer__ * SOAP_FMAC4 soap_in___ns2__ActivateViewer__(struct soap *soap, const char *tag, struct __ns2__ActivateViewer__ *a, const char *type)
{
	size_t soap_flag_ns2__ActivateViewer = 1;
	short soap_flag;
	a = (struct __ns2__ActivateViewer__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__ActivateViewer__, sizeof(struct __ns2__ActivateViewer__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__ActivateViewer__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__ActivateViewer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__ActivateViewer(soap, "ns2:ActivateViewer", &a->ns2__ActivateViewer, ""))
				{	soap_flag_ns2__ActivateViewer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__ActivateViewer__(struct soap *soap, const struct __ns2__ActivateViewer__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__ActivateViewer__(soap, tag?tag:"-ns2:ActivateViewer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ActivateViewer__ * SOAP_FMAC4 soap_get___ns2__ActivateViewer__(struct soap *soap, struct __ns2__ActivateViewer__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ActivateViewer__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__ActivateViewer__ * SOAP_FMAC2 soap_instantiate___ns2__ActivateViewer__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ActivateViewer__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__ActivateViewer__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__ActivateViewer__);
		if (size)
			*size = sizeof(struct __ns2__ActivateViewer__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__ActivateViewer__, n);
		if (size)
			*size = n * sizeof(struct __ns2__ActivateViewer__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__ActivateViewer__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ActivateViewer__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__ActivateViewer__ %p -> %p\n", q, p));
	*(struct __ns2__ActivateViewer__*)p = *(struct __ns2__ActivateViewer__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__OpenStudies__(struct soap *soap, struct __ns2__OpenStudies__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__OpenStudies = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__OpenStudies__(struct soap *soap, const struct __ns2__OpenStudies__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__OpenStudies(soap, &a->ns2__OpenStudies);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__OpenStudies__(struct soap *soap, const char *tag, int id, const struct __ns2__OpenStudies__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__OpenStudies(soap, "ns2:OpenStudies", -1, &a->ns2__OpenStudies, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenStudies__ * SOAP_FMAC4 soap_in___ns2__OpenStudies__(struct soap *soap, const char *tag, struct __ns2__OpenStudies__ *a, const char *type)
{
	size_t soap_flag_ns2__OpenStudies = 1;
	short soap_flag;
	a = (struct __ns2__OpenStudies__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__OpenStudies__, sizeof(struct __ns2__OpenStudies__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__OpenStudies__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__OpenStudies && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__OpenStudies(soap, "ns2:OpenStudies", &a->ns2__OpenStudies, ""))
				{	soap_flag_ns2__OpenStudies--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__OpenStudies__(struct soap *soap, const struct __ns2__OpenStudies__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__OpenStudies__(soap, tag?tag:"-ns2:OpenStudies", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenStudies__ * SOAP_FMAC4 soap_get___ns2__OpenStudies__(struct soap *soap, struct __ns2__OpenStudies__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__OpenStudies__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__OpenStudies__ * SOAP_FMAC2 soap_instantiate___ns2__OpenStudies__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__OpenStudies__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__OpenStudies__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__OpenStudies__);
		if (size)
			*size = sizeof(struct __ns2__OpenStudies__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__OpenStudies__, n);
		if (size)
			*size = n * sizeof(struct __ns2__OpenStudies__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__OpenStudies__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__OpenStudies__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__OpenStudies__ %p -> %p\n", q, p));
	*(struct __ns2__OpenStudies__*)p = *(struct __ns2__OpenStudies__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetViewerInfo__(struct soap *soap, struct __ns2__GetViewerInfo__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetViewerInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetViewerInfo__(struct soap *soap, const struct __ns2__GetViewerInfo__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetViewerInfo(soap, &a->ns2__GetViewerInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetViewerInfo__(struct soap *soap, const char *tag, int id, const struct __ns2__GetViewerInfo__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetViewerInfo(soap, "ns2:GetViewerInfo", -1, &a->ns2__GetViewerInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewerInfo__ * SOAP_FMAC4 soap_in___ns2__GetViewerInfo__(struct soap *soap, const char *tag, struct __ns2__GetViewerInfo__ *a, const char *type)
{
	size_t soap_flag_ns2__GetViewerInfo = 1;
	short soap_flag;
	a = (struct __ns2__GetViewerInfo__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetViewerInfo__, sizeof(struct __ns2__GetViewerInfo__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetViewerInfo__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetViewerInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetViewerInfo(soap, "ns2:GetViewerInfo", &a->ns2__GetViewerInfo, ""))
				{	soap_flag_ns2__GetViewerInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetViewerInfo__(struct soap *soap, const struct __ns2__GetViewerInfo__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetViewerInfo__(soap, tag?tag:"-ns2:GetViewerInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewerInfo__ * SOAP_FMAC4 soap_get___ns2__GetViewerInfo__(struct soap *soap, struct __ns2__GetViewerInfo__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetViewerInfo__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetViewerInfo__ * SOAP_FMAC2 soap_instantiate___ns2__GetViewerInfo__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetViewerInfo__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetViewerInfo__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetViewerInfo__);
		if (size)
			*size = sizeof(struct __ns2__GetViewerInfo__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetViewerInfo__, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetViewerInfo__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetViewerInfo__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetViewerInfo__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetViewerInfo__ %p -> %p\n", q, p));
	*(struct __ns2__GetViewerInfo__*)p = *(struct __ns2__GetViewerInfo__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetActiveViewers__(struct soap *soap, struct __ns2__GetActiveViewers__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetActiveViewers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetActiveViewers__(struct soap *soap, const struct __ns2__GetActiveViewers__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetActiveViewers(soap, &a->ns2__GetActiveViewers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetActiveViewers__(struct soap *soap, const char *tag, int id, const struct __ns2__GetActiveViewers__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetActiveViewers(soap, "ns2:GetActiveViewers", -1, &a->ns2__GetActiveViewers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetActiveViewers__ * SOAP_FMAC4 soap_in___ns2__GetActiveViewers__(struct soap *soap, const char *tag, struct __ns2__GetActiveViewers__ *a, const char *type)
{
	size_t soap_flag_ns2__GetActiveViewers = 1;
	short soap_flag;
	a = (struct __ns2__GetActiveViewers__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetActiveViewers__, sizeof(struct __ns2__GetActiveViewers__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetActiveViewers__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetActiveViewers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetActiveViewers(soap, "ns2:GetActiveViewers", &a->ns2__GetActiveViewers, ""))
				{	soap_flag_ns2__GetActiveViewers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetActiveViewers__(struct soap *soap, const struct __ns2__GetActiveViewers__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetActiveViewers__(soap, tag?tag:"-ns2:GetActiveViewers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetActiveViewers__ * SOAP_FMAC4 soap_get___ns2__GetActiveViewers__(struct soap *soap, struct __ns2__GetActiveViewers__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetActiveViewers__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetActiveViewers__ * SOAP_FMAC2 soap_instantiate___ns2__GetActiveViewers__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetActiveViewers__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetActiveViewers__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetActiveViewers__);
		if (size)
			*size = sizeof(struct __ns2__GetActiveViewers__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetActiveViewers__, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetActiveViewers__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetActiveViewers__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetActiveViewers__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetActiveViewers__ %p -> %p\n", q, p));
	*(struct __ns2__GetActiveViewers__*)p = *(struct __ns2__GetActiveViewers__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetViewers__(struct soap *soap, struct __ns2__GetViewers__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetViewers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetViewers__(struct soap *soap, const struct __ns2__GetViewers__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetViewers(soap, &a->ns2__GetViewers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetViewers__(struct soap *soap, const char *tag, int id, const struct __ns2__GetViewers__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetViewers(soap, "ns2:GetViewers", -1, &a->ns2__GetViewers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewers__ * SOAP_FMAC4 soap_in___ns2__GetViewers__(struct soap *soap, const char *tag, struct __ns2__GetViewers__ *a, const char *type)
{
	size_t soap_flag_ns2__GetViewers = 1;
	short soap_flag;
	a = (struct __ns2__GetViewers__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetViewers__, sizeof(struct __ns2__GetViewers__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetViewers__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetViewers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetViewers(soap, "ns2:GetViewers", &a->ns2__GetViewers, ""))
				{	soap_flag_ns2__GetViewers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetViewers__(struct soap *soap, const struct __ns2__GetViewers__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetViewers__(soap, tag?tag:"-ns2:GetViewers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewers__ * SOAP_FMAC4 soap_get___ns2__GetViewers__(struct soap *soap, struct __ns2__GetViewers__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetViewers__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetViewers__ * SOAP_FMAC2 soap_instantiate___ns2__GetViewers__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetViewers__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetViewers__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetViewers__);
		if (size)
			*size = sizeof(struct __ns2__GetViewers__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetViewers__, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetViewers__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetViewers__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetViewers__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetViewers__ %p -> %p\n", q, p));
	*(struct __ns2__GetViewers__*)p = *(struct __ns2__GetViewers__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__OpenFiles__(struct soap *soap, struct __ns2__OpenFiles__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__OpenFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__OpenFiles__(struct soap *soap, const struct __ns2__OpenFiles__ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__OpenFiles(soap, &a->ns2__OpenFiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__OpenFiles__(struct soap *soap, const char *tag, int id, const struct __ns2__OpenFiles__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__OpenFiles(soap, "ns2:OpenFiles", -1, &a->ns2__OpenFiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenFiles__ * SOAP_FMAC4 soap_in___ns2__OpenFiles__(struct soap *soap, const char *tag, struct __ns2__OpenFiles__ *a, const char *type)
{
	size_t soap_flag_ns2__OpenFiles = 1;
	short soap_flag;
	a = (struct __ns2__OpenFiles__ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__OpenFiles__, sizeof(struct __ns2__OpenFiles__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__OpenFiles__(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__OpenFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__OpenFiles(soap, "ns2:OpenFiles", &a->ns2__OpenFiles, ""))
				{	soap_flag_ns2__OpenFiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__OpenFiles__(struct soap *soap, const struct __ns2__OpenFiles__ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__OpenFiles__(soap, tag?tag:"-ns2:OpenFiles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenFiles__ * SOAP_FMAC4 soap_get___ns2__OpenFiles__(struct soap *soap, struct __ns2__OpenFiles__ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__OpenFiles__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__OpenFiles__ * SOAP_FMAC2 soap_instantiate___ns2__OpenFiles__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__OpenFiles__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__OpenFiles__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__OpenFiles__);
		if (size)
			*size = sizeof(struct __ns2__OpenFiles__);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__OpenFiles__, n);
		if (size)
			*size = n * sizeof(struct __ns2__OpenFiles__);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__OpenFiles__*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__OpenFiles__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__OpenFiles__ %p -> %p\n", q, p));
	*(struct __ns2__OpenFiles__*)p = *(struct __ns2__OpenFiles__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__CloseViewer_(struct soap *soap, struct __ns2__CloseViewer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__CloseViewer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__CloseViewer_(struct soap *soap, const struct __ns2__CloseViewer_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__CloseViewer(soap, &a->ns2__CloseViewer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__CloseViewer_(struct soap *soap, const char *tag, int id, const struct __ns2__CloseViewer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__CloseViewer(soap, "ns2:CloseViewer", -1, &a->ns2__CloseViewer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CloseViewer_ * SOAP_FMAC4 soap_in___ns2__CloseViewer_(struct soap *soap, const char *tag, struct __ns2__CloseViewer_ *a, const char *type)
{
	size_t soap_flag_ns2__CloseViewer = 1;
	short soap_flag;
	a = (struct __ns2__CloseViewer_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__CloseViewer_, sizeof(struct __ns2__CloseViewer_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__CloseViewer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__CloseViewer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__CloseViewer(soap, "ns2:CloseViewer", &a->ns2__CloseViewer, ""))
				{	soap_flag_ns2__CloseViewer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__CloseViewer_(struct soap *soap, const struct __ns2__CloseViewer_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__CloseViewer_(soap, tag?tag:"-ns2:CloseViewer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CloseViewer_ * SOAP_FMAC4 soap_get___ns2__CloseViewer_(struct soap *soap, struct __ns2__CloseViewer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__CloseViewer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__CloseViewer_ * SOAP_FMAC2 soap_instantiate___ns2__CloseViewer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__CloseViewer_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__CloseViewer_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__CloseViewer_);
		if (size)
			*size = sizeof(struct __ns2__CloseViewer_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__CloseViewer_, n);
		if (size)
			*size = n * sizeof(struct __ns2__CloseViewer_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__CloseViewer_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__CloseViewer_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__CloseViewer_ %p -> %p\n", q, p));
	*(struct __ns2__CloseViewer_*)p = *(struct __ns2__CloseViewer_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__ActivateViewer_(struct soap *soap, struct __ns2__ActivateViewer_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__ActivateViewer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__ActivateViewer_(struct soap *soap, const struct __ns2__ActivateViewer_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__ActivateViewer(soap, &a->ns2__ActivateViewer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ActivateViewer_(struct soap *soap, const char *tag, int id, const struct __ns2__ActivateViewer_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__ActivateViewer(soap, "ns2:ActivateViewer", -1, &a->ns2__ActivateViewer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ActivateViewer_ * SOAP_FMAC4 soap_in___ns2__ActivateViewer_(struct soap *soap, const char *tag, struct __ns2__ActivateViewer_ *a, const char *type)
{
	size_t soap_flag_ns2__ActivateViewer = 1;
	short soap_flag;
	a = (struct __ns2__ActivateViewer_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__ActivateViewer_, sizeof(struct __ns2__ActivateViewer_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__ActivateViewer_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__ActivateViewer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__ActivateViewer(soap, "ns2:ActivateViewer", &a->ns2__ActivateViewer, ""))
				{	soap_flag_ns2__ActivateViewer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__ActivateViewer_(struct soap *soap, const struct __ns2__ActivateViewer_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__ActivateViewer_(soap, tag?tag:"-ns2:ActivateViewer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ActivateViewer_ * SOAP_FMAC4 soap_get___ns2__ActivateViewer_(struct soap *soap, struct __ns2__ActivateViewer_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ActivateViewer_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__ActivateViewer_ * SOAP_FMAC2 soap_instantiate___ns2__ActivateViewer_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ActivateViewer_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__ActivateViewer_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__ActivateViewer_);
		if (size)
			*size = sizeof(struct __ns2__ActivateViewer_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__ActivateViewer_, n);
		if (size)
			*size = n * sizeof(struct __ns2__ActivateViewer_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__ActivateViewer_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ActivateViewer_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__ActivateViewer_ %p -> %p\n", q, p));
	*(struct __ns2__ActivateViewer_*)p = *(struct __ns2__ActivateViewer_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__OpenStudies_(struct soap *soap, struct __ns2__OpenStudies_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__OpenStudies = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__OpenStudies_(struct soap *soap, const struct __ns2__OpenStudies_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__OpenStudies(soap, &a->ns2__OpenStudies);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__OpenStudies_(struct soap *soap, const char *tag, int id, const struct __ns2__OpenStudies_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__OpenStudies(soap, "ns2:OpenStudies", -1, &a->ns2__OpenStudies, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenStudies_ * SOAP_FMAC4 soap_in___ns2__OpenStudies_(struct soap *soap, const char *tag, struct __ns2__OpenStudies_ *a, const char *type)
{
	size_t soap_flag_ns2__OpenStudies = 1;
	short soap_flag;
	a = (struct __ns2__OpenStudies_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__OpenStudies_, sizeof(struct __ns2__OpenStudies_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__OpenStudies_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__OpenStudies && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__OpenStudies(soap, "ns2:OpenStudies", &a->ns2__OpenStudies, ""))
				{	soap_flag_ns2__OpenStudies--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__OpenStudies_(struct soap *soap, const struct __ns2__OpenStudies_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__OpenStudies_(soap, tag?tag:"-ns2:OpenStudies", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenStudies_ * SOAP_FMAC4 soap_get___ns2__OpenStudies_(struct soap *soap, struct __ns2__OpenStudies_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__OpenStudies_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__OpenStudies_ * SOAP_FMAC2 soap_instantiate___ns2__OpenStudies_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__OpenStudies_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__OpenStudies_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__OpenStudies_);
		if (size)
			*size = sizeof(struct __ns2__OpenStudies_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__OpenStudies_, n);
		if (size)
			*size = n * sizeof(struct __ns2__OpenStudies_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__OpenStudies_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__OpenStudies_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__OpenStudies_ %p -> %p\n", q, p));
	*(struct __ns2__OpenStudies_*)p = *(struct __ns2__OpenStudies_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetViewerInfo_(struct soap *soap, struct __ns2__GetViewerInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetViewerInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetViewerInfo_(struct soap *soap, const struct __ns2__GetViewerInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetViewerInfo(soap, &a->ns2__GetViewerInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetViewerInfo_(struct soap *soap, const char *tag, int id, const struct __ns2__GetViewerInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetViewerInfo(soap, "ns2:GetViewerInfo", -1, &a->ns2__GetViewerInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewerInfo_ * SOAP_FMAC4 soap_in___ns2__GetViewerInfo_(struct soap *soap, const char *tag, struct __ns2__GetViewerInfo_ *a, const char *type)
{
	size_t soap_flag_ns2__GetViewerInfo = 1;
	short soap_flag;
	a = (struct __ns2__GetViewerInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetViewerInfo_, sizeof(struct __ns2__GetViewerInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetViewerInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetViewerInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetViewerInfo(soap, "ns2:GetViewerInfo", &a->ns2__GetViewerInfo, ""))
				{	soap_flag_ns2__GetViewerInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetViewerInfo_(struct soap *soap, const struct __ns2__GetViewerInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetViewerInfo_(soap, tag?tag:"-ns2:GetViewerInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewerInfo_ * SOAP_FMAC4 soap_get___ns2__GetViewerInfo_(struct soap *soap, struct __ns2__GetViewerInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetViewerInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetViewerInfo_ * SOAP_FMAC2 soap_instantiate___ns2__GetViewerInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetViewerInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetViewerInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetViewerInfo_);
		if (size)
			*size = sizeof(struct __ns2__GetViewerInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetViewerInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetViewerInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetViewerInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetViewerInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetViewerInfo_ %p -> %p\n", q, p));
	*(struct __ns2__GetViewerInfo_*)p = *(struct __ns2__GetViewerInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetActiveViewers_(struct soap *soap, struct __ns2__GetActiveViewers_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetActiveViewers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetActiveViewers_(struct soap *soap, const struct __ns2__GetActiveViewers_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetActiveViewers(soap, &a->ns2__GetActiveViewers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetActiveViewers_(struct soap *soap, const char *tag, int id, const struct __ns2__GetActiveViewers_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetActiveViewers(soap, "ns2:GetActiveViewers", -1, &a->ns2__GetActiveViewers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetActiveViewers_ * SOAP_FMAC4 soap_in___ns2__GetActiveViewers_(struct soap *soap, const char *tag, struct __ns2__GetActiveViewers_ *a, const char *type)
{
	size_t soap_flag_ns2__GetActiveViewers = 1;
	short soap_flag;
	a = (struct __ns2__GetActiveViewers_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetActiveViewers_, sizeof(struct __ns2__GetActiveViewers_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetActiveViewers_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetActiveViewers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetActiveViewers(soap, "ns2:GetActiveViewers", &a->ns2__GetActiveViewers, ""))
				{	soap_flag_ns2__GetActiveViewers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetActiveViewers_(struct soap *soap, const struct __ns2__GetActiveViewers_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetActiveViewers_(soap, tag?tag:"-ns2:GetActiveViewers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetActiveViewers_ * SOAP_FMAC4 soap_get___ns2__GetActiveViewers_(struct soap *soap, struct __ns2__GetActiveViewers_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetActiveViewers_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetActiveViewers_ * SOAP_FMAC2 soap_instantiate___ns2__GetActiveViewers_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetActiveViewers_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetActiveViewers_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetActiveViewers_);
		if (size)
			*size = sizeof(struct __ns2__GetActiveViewers_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetActiveViewers_, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetActiveViewers_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetActiveViewers_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetActiveViewers_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetActiveViewers_ %p -> %p\n", q, p));
	*(struct __ns2__GetActiveViewers_*)p = *(struct __ns2__GetActiveViewers_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetViewers_(struct soap *soap, struct __ns2__GetViewers_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetViewers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetViewers_(struct soap *soap, const struct __ns2__GetViewers_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetViewers(soap, &a->ns2__GetViewers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetViewers_(struct soap *soap, const char *tag, int id, const struct __ns2__GetViewers_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetViewers(soap, "ns2:GetViewers", -1, &a->ns2__GetViewers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewers_ * SOAP_FMAC4 soap_in___ns2__GetViewers_(struct soap *soap, const char *tag, struct __ns2__GetViewers_ *a, const char *type)
{
	size_t soap_flag_ns2__GetViewers = 1;
	short soap_flag;
	a = (struct __ns2__GetViewers_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetViewers_, sizeof(struct __ns2__GetViewers_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetViewers_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetViewers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetViewers(soap, "ns2:GetViewers", &a->ns2__GetViewers, ""))
				{	soap_flag_ns2__GetViewers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetViewers_(struct soap *soap, const struct __ns2__GetViewers_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetViewers_(soap, tag?tag:"-ns2:GetViewers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewers_ * SOAP_FMAC4 soap_get___ns2__GetViewers_(struct soap *soap, struct __ns2__GetViewers_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetViewers_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetViewers_ * SOAP_FMAC2 soap_instantiate___ns2__GetViewers_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetViewers_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetViewers_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetViewers_);
		if (size)
			*size = sizeof(struct __ns2__GetViewers_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetViewers_, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetViewers_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetViewers_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetViewers_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetViewers_ %p -> %p\n", q, p));
	*(struct __ns2__GetViewers_*)p = *(struct __ns2__GetViewers_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__OpenFiles_(struct soap *soap, struct __ns2__OpenFiles_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__OpenFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__OpenFiles_(struct soap *soap, const struct __ns2__OpenFiles_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__OpenFiles(soap, &a->ns2__OpenFiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__OpenFiles_(struct soap *soap, const char *tag, int id, const struct __ns2__OpenFiles_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__OpenFiles(soap, "ns2:OpenFiles", -1, &a->ns2__OpenFiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenFiles_ * SOAP_FMAC4 soap_in___ns2__OpenFiles_(struct soap *soap, const char *tag, struct __ns2__OpenFiles_ *a, const char *type)
{
	size_t soap_flag_ns2__OpenFiles = 1;
	short soap_flag;
	a = (struct __ns2__OpenFiles_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__OpenFiles_, sizeof(struct __ns2__OpenFiles_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__OpenFiles_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__OpenFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__OpenFiles(soap, "ns2:OpenFiles", &a->ns2__OpenFiles, ""))
				{	soap_flag_ns2__OpenFiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__OpenFiles_(struct soap *soap, const struct __ns2__OpenFiles_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__OpenFiles_(soap, tag?tag:"-ns2:OpenFiles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenFiles_ * SOAP_FMAC4 soap_get___ns2__OpenFiles_(struct soap *soap, struct __ns2__OpenFiles_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__OpenFiles_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__OpenFiles_ * SOAP_FMAC2 soap_instantiate___ns2__OpenFiles_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__OpenFiles_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__OpenFiles_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__OpenFiles_);
		if (size)
			*size = sizeof(struct __ns2__OpenFiles_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__OpenFiles_, n);
		if (size)
			*size = n * sizeof(struct __ns2__OpenFiles_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__OpenFiles_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__OpenFiles_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__OpenFiles_ %p -> %p\n", q, p));
	*(struct __ns2__OpenFiles_*)p = *(struct __ns2__OpenFiles_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__CloseViewer(struct soap *soap, struct __ns2__CloseViewer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__CloseViewer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__CloseViewer(struct soap *soap, const struct __ns2__CloseViewer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__CloseViewer(soap, &a->ns2__CloseViewer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__CloseViewer(struct soap *soap, const char *tag, int id, const struct __ns2__CloseViewer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__CloseViewer(soap, "ns2:CloseViewer", -1, &a->ns2__CloseViewer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CloseViewer * SOAP_FMAC4 soap_in___ns2__CloseViewer(struct soap *soap, const char *tag, struct __ns2__CloseViewer *a, const char *type)
{
	size_t soap_flag_ns2__CloseViewer = 1;
	short soap_flag;
	a = (struct __ns2__CloseViewer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__CloseViewer, sizeof(struct __ns2__CloseViewer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__CloseViewer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__CloseViewer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__CloseViewer(soap, "ns2:CloseViewer", &a->ns2__CloseViewer, ""))
				{	soap_flag_ns2__CloseViewer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__CloseViewer(struct soap *soap, const struct __ns2__CloseViewer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__CloseViewer(soap, tag?tag:"-ns2:CloseViewer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__CloseViewer * SOAP_FMAC4 soap_get___ns2__CloseViewer(struct soap *soap, struct __ns2__CloseViewer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__CloseViewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__CloseViewer * SOAP_FMAC2 soap_instantiate___ns2__CloseViewer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__CloseViewer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__CloseViewer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__CloseViewer);
		if (size)
			*size = sizeof(struct __ns2__CloseViewer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__CloseViewer, n);
		if (size)
			*size = n * sizeof(struct __ns2__CloseViewer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__CloseViewer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__CloseViewer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__CloseViewer %p -> %p\n", q, p));
	*(struct __ns2__CloseViewer*)p = *(struct __ns2__CloseViewer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__ActivateViewer(struct soap *soap, struct __ns2__ActivateViewer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__ActivateViewer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__ActivateViewer(struct soap *soap, const struct __ns2__ActivateViewer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__ActivateViewer(soap, &a->ns2__ActivateViewer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__ActivateViewer(struct soap *soap, const char *tag, int id, const struct __ns2__ActivateViewer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__ActivateViewer(soap, "ns2:ActivateViewer", -1, &a->ns2__ActivateViewer, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ActivateViewer * SOAP_FMAC4 soap_in___ns2__ActivateViewer(struct soap *soap, const char *tag, struct __ns2__ActivateViewer *a, const char *type)
{
	size_t soap_flag_ns2__ActivateViewer = 1;
	short soap_flag;
	a = (struct __ns2__ActivateViewer *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__ActivateViewer, sizeof(struct __ns2__ActivateViewer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__ActivateViewer(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__ActivateViewer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__ActivateViewer(soap, "ns2:ActivateViewer", &a->ns2__ActivateViewer, ""))
				{	soap_flag_ns2__ActivateViewer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__ActivateViewer(struct soap *soap, const struct __ns2__ActivateViewer *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__ActivateViewer(soap, tag?tag:"-ns2:ActivateViewer", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__ActivateViewer * SOAP_FMAC4 soap_get___ns2__ActivateViewer(struct soap *soap, struct __ns2__ActivateViewer *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__ActivateViewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__ActivateViewer * SOAP_FMAC2 soap_instantiate___ns2__ActivateViewer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__ActivateViewer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__ActivateViewer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__ActivateViewer);
		if (size)
			*size = sizeof(struct __ns2__ActivateViewer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__ActivateViewer, n);
		if (size)
			*size = n * sizeof(struct __ns2__ActivateViewer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__ActivateViewer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__ActivateViewer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__ActivateViewer %p -> %p\n", q, p));
	*(struct __ns2__ActivateViewer*)p = *(struct __ns2__ActivateViewer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__OpenStudies(struct soap *soap, struct __ns2__OpenStudies *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__OpenStudies = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__OpenStudies(struct soap *soap, const struct __ns2__OpenStudies *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__OpenStudies(soap, &a->ns2__OpenStudies);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__OpenStudies(struct soap *soap, const char *tag, int id, const struct __ns2__OpenStudies *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__OpenStudies(soap, "ns2:OpenStudies", -1, &a->ns2__OpenStudies, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenStudies * SOAP_FMAC4 soap_in___ns2__OpenStudies(struct soap *soap, const char *tag, struct __ns2__OpenStudies *a, const char *type)
{
	size_t soap_flag_ns2__OpenStudies = 1;
	short soap_flag;
	a = (struct __ns2__OpenStudies *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__OpenStudies, sizeof(struct __ns2__OpenStudies), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__OpenStudies(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__OpenStudies && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__OpenStudies(soap, "ns2:OpenStudies", &a->ns2__OpenStudies, ""))
				{	soap_flag_ns2__OpenStudies--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__OpenStudies(struct soap *soap, const struct __ns2__OpenStudies *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__OpenStudies(soap, tag?tag:"-ns2:OpenStudies", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenStudies * SOAP_FMAC4 soap_get___ns2__OpenStudies(struct soap *soap, struct __ns2__OpenStudies *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__OpenStudies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__OpenStudies * SOAP_FMAC2 soap_instantiate___ns2__OpenStudies(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__OpenStudies(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__OpenStudies, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__OpenStudies);
		if (size)
			*size = sizeof(struct __ns2__OpenStudies);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__OpenStudies, n);
		if (size)
			*size = n * sizeof(struct __ns2__OpenStudies);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__OpenStudies*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__OpenStudies(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__OpenStudies %p -> %p\n", q, p));
	*(struct __ns2__OpenStudies*)p = *(struct __ns2__OpenStudies*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetViewerInfo(struct soap *soap, struct __ns2__GetViewerInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetViewerInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetViewerInfo(struct soap *soap, const struct __ns2__GetViewerInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetViewerInfo(soap, &a->ns2__GetViewerInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetViewerInfo(struct soap *soap, const char *tag, int id, const struct __ns2__GetViewerInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetViewerInfo(soap, "ns2:GetViewerInfo", -1, &a->ns2__GetViewerInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewerInfo * SOAP_FMAC4 soap_in___ns2__GetViewerInfo(struct soap *soap, const char *tag, struct __ns2__GetViewerInfo *a, const char *type)
{
	size_t soap_flag_ns2__GetViewerInfo = 1;
	short soap_flag;
	a = (struct __ns2__GetViewerInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetViewerInfo, sizeof(struct __ns2__GetViewerInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetViewerInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetViewerInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetViewerInfo(soap, "ns2:GetViewerInfo", &a->ns2__GetViewerInfo, ""))
				{	soap_flag_ns2__GetViewerInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetViewerInfo(struct soap *soap, const struct __ns2__GetViewerInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetViewerInfo(soap, tag?tag:"-ns2:GetViewerInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewerInfo * SOAP_FMAC4 soap_get___ns2__GetViewerInfo(struct soap *soap, struct __ns2__GetViewerInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetViewerInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetViewerInfo * SOAP_FMAC2 soap_instantiate___ns2__GetViewerInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetViewerInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetViewerInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetViewerInfo);
		if (size)
			*size = sizeof(struct __ns2__GetViewerInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetViewerInfo, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetViewerInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetViewerInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetViewerInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetViewerInfo %p -> %p\n", q, p));
	*(struct __ns2__GetViewerInfo*)p = *(struct __ns2__GetViewerInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetActiveViewers(struct soap *soap, struct __ns2__GetActiveViewers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetActiveViewers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetActiveViewers(struct soap *soap, const struct __ns2__GetActiveViewers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetActiveViewers(soap, &a->ns2__GetActiveViewers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetActiveViewers(struct soap *soap, const char *tag, int id, const struct __ns2__GetActiveViewers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetActiveViewers(soap, "ns2:GetActiveViewers", -1, &a->ns2__GetActiveViewers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetActiveViewers * SOAP_FMAC4 soap_in___ns2__GetActiveViewers(struct soap *soap, const char *tag, struct __ns2__GetActiveViewers *a, const char *type)
{
	size_t soap_flag_ns2__GetActiveViewers = 1;
	short soap_flag;
	a = (struct __ns2__GetActiveViewers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetActiveViewers, sizeof(struct __ns2__GetActiveViewers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetActiveViewers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetActiveViewers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetActiveViewers(soap, "ns2:GetActiveViewers", &a->ns2__GetActiveViewers, ""))
				{	soap_flag_ns2__GetActiveViewers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetActiveViewers(struct soap *soap, const struct __ns2__GetActiveViewers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetActiveViewers(soap, tag?tag:"-ns2:GetActiveViewers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetActiveViewers * SOAP_FMAC4 soap_get___ns2__GetActiveViewers(struct soap *soap, struct __ns2__GetActiveViewers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetActiveViewers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetActiveViewers * SOAP_FMAC2 soap_instantiate___ns2__GetActiveViewers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetActiveViewers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetActiveViewers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetActiveViewers);
		if (size)
			*size = sizeof(struct __ns2__GetActiveViewers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetActiveViewers, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetActiveViewers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetActiveViewers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetActiveViewers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetActiveViewers %p -> %p\n", q, p));
	*(struct __ns2__GetActiveViewers*)p = *(struct __ns2__GetActiveViewers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__GetViewers(struct soap *soap, struct __ns2__GetViewers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__GetViewers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__GetViewers(struct soap *soap, const struct __ns2__GetViewers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__GetViewers(soap, &a->ns2__GetViewers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__GetViewers(struct soap *soap, const char *tag, int id, const struct __ns2__GetViewers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__GetViewers(soap, "ns2:GetViewers", -1, &a->ns2__GetViewers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewers * SOAP_FMAC4 soap_in___ns2__GetViewers(struct soap *soap, const char *tag, struct __ns2__GetViewers *a, const char *type)
{
	size_t soap_flag_ns2__GetViewers = 1;
	short soap_flag;
	a = (struct __ns2__GetViewers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__GetViewers, sizeof(struct __ns2__GetViewers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__GetViewers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__GetViewers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__GetViewers(soap, "ns2:GetViewers", &a->ns2__GetViewers, ""))
				{	soap_flag_ns2__GetViewers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__GetViewers(struct soap *soap, const struct __ns2__GetViewers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__GetViewers(soap, tag?tag:"-ns2:GetViewers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__GetViewers * SOAP_FMAC4 soap_get___ns2__GetViewers(struct soap *soap, struct __ns2__GetViewers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__GetViewers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__GetViewers * SOAP_FMAC2 soap_instantiate___ns2__GetViewers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__GetViewers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__GetViewers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__GetViewers);
		if (size)
			*size = sizeof(struct __ns2__GetViewers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__GetViewers, n);
		if (size)
			*size = n * sizeof(struct __ns2__GetViewers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__GetViewers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__GetViewers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__GetViewers %p -> %p\n", q, p));
	*(struct __ns2__GetViewers*)p = *(struct __ns2__GetViewers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__OpenFiles(struct soap *soap, struct __ns2__OpenFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__OpenFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__OpenFiles(struct soap *soap, const struct __ns2__OpenFiles *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__OpenFiles(soap, &a->ns2__OpenFiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__OpenFiles(struct soap *soap, const char *tag, int id, const struct __ns2__OpenFiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns2__OpenFiles(soap, "ns2:OpenFiles", -1, &a->ns2__OpenFiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenFiles * SOAP_FMAC4 soap_in___ns2__OpenFiles(struct soap *soap, const char *tag, struct __ns2__OpenFiles *a, const char *type)
{
	size_t soap_flag_ns2__OpenFiles = 1;
	short soap_flag;
	a = (struct __ns2__OpenFiles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__OpenFiles, sizeof(struct __ns2__OpenFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__OpenFiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__OpenFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__OpenFiles(soap, "ns2:OpenFiles", &a->ns2__OpenFiles, ""))
				{	soap_flag_ns2__OpenFiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__OpenFiles(struct soap *soap, const struct __ns2__OpenFiles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__OpenFiles(soap, tag?tag:"-ns2:OpenFiles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__OpenFiles * SOAP_FMAC4 soap_get___ns2__OpenFiles(struct soap *soap, struct __ns2__OpenFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__OpenFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns2__OpenFiles * SOAP_FMAC2 soap_instantiate___ns2__OpenFiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns2__OpenFiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns2__OpenFiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns2__OpenFiles);
		if (size)
			*size = sizeof(struct __ns2__OpenFiles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns2__OpenFiles, n);
		if (size)
			*size = n * sizeof(struct __ns2__OpenFiles);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns2__OpenFiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns2__OpenFiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns2__OpenFiles %p -> %p\n", q, p));
	*(struct __ns2__OpenFiles*)p = *(struct __ns2__OpenFiles*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->ns5__DataValidationFault_ = NULL;
	a->ns5__QueryFailedFault_ = NULL;
	a->ns2__ViewerNotFoundFault_ = NULL;
	a->ns2__NoActiveViewersFault_ = NULL;
	a->ns2__NoViewersFault_ = NULL;
	a->ns2__OpenFilesFault_ = NULL;
	a->ns2__OpenStudiesFault_ = NULL;
	a->ns6__StudyInUseFault_ = NULL;
	a->ns6__StudyNearlineFault_ = NULL;
	a->ns6__StudyNotFoundFault_ = NULL;
	a->ns6__StudyOfflineFault_ = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__DataValidationFault(soap, &a->ns5__DataValidationFault_);
	soap_serialize_PointerTons5__QueryFailedFault(soap, &a->ns5__QueryFailedFault_);
	soap_serialize_PointerTons2__ViewerNotFoundFault(soap, &a->ns2__ViewerNotFoundFault_);
	soap_serialize_PointerTons2__NoActiveViewersFault(soap, &a->ns2__NoActiveViewersFault_);
	soap_serialize_PointerTons2__NoViewersFault(soap, &a->ns2__NoViewersFault_);
	soap_serialize_PointerTons2__OpenFilesFault(soap, &a->ns2__OpenFilesFault_);
	soap_serialize_PointerTons2__OpenStudiesFault(soap, &a->ns2__OpenStudiesFault_);
	soap_serialize_PointerTons6__StudyInUseFault(soap, &a->ns6__StudyInUseFault_);
	soap_serialize_PointerTons6__StudyNearlineFault(soap, &a->ns6__StudyNearlineFault_);
	soap_serialize_PointerTons6__StudyNotFoundFault(soap, &a->ns6__StudyNotFoundFault_);
	soap_serialize_PointerTons6__StudyOfflineFault(soap, &a->ns6__StudyOfflineFault_);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_out_PointerTons5__DataValidationFault(soap, "ns5:DataValidationFault", -1, &a->ns5__DataValidationFault_, ""))
		return soap->error;
	if (soap_out_PointerTons5__QueryFailedFault(soap, "ns5:QueryFailedFault", -1, &a->ns5__QueryFailedFault_, ""))
		return soap->error;
	if (soap_out_PointerTons2__ViewerNotFoundFault(soap, "ns2:ViewerNotFoundFault", -1, &a->ns2__ViewerNotFoundFault_, ""))
		return soap->error;
	if (soap_out_PointerTons2__NoActiveViewersFault(soap, "ns2:NoActiveViewersFault", -1, &a->ns2__NoActiveViewersFault_, ""))
		return soap->error;
	if (soap_out_PointerTons2__NoViewersFault(soap, "ns2:NoViewersFault", -1, &a->ns2__NoViewersFault_, ""))
		return soap->error;
	if (soap_out_PointerTons2__OpenFilesFault(soap, "ns2:OpenFilesFault", -1, &a->ns2__OpenFilesFault_, ""))
		return soap->error;
	if (soap_out_PointerTons2__OpenStudiesFault(soap, "ns2:OpenStudiesFault", -1, &a->ns2__OpenStudiesFault_, ""))
		return soap->error;
	if (soap_out_PointerTons6__StudyInUseFault(soap, "ns6:StudyInUseFault", -1, &a->ns6__StudyInUseFault_, ""))
		return soap->error;
	if (soap_out_PointerTons6__StudyNearlineFault(soap, "ns6:StudyNearlineFault", -1, &a->ns6__StudyNearlineFault_, ""))
		return soap->error;
	if (soap_out_PointerTons6__StudyNotFoundFault(soap, "ns6:StudyNotFoundFault", -1, &a->ns6__StudyNotFoundFault_, ""))
		return soap->error;
	if (soap_out_PointerTons6__StudyOfflineFault(soap, "ns6:StudyOfflineFault", -1, &a->ns6__StudyOfflineFault_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns5__DataValidationFault_ = 1;
	size_t soap_flag_ns5__QueryFailedFault_ = 1;
	size_t soap_flag_ns2__ViewerNotFoundFault_ = 1;
	size_t soap_flag_ns2__NoActiveViewersFault_ = 1;
	size_t soap_flag_ns2__NoViewersFault_ = 1;
	size_t soap_flag_ns2__OpenFilesFault_ = 1;
	size_t soap_flag_ns2__OpenStudiesFault_ = 1;
	size_t soap_flag_ns6__StudyInUseFault_ = 1;
	size_t soap_flag_ns6__StudyNearlineFault_ = 1;
	size_t soap_flag_ns6__StudyNotFoundFault_ = 1;
	size_t soap_flag_ns6__StudyOfflineFault_ = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns5__DataValidationFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__DataValidationFault(soap, "ns5:DataValidationFault", &a->ns5__DataValidationFault_, "ns5:DataValidationFault"))
				{	soap_flag_ns5__DataValidationFault_--;
					continue;
				}
			if (soap_flag_ns5__QueryFailedFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__QueryFailedFault(soap, "ns5:QueryFailedFault", &a->ns5__QueryFailedFault_, "ns5:QueryFailedFault"))
				{	soap_flag_ns5__QueryFailedFault_--;
					continue;
				}
			if (soap_flag_ns2__ViewerNotFoundFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ViewerNotFoundFault(soap, "ns2:ViewerNotFoundFault", &a->ns2__ViewerNotFoundFault_, "ns2:ViewerNotFoundFault"))
				{	soap_flag_ns2__ViewerNotFoundFault_--;
					continue;
				}
			if (soap_flag_ns2__NoActiveViewersFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NoActiveViewersFault(soap, "ns2:NoActiveViewersFault", &a->ns2__NoActiveViewersFault_, "ns2:NoActiveViewersFault"))
				{	soap_flag_ns2__NoActiveViewersFault_--;
					continue;
				}
			if (soap_flag_ns2__NoViewersFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NoViewersFault(soap, "ns2:NoViewersFault", &a->ns2__NoViewersFault_, "ns2:NoViewersFault"))
				{	soap_flag_ns2__NoViewersFault_--;
					continue;
				}
			if (soap_flag_ns2__OpenFilesFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OpenFilesFault(soap, "ns2:OpenFilesFault", &a->ns2__OpenFilesFault_, "ns2:OpenFilesFault"))
				{	soap_flag_ns2__OpenFilesFault_--;
					continue;
				}
			if (soap_flag_ns2__OpenStudiesFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__OpenStudiesFault(soap, "ns2:OpenStudiesFault", &a->ns2__OpenStudiesFault_, "ns2:OpenStudiesFault"))
				{	soap_flag_ns2__OpenStudiesFault_--;
					continue;
				}
			if (soap_flag_ns6__StudyInUseFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__StudyInUseFault(soap, "ns6:StudyInUseFault", &a->ns6__StudyInUseFault_, "ns6:StudyInUseFault"))
				{	soap_flag_ns6__StudyInUseFault_--;
					continue;
				}
			if (soap_flag_ns6__StudyNearlineFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__StudyNearlineFault(soap, "ns6:StudyNearlineFault", &a->ns6__StudyNearlineFault_, "ns6:StudyNearlineFault"))
				{	soap_flag_ns6__StudyNearlineFault_--;
					continue;
				}
			if (soap_flag_ns6__StudyNotFoundFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__StudyNotFoundFault(soap, "ns6:StudyNotFoundFault", &a->ns6__StudyNotFoundFault_, "ns6:StudyNotFoundFault"))
				{	soap_flag_ns6__StudyNotFoundFault_--;
					continue;
				}
			if (soap_flag_ns6__StudyOfflineFault_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__StudyOfflineFault(soap, "ns6:StudyOfflineFault", &a->ns6__StudyOfflineFault_, "ns6:StudyOfflineFault"))
				{	soap_flag_ns6__StudyOfflineFault_--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__ImageQueryResponse(struct soap *soap, _ns5__ImageQueryResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__ImageQueryResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__ImageQueryResponse(struct soap *soap, const char *tag, int id, _ns5__ImageQueryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__ImageQueryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__ImageQueryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__ImageQueryResponse(struct soap *soap, const char *tag, _ns5__ImageQueryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__ImageQueryResponse **)soap_malloc(soap, sizeof(_ns5__ImageQueryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__ImageQueryResponse *)soap_instantiate__ns5__ImageQueryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__ImageQueryResponse ** p = (_ns5__ImageQueryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ImageQueryResponse, sizeof(_ns5__ImageQueryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__ImageQueryResponse(struct soap *soap, _ns5__ImageQueryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__ImageQueryResponse);
	if (soap_out_PointerTo_ns5__ImageQueryResponse(soap, tag?tag:"ns5:ImageQueryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__ImageQueryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__ImageQueryResponse(struct soap *soap, _ns5__ImageQueryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__ImageQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__ImageQuery(struct soap *soap, _ns5__ImageQuery *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__ImageQuery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__ImageQuery(struct soap *soap, const char *tag, int id, _ns5__ImageQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__ImageQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__ImageQuery ** SOAP_FMAC4 soap_in_PointerTo_ns5__ImageQuery(struct soap *soap, const char *tag, _ns5__ImageQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__ImageQuery **)soap_malloc(soap, sizeof(_ns5__ImageQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__ImageQuery *)soap_instantiate__ns5__ImageQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__ImageQuery ** p = (_ns5__ImageQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__ImageQuery, sizeof(_ns5__ImageQuery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__ImageQuery(struct soap *soap, _ns5__ImageQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__ImageQuery);
	if (soap_out_PointerTo_ns5__ImageQuery(soap, tag?tag:"ns5:ImageQuery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__ImageQuery ** SOAP_FMAC4 soap_get_PointerTo_ns5__ImageQuery(struct soap *soap, _ns5__ImageQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__ImageQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__SeriesQueryResponse(struct soap *soap, _ns5__SeriesQueryResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__SeriesQueryResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__SeriesQueryResponse(struct soap *soap, const char *tag, int id, _ns5__SeriesQueryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__SeriesQueryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__SeriesQueryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__SeriesQueryResponse(struct soap *soap, const char *tag, _ns5__SeriesQueryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__SeriesQueryResponse **)soap_malloc(soap, sizeof(_ns5__SeriesQueryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__SeriesQueryResponse *)soap_instantiate__ns5__SeriesQueryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__SeriesQueryResponse ** p = (_ns5__SeriesQueryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__SeriesQueryResponse, sizeof(_ns5__SeriesQueryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__SeriesQueryResponse(struct soap *soap, _ns5__SeriesQueryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__SeriesQueryResponse);
	if (soap_out_PointerTo_ns5__SeriesQueryResponse(soap, tag?tag:"ns5:SeriesQueryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__SeriesQueryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__SeriesQueryResponse(struct soap *soap, _ns5__SeriesQueryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__SeriesQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__SeriesQuery(struct soap *soap, _ns5__SeriesQuery *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__SeriesQuery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__SeriesQuery(struct soap *soap, const char *tag, int id, _ns5__SeriesQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__SeriesQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__SeriesQuery ** SOAP_FMAC4 soap_in_PointerTo_ns5__SeriesQuery(struct soap *soap, const char *tag, _ns5__SeriesQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__SeriesQuery **)soap_malloc(soap, sizeof(_ns5__SeriesQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__SeriesQuery *)soap_instantiate__ns5__SeriesQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__SeriesQuery ** p = (_ns5__SeriesQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__SeriesQuery, sizeof(_ns5__SeriesQuery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__SeriesQuery(struct soap *soap, _ns5__SeriesQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__SeriesQuery);
	if (soap_out_PointerTo_ns5__SeriesQuery(soap, tag?tag:"ns5:SeriesQuery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__SeriesQuery ** SOAP_FMAC4 soap_get_PointerTo_ns5__SeriesQuery(struct soap *soap, _ns5__SeriesQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__SeriesQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__StudyQueryResponse(struct soap *soap, _ns5__StudyQueryResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__StudyQueryResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__StudyQueryResponse(struct soap *soap, const char *tag, int id, _ns5__StudyQueryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__StudyQueryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__StudyQueryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__StudyQueryResponse(struct soap *soap, const char *tag, _ns5__StudyQueryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__StudyQueryResponse **)soap_malloc(soap, sizeof(_ns5__StudyQueryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__StudyQueryResponse *)soap_instantiate__ns5__StudyQueryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__StudyQueryResponse ** p = (_ns5__StudyQueryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__StudyQueryResponse, sizeof(_ns5__StudyQueryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__StudyQueryResponse(struct soap *soap, _ns5__StudyQueryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__StudyQueryResponse);
	if (soap_out_PointerTo_ns5__StudyQueryResponse(soap, tag?tag:"ns5:StudyQueryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__StudyQueryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__StudyQueryResponse(struct soap *soap, _ns5__StudyQueryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__StudyQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__StudyQuery(struct soap *soap, _ns5__StudyQuery *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__StudyQuery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__StudyQuery(struct soap *soap, const char *tag, int id, _ns5__StudyQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__StudyQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns5__StudyQuery ** SOAP_FMAC4 soap_in_PointerTo_ns5__StudyQuery(struct soap *soap, const char *tag, _ns5__StudyQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns5__StudyQuery **)soap_malloc(soap, sizeof(_ns5__StudyQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns5__StudyQuery *)soap_instantiate__ns5__StudyQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns5__StudyQuery ** p = (_ns5__StudyQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__StudyQuery, sizeof(_ns5__StudyQuery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__StudyQuery(struct soap *soap, _ns5__StudyQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns5__StudyQuery);
	if (soap_out_PointerTo_ns5__StudyQuery(soap, tag?tag:"ns5:StudyQuery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns5__StudyQuery ** SOAP_FMAC4 soap_get_PointerTo_ns5__StudyQuery(struct soap *soap, _ns5__StudyQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__StudyQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__CloseViewerResponse(struct soap *soap, _ns2__CloseViewerResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__CloseViewerResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__CloseViewerResponse(struct soap *soap, const char *tag, int id, _ns2__CloseViewerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__CloseViewerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__CloseViewerResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__CloseViewerResponse(struct soap *soap, const char *tag, _ns2__CloseViewerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__CloseViewerResponse **)soap_malloc(soap, sizeof(_ns2__CloseViewerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__CloseViewerResponse *)soap_instantiate__ns2__CloseViewerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__CloseViewerResponse ** p = (_ns2__CloseViewerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__CloseViewerResponse, sizeof(_ns2__CloseViewerResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__CloseViewerResponse(struct soap *soap, _ns2__CloseViewerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__CloseViewerResponse);
	if (soap_out_PointerTo_ns2__CloseViewerResponse(soap, tag?tag:"ns2:CloseViewerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__CloseViewerResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__CloseViewerResponse(struct soap *soap, _ns2__CloseViewerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__CloseViewerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__CloseViewer(struct soap *soap, _ns2__CloseViewer *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__CloseViewer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__CloseViewer(struct soap *soap, const char *tag, int id, _ns2__CloseViewer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__CloseViewer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__CloseViewer ** SOAP_FMAC4 soap_in_PointerTo_ns2__CloseViewer(struct soap *soap, const char *tag, _ns2__CloseViewer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__CloseViewer **)soap_malloc(soap, sizeof(_ns2__CloseViewer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__CloseViewer *)soap_instantiate__ns2__CloseViewer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__CloseViewer ** p = (_ns2__CloseViewer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__CloseViewer, sizeof(_ns2__CloseViewer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__CloseViewer(struct soap *soap, _ns2__CloseViewer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__CloseViewer);
	if (soap_out_PointerTo_ns2__CloseViewer(soap, tag?tag:"ns2:CloseViewer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__CloseViewer ** SOAP_FMAC4 soap_get_PointerTo_ns2__CloseViewer(struct soap *soap, _ns2__CloseViewer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__CloseViewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ActivateViewerResponse(struct soap *soap, _ns2__ActivateViewerResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ActivateViewerResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ActivateViewerResponse(struct soap *soap, const char *tag, int id, _ns2__ActivateViewerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ActivateViewerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__ActivateViewerResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__ActivateViewerResponse(struct soap *soap, const char *tag, _ns2__ActivateViewerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__ActivateViewerResponse **)soap_malloc(soap, sizeof(_ns2__ActivateViewerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__ActivateViewerResponse *)soap_instantiate__ns2__ActivateViewerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__ActivateViewerResponse ** p = (_ns2__ActivateViewerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ActivateViewerResponse, sizeof(_ns2__ActivateViewerResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ActivateViewerResponse(struct soap *soap, _ns2__ActivateViewerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ActivateViewerResponse);
	if (soap_out_PointerTo_ns2__ActivateViewerResponse(soap, tag?tag:"ns2:ActivateViewerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__ActivateViewerResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__ActivateViewerResponse(struct soap *soap, _ns2__ActivateViewerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ActivateViewerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__ActivateViewer(struct soap *soap, _ns2__ActivateViewer *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__ActivateViewer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__ActivateViewer(struct soap *soap, const char *tag, int id, _ns2__ActivateViewer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__ActivateViewer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__ActivateViewer ** SOAP_FMAC4 soap_in_PointerTo_ns2__ActivateViewer(struct soap *soap, const char *tag, _ns2__ActivateViewer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__ActivateViewer **)soap_malloc(soap, sizeof(_ns2__ActivateViewer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__ActivateViewer *)soap_instantiate__ns2__ActivateViewer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__ActivateViewer ** p = (_ns2__ActivateViewer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__ActivateViewer, sizeof(_ns2__ActivateViewer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__ActivateViewer(struct soap *soap, _ns2__ActivateViewer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__ActivateViewer);
	if (soap_out_PointerTo_ns2__ActivateViewer(soap, tag?tag:"ns2:ActivateViewer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__ActivateViewer ** SOAP_FMAC4 soap_get_PointerTo_ns2__ActivateViewer(struct soap *soap, _ns2__ActivateViewer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__ActivateViewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__OpenStudiesResponse(struct soap *soap, _ns2__OpenStudiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__OpenStudiesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__OpenStudiesResponse(struct soap *soap, const char *tag, int id, _ns2__OpenStudiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__OpenStudiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__OpenStudiesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__OpenStudiesResponse(struct soap *soap, const char *tag, _ns2__OpenStudiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__OpenStudiesResponse **)soap_malloc(soap, sizeof(_ns2__OpenStudiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__OpenStudiesResponse *)soap_instantiate__ns2__OpenStudiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__OpenStudiesResponse ** p = (_ns2__OpenStudiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__OpenStudiesResponse, sizeof(_ns2__OpenStudiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__OpenStudiesResponse(struct soap *soap, _ns2__OpenStudiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__OpenStudiesResponse);
	if (soap_out_PointerTo_ns2__OpenStudiesResponse(soap, tag?tag:"ns2:OpenStudiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__OpenStudiesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__OpenStudiesResponse(struct soap *soap, _ns2__OpenStudiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__OpenStudiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__OpenStudies(struct soap *soap, _ns2__OpenStudies *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__OpenStudies))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__OpenStudies(struct soap *soap, const char *tag, int id, _ns2__OpenStudies *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__OpenStudies);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__OpenStudies ** SOAP_FMAC4 soap_in_PointerTo_ns2__OpenStudies(struct soap *soap, const char *tag, _ns2__OpenStudies **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__OpenStudies **)soap_malloc(soap, sizeof(_ns2__OpenStudies *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__OpenStudies *)soap_instantiate__ns2__OpenStudies(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__OpenStudies ** p = (_ns2__OpenStudies **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__OpenStudies, sizeof(_ns2__OpenStudies), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__OpenStudies(struct soap *soap, _ns2__OpenStudies *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__OpenStudies);
	if (soap_out_PointerTo_ns2__OpenStudies(soap, tag?tag:"ns2:OpenStudies", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__OpenStudies ** SOAP_FMAC4 soap_get_PointerTo_ns2__OpenStudies(struct soap *soap, _ns2__OpenStudies **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__OpenStudies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetViewerInfoResponse(struct soap *soap, _ns2__GetViewerInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetViewerInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetViewerInfoResponse(struct soap *soap, const char *tag, int id, _ns2__GetViewerInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetViewerInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__GetViewerInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetViewerInfoResponse(struct soap *soap, const char *tag, _ns2__GetViewerInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetViewerInfoResponse **)soap_malloc(soap, sizeof(_ns2__GetViewerInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetViewerInfoResponse *)soap_instantiate__ns2__GetViewerInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__GetViewerInfoResponse ** p = (_ns2__GetViewerInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetViewerInfoResponse, sizeof(_ns2__GetViewerInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetViewerInfoResponse(struct soap *soap, _ns2__GetViewerInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__GetViewerInfoResponse);
	if (soap_out_PointerTo_ns2__GetViewerInfoResponse(soap, tag?tag:"ns2:GetViewerInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetViewerInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetViewerInfoResponse(struct soap *soap, _ns2__GetViewerInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetViewerInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetViewerInfo(struct soap *soap, _ns2__GetViewerInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetViewerInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetViewerInfo(struct soap *soap, const char *tag, int id, _ns2__GetViewerInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetViewerInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__GetViewerInfo ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetViewerInfo(struct soap *soap, const char *tag, _ns2__GetViewerInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetViewerInfo **)soap_malloc(soap, sizeof(_ns2__GetViewerInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetViewerInfo *)soap_instantiate__ns2__GetViewerInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__GetViewerInfo ** p = (_ns2__GetViewerInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetViewerInfo, sizeof(_ns2__GetViewerInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetViewerInfo(struct soap *soap, _ns2__GetViewerInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__GetViewerInfo);
	if (soap_out_PointerTo_ns2__GetViewerInfo(soap, tag?tag:"ns2:GetViewerInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetViewerInfo ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetViewerInfo(struct soap *soap, _ns2__GetViewerInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetViewerInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetActiveViewersResponse(struct soap *soap, _ns2__GetActiveViewersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetActiveViewersResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetActiveViewersResponse(struct soap *soap, const char *tag, int id, _ns2__GetActiveViewersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetActiveViewersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__GetActiveViewersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetActiveViewersResponse(struct soap *soap, const char *tag, _ns2__GetActiveViewersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetActiveViewersResponse **)soap_malloc(soap, sizeof(_ns2__GetActiveViewersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetActiveViewersResponse *)soap_instantiate__ns2__GetActiveViewersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__GetActiveViewersResponse ** p = (_ns2__GetActiveViewersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetActiveViewersResponse, sizeof(_ns2__GetActiveViewersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetActiveViewersResponse(struct soap *soap, _ns2__GetActiveViewersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__GetActiveViewersResponse);
	if (soap_out_PointerTo_ns2__GetActiveViewersResponse(soap, tag?tag:"ns2:GetActiveViewersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetActiveViewersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetActiveViewersResponse(struct soap *soap, _ns2__GetActiveViewersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetActiveViewersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetActiveViewers(struct soap *soap, _ns2__GetActiveViewers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetActiveViewers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetActiveViewers(struct soap *soap, const char *tag, int id, _ns2__GetActiveViewers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetActiveViewers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__GetActiveViewers ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetActiveViewers(struct soap *soap, const char *tag, _ns2__GetActiveViewers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetActiveViewers **)soap_malloc(soap, sizeof(_ns2__GetActiveViewers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetActiveViewers *)soap_instantiate__ns2__GetActiveViewers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__GetActiveViewers ** p = (_ns2__GetActiveViewers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetActiveViewers, sizeof(_ns2__GetActiveViewers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetActiveViewers(struct soap *soap, _ns2__GetActiveViewers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__GetActiveViewers);
	if (soap_out_PointerTo_ns2__GetActiveViewers(soap, tag?tag:"ns2:GetActiveViewers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetActiveViewers ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetActiveViewers(struct soap *soap, _ns2__GetActiveViewers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetActiveViewers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetViewersResponse(struct soap *soap, _ns2__GetViewersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetViewersResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetViewersResponse(struct soap *soap, const char *tag, int id, _ns2__GetViewersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetViewersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__GetViewersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetViewersResponse(struct soap *soap, const char *tag, _ns2__GetViewersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetViewersResponse **)soap_malloc(soap, sizeof(_ns2__GetViewersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetViewersResponse *)soap_instantiate__ns2__GetViewersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__GetViewersResponse ** p = (_ns2__GetViewersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetViewersResponse, sizeof(_ns2__GetViewersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetViewersResponse(struct soap *soap, _ns2__GetViewersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__GetViewersResponse);
	if (soap_out_PointerTo_ns2__GetViewersResponse(soap, tag?tag:"ns2:GetViewersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetViewersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetViewersResponse(struct soap *soap, _ns2__GetViewersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetViewersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__GetViewers(struct soap *soap, _ns2__GetViewers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__GetViewers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__GetViewers(struct soap *soap, const char *tag, int id, _ns2__GetViewers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__GetViewers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__GetViewers ** SOAP_FMAC4 soap_in_PointerTo_ns2__GetViewers(struct soap *soap, const char *tag, _ns2__GetViewers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__GetViewers **)soap_malloc(soap, sizeof(_ns2__GetViewers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__GetViewers *)soap_instantiate__ns2__GetViewers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__GetViewers ** p = (_ns2__GetViewers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__GetViewers, sizeof(_ns2__GetViewers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__GetViewers(struct soap *soap, _ns2__GetViewers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__GetViewers);
	if (soap_out_PointerTo_ns2__GetViewers(soap, tag?tag:"ns2:GetViewers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__GetViewers ** SOAP_FMAC4 soap_get_PointerTo_ns2__GetViewers(struct soap *soap, _ns2__GetViewers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__GetViewers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__OpenFilesResponse(struct soap *soap, _ns2__OpenFilesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__OpenFilesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__OpenFilesResponse(struct soap *soap, const char *tag, int id, _ns2__OpenFilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__OpenFilesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__OpenFilesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__OpenFilesResponse(struct soap *soap, const char *tag, _ns2__OpenFilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__OpenFilesResponse **)soap_malloc(soap, sizeof(_ns2__OpenFilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__OpenFilesResponse *)soap_instantiate__ns2__OpenFilesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__OpenFilesResponse ** p = (_ns2__OpenFilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__OpenFilesResponse, sizeof(_ns2__OpenFilesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__OpenFilesResponse(struct soap *soap, _ns2__OpenFilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__OpenFilesResponse);
	if (soap_out_PointerTo_ns2__OpenFilesResponse(soap, tag?tag:"ns2:OpenFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__OpenFilesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__OpenFilesResponse(struct soap *soap, _ns2__OpenFilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__OpenFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__OpenFiles(struct soap *soap, _ns2__OpenFiles *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__OpenFiles))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__OpenFiles(struct soap *soap, const char *tag, int id, _ns2__OpenFiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__OpenFiles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns2__OpenFiles ** SOAP_FMAC4 soap_in_PointerTo_ns2__OpenFiles(struct soap *soap, const char *tag, _ns2__OpenFiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns2__OpenFiles **)soap_malloc(soap, sizeof(_ns2__OpenFiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns2__OpenFiles *)soap_instantiate__ns2__OpenFiles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns2__OpenFiles ** p = (_ns2__OpenFiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__OpenFiles, sizeof(_ns2__OpenFiles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__OpenFiles(struct soap *soap, _ns2__OpenFiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__OpenFiles);
	if (soap_out_PointerTo_ns2__OpenFiles(soap, tag?tag:"ns2:OpenFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns2__OpenFiles ** SOAP_FMAC4 soap_get_PointerTo_ns2__OpenFiles(struct soap *soap, _ns2__OpenFiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__OpenFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__StudyOfflineFault(struct soap *soap, ns6__StudyOfflineFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__StudyOfflineFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__StudyOfflineFault(struct soap *soap, const char *tag, int id, ns6__StudyOfflineFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__StudyOfflineFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__StudyOfflineFault ** SOAP_FMAC4 soap_in_PointerTons6__StudyOfflineFault(struct soap *soap, const char *tag, ns6__StudyOfflineFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__StudyOfflineFault **)soap_malloc(soap, sizeof(ns6__StudyOfflineFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__StudyOfflineFault *)soap_instantiate_ns6__StudyOfflineFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__StudyOfflineFault ** p = (ns6__StudyOfflineFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__StudyOfflineFault, sizeof(ns6__StudyOfflineFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__StudyOfflineFault(struct soap *soap, ns6__StudyOfflineFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__StudyOfflineFault);
	if (soap_out_PointerTons6__StudyOfflineFault(soap, tag?tag:"ns6:StudyOfflineFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__StudyOfflineFault ** SOAP_FMAC4 soap_get_PointerTons6__StudyOfflineFault(struct soap *soap, ns6__StudyOfflineFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__StudyOfflineFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__StudyNotFoundFault(struct soap *soap, ns6__StudyNotFoundFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__StudyNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__StudyNotFoundFault(struct soap *soap, const char *tag, int id, ns6__StudyNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__StudyNotFoundFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__StudyNotFoundFault ** SOAP_FMAC4 soap_in_PointerTons6__StudyNotFoundFault(struct soap *soap, const char *tag, ns6__StudyNotFoundFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__StudyNotFoundFault **)soap_malloc(soap, sizeof(ns6__StudyNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__StudyNotFoundFault *)soap_instantiate_ns6__StudyNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__StudyNotFoundFault ** p = (ns6__StudyNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__StudyNotFoundFault, sizeof(ns6__StudyNotFoundFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__StudyNotFoundFault(struct soap *soap, ns6__StudyNotFoundFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__StudyNotFoundFault);
	if (soap_out_PointerTons6__StudyNotFoundFault(soap, tag?tag:"ns6:StudyNotFoundFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__StudyNotFoundFault ** SOAP_FMAC4 soap_get_PointerTons6__StudyNotFoundFault(struct soap *soap, ns6__StudyNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__StudyNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__StudyNearlineFault(struct soap *soap, ns6__StudyNearlineFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__StudyNearlineFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__StudyNearlineFault(struct soap *soap, const char *tag, int id, ns6__StudyNearlineFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__StudyNearlineFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__StudyNearlineFault ** SOAP_FMAC4 soap_in_PointerTons6__StudyNearlineFault(struct soap *soap, const char *tag, ns6__StudyNearlineFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__StudyNearlineFault **)soap_malloc(soap, sizeof(ns6__StudyNearlineFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__StudyNearlineFault *)soap_instantiate_ns6__StudyNearlineFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__StudyNearlineFault ** p = (ns6__StudyNearlineFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__StudyNearlineFault, sizeof(ns6__StudyNearlineFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__StudyNearlineFault(struct soap *soap, ns6__StudyNearlineFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__StudyNearlineFault);
	if (soap_out_PointerTons6__StudyNearlineFault(soap, tag?tag:"ns6:StudyNearlineFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__StudyNearlineFault ** SOAP_FMAC4 soap_get_PointerTons6__StudyNearlineFault(struct soap *soap, ns6__StudyNearlineFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__StudyNearlineFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__StudyInUseFault(struct soap *soap, ns6__StudyInUseFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__StudyInUseFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__StudyInUseFault(struct soap *soap, const char *tag, int id, ns6__StudyInUseFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__StudyInUseFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__StudyInUseFault ** SOAP_FMAC4 soap_in_PointerTons6__StudyInUseFault(struct soap *soap, const char *tag, ns6__StudyInUseFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__StudyInUseFault **)soap_malloc(soap, sizeof(ns6__StudyInUseFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__StudyInUseFault *)soap_instantiate_ns6__StudyInUseFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__StudyInUseFault ** p = (ns6__StudyInUseFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__StudyInUseFault, sizeof(ns6__StudyInUseFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__StudyInUseFault(struct soap *soap, ns6__StudyInUseFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__StudyInUseFault);
	if (soap_out_PointerTons6__StudyInUseFault(soap, tag?tag:"ns6:StudyInUseFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__StudyInUseFault ** SOAP_FMAC4 soap_get_PointerTons6__StudyInUseFault(struct soap *soap, ns6__StudyInUseFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__StudyInUseFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OpenStudiesFault(struct soap *soap, ns2__OpenStudiesFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OpenStudiesFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OpenStudiesFault(struct soap *soap, const char *tag, int id, ns2__OpenStudiesFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OpenStudiesFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OpenStudiesFault ** SOAP_FMAC4 soap_in_PointerTons2__OpenStudiesFault(struct soap *soap, const char *tag, ns2__OpenStudiesFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OpenStudiesFault **)soap_malloc(soap, sizeof(ns2__OpenStudiesFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OpenStudiesFault *)soap_instantiate_ns2__OpenStudiesFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OpenStudiesFault ** p = (ns2__OpenStudiesFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OpenStudiesFault, sizeof(ns2__OpenStudiesFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OpenStudiesFault(struct soap *soap, ns2__OpenStudiesFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OpenStudiesFault);
	if (soap_out_PointerTons2__OpenStudiesFault(soap, tag?tag:"ns2:OpenStudiesFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OpenStudiesFault ** SOAP_FMAC4 soap_get_PointerTons2__OpenStudiesFault(struct soap *soap, ns2__OpenStudiesFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OpenStudiesFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OpenFilesFault(struct soap *soap, ns2__OpenFilesFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OpenFilesFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OpenFilesFault(struct soap *soap, const char *tag, int id, ns2__OpenFilesFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OpenFilesFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OpenFilesFault ** SOAP_FMAC4 soap_in_PointerTons2__OpenFilesFault(struct soap *soap, const char *tag, ns2__OpenFilesFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OpenFilesFault **)soap_malloc(soap, sizeof(ns2__OpenFilesFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OpenFilesFault *)soap_instantiate_ns2__OpenFilesFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OpenFilesFault ** p = (ns2__OpenFilesFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OpenFilesFault, sizeof(ns2__OpenFilesFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OpenFilesFault(struct soap *soap, ns2__OpenFilesFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OpenFilesFault);
	if (soap_out_PointerTons2__OpenFilesFault(soap, tag?tag:"ns2:OpenFilesFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OpenFilesFault ** SOAP_FMAC4 soap_get_PointerTons2__OpenFilesFault(struct soap *soap, ns2__OpenFilesFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OpenFilesFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NoViewersFault(struct soap *soap, ns2__NoViewersFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NoViewersFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NoViewersFault(struct soap *soap, const char *tag, int id, ns2__NoViewersFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NoViewersFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NoViewersFault ** SOAP_FMAC4 soap_in_PointerTons2__NoViewersFault(struct soap *soap, const char *tag, ns2__NoViewersFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NoViewersFault **)soap_malloc(soap, sizeof(ns2__NoViewersFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NoViewersFault *)soap_instantiate_ns2__NoViewersFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NoViewersFault ** p = (ns2__NoViewersFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NoViewersFault, sizeof(ns2__NoViewersFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NoViewersFault(struct soap *soap, ns2__NoViewersFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NoViewersFault);
	if (soap_out_PointerTons2__NoViewersFault(soap, tag?tag:"ns2:NoViewersFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NoViewersFault ** SOAP_FMAC4 soap_get_PointerTons2__NoViewersFault(struct soap *soap, ns2__NoViewersFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NoViewersFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NoActiveViewersFault(struct soap *soap, ns2__NoActiveViewersFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NoActiveViewersFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NoActiveViewersFault(struct soap *soap, const char *tag, int id, ns2__NoActiveViewersFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NoActiveViewersFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NoActiveViewersFault ** SOAP_FMAC4 soap_in_PointerTons2__NoActiveViewersFault(struct soap *soap, const char *tag, ns2__NoActiveViewersFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NoActiveViewersFault **)soap_malloc(soap, sizeof(ns2__NoActiveViewersFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NoActiveViewersFault *)soap_instantiate_ns2__NoActiveViewersFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NoActiveViewersFault ** p = (ns2__NoActiveViewersFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NoActiveViewersFault, sizeof(ns2__NoActiveViewersFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NoActiveViewersFault(struct soap *soap, ns2__NoActiveViewersFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NoActiveViewersFault);
	if (soap_out_PointerTons2__NoActiveViewersFault(soap, tag?tag:"ns2:NoActiveViewersFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NoActiveViewersFault ** SOAP_FMAC4 soap_get_PointerTons2__NoActiveViewersFault(struct soap *soap, ns2__NoActiveViewersFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NoActiveViewersFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ViewerNotFoundFault(struct soap *soap, ns2__ViewerNotFoundFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ViewerNotFoundFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ViewerNotFoundFault(struct soap *soap, const char *tag, int id, ns2__ViewerNotFoundFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ViewerNotFoundFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ViewerNotFoundFault ** SOAP_FMAC4 soap_in_PointerTons2__ViewerNotFoundFault(struct soap *soap, const char *tag, ns2__ViewerNotFoundFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ViewerNotFoundFault **)soap_malloc(soap, sizeof(ns2__ViewerNotFoundFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ViewerNotFoundFault *)soap_instantiate_ns2__ViewerNotFoundFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ViewerNotFoundFault ** p = (ns2__ViewerNotFoundFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ViewerNotFoundFault, sizeof(ns2__ViewerNotFoundFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ViewerNotFoundFault(struct soap *soap, ns2__ViewerNotFoundFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ViewerNotFoundFault);
	if (soap_out_PointerTons2__ViewerNotFoundFault(soap, tag?tag:"ns2:ViewerNotFoundFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ViewerNotFoundFault ** SOAP_FMAC4 soap_get_PointerTons2__ViewerNotFoundFault(struct soap *soap, ns2__ViewerNotFoundFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ViewerNotFoundFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__QueryFailedFault(struct soap *soap, ns5__QueryFailedFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__QueryFailedFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__QueryFailedFault(struct soap *soap, const char *tag, int id, ns5__QueryFailedFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__QueryFailedFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__QueryFailedFault ** SOAP_FMAC4 soap_in_PointerTons5__QueryFailedFault(struct soap *soap, const char *tag, ns5__QueryFailedFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__QueryFailedFault **)soap_malloc(soap, sizeof(ns5__QueryFailedFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__QueryFailedFault *)soap_instantiate_ns5__QueryFailedFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__QueryFailedFault ** p = (ns5__QueryFailedFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__QueryFailedFault, sizeof(ns5__QueryFailedFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__QueryFailedFault(struct soap *soap, ns5__QueryFailedFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__QueryFailedFault);
	if (soap_out_PointerTons5__QueryFailedFault(soap, tag?tag:"ns5:QueryFailedFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__QueryFailedFault ** SOAP_FMAC4 soap_get_PointerTons5__QueryFailedFault(struct soap *soap, ns5__QueryFailedFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__QueryFailedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__DataValidationFault(struct soap *soap, ns5__DataValidationFault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__DataValidationFault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__DataValidationFault(struct soap *soap, const char *tag, int id, ns5__DataValidationFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__DataValidationFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__DataValidationFault ** SOAP_FMAC4 soap_in_PointerTons5__DataValidationFault(struct soap *soap, const char *tag, ns5__DataValidationFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__DataValidationFault **)soap_malloc(soap, sizeof(ns5__DataValidationFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__DataValidationFault *)soap_instantiate_ns5__DataValidationFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__DataValidationFault ** p = (ns5__DataValidationFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__DataValidationFault, sizeof(ns5__DataValidationFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__DataValidationFault(struct soap *soap, ns5__DataValidationFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__DataValidationFault);
	if (soap_out_PointerTons5__DataValidationFault(soap, tag?tag:"ns5:DataValidationFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__DataValidationFault ** SOAP_FMAC4 soap_get_PointerTons5__DataValidationFault(struct soap *soap, ns5__DataValidationFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__DataValidationFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ArrayOfImageIdentifier(struct soap *soap, ns5__ArrayOfImageIdentifier *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ArrayOfImageIdentifier))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ArrayOfImageIdentifier(struct soap *soap, const char *tag, int id, ns5__ArrayOfImageIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ArrayOfImageIdentifier);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ArrayOfImageIdentifier ** SOAP_FMAC4 soap_in_PointerTons5__ArrayOfImageIdentifier(struct soap *soap, const char *tag, ns5__ArrayOfImageIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ArrayOfImageIdentifier **)soap_malloc(soap, sizeof(ns5__ArrayOfImageIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ArrayOfImageIdentifier *)soap_instantiate_ns5__ArrayOfImageIdentifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__ArrayOfImageIdentifier ** p = (ns5__ArrayOfImageIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ArrayOfImageIdentifier, sizeof(ns5__ArrayOfImageIdentifier), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ArrayOfImageIdentifier(struct soap *soap, ns5__ArrayOfImageIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ArrayOfImageIdentifier);
	if (soap_out_PointerTons5__ArrayOfImageIdentifier(soap, tag?tag:"ns5:ArrayOfImageIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ArrayOfImageIdentifier ** SOAP_FMAC4 soap_get_PointerTons5__ArrayOfImageIdentifier(struct soap *soap, ns5__ArrayOfImageIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ArrayOfImageIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ArrayOfSeriesIdentifier(struct soap *soap, ns5__ArrayOfSeriesIdentifier *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ArrayOfSeriesIdentifier))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ArrayOfSeriesIdentifier(struct soap *soap, const char *tag, int id, ns5__ArrayOfSeriesIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ArrayOfSeriesIdentifier);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ArrayOfSeriesIdentifier ** SOAP_FMAC4 soap_in_PointerTons5__ArrayOfSeriesIdentifier(struct soap *soap, const char *tag, ns5__ArrayOfSeriesIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ArrayOfSeriesIdentifier **)soap_malloc(soap, sizeof(ns5__ArrayOfSeriesIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ArrayOfSeriesIdentifier *)soap_instantiate_ns5__ArrayOfSeriesIdentifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__ArrayOfSeriesIdentifier ** p = (ns5__ArrayOfSeriesIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ArrayOfSeriesIdentifier, sizeof(ns5__ArrayOfSeriesIdentifier), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ArrayOfSeriesIdentifier(struct soap *soap, ns5__ArrayOfSeriesIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ArrayOfSeriesIdentifier);
	if (soap_out_PointerTons5__ArrayOfSeriesIdentifier(soap, tag?tag:"ns5:ArrayOfSeriesIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ArrayOfSeriesIdentifier ** SOAP_FMAC4 soap_get_PointerTons5__ArrayOfSeriesIdentifier(struct soap *soap, ns5__ArrayOfSeriesIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ArrayOfSeriesIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, ns5__ArrayOfStudyRootStudyIdentifier *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, const char *tag, int id, ns5__ArrayOfStudyRootStudyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ArrayOfStudyRootStudyIdentifier ** SOAP_FMAC4 soap_in_PointerTons5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, const char *tag, ns5__ArrayOfStudyRootStudyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ArrayOfStudyRootStudyIdentifier **)soap_malloc(soap, sizeof(ns5__ArrayOfStudyRootStudyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ArrayOfStudyRootStudyIdentifier *)soap_instantiate_ns5__ArrayOfStudyRootStudyIdentifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__ArrayOfStudyRootStudyIdentifier ** p = (ns5__ArrayOfStudyRootStudyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ArrayOfStudyRootStudyIdentifier, sizeof(ns5__ArrayOfStudyRootStudyIdentifier), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, ns5__ArrayOfStudyRootStudyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ArrayOfStudyRootStudyIdentifier);
	if (soap_out_PointerTons5__ArrayOfStudyRootStudyIdentifier(soap, tag?tag:"ns5:ArrayOfStudyRootStudyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ArrayOfStudyRootStudyIdentifier ** SOAP_FMAC4 soap_get_PointerTons5__ArrayOfStudyRootStudyIdentifier(struct soap *soap, ns5__ArrayOfStudyRootStudyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ArrayOfStudyRootStudyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ImageIdentifier(struct soap *soap, ns5__ImageIdentifier *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ImageIdentifier))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ImageIdentifier(struct soap *soap, const char *tag, int id, ns5__ImageIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ImageIdentifier);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ImageIdentifier ** SOAP_FMAC4 soap_in_PointerTons5__ImageIdentifier(struct soap *soap, const char *tag, ns5__ImageIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ImageIdentifier **)soap_malloc(soap, sizeof(ns5__ImageIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ImageIdentifier *)soap_instantiate_ns5__ImageIdentifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__ImageIdentifier ** p = (ns5__ImageIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ImageIdentifier, sizeof(ns5__ImageIdentifier), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ImageIdentifier(struct soap *soap, ns5__ImageIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ImageIdentifier);
	if (soap_out_PointerTons5__ImageIdentifier(soap, tag?tag:"ns5:ImageIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ImageIdentifier ** SOAP_FMAC4 soap_get_PointerTons5__ImageIdentifier(struct soap *soap, ns5__ImageIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ImageIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__SeriesIdentifier(struct soap *soap, ns5__SeriesIdentifier *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__SeriesIdentifier))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__SeriesIdentifier(struct soap *soap, const char *tag, int id, ns5__SeriesIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__SeriesIdentifier);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__SeriesIdentifier ** SOAP_FMAC4 soap_in_PointerTons5__SeriesIdentifier(struct soap *soap, const char *tag, ns5__SeriesIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__SeriesIdentifier **)soap_malloc(soap, sizeof(ns5__SeriesIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__SeriesIdentifier *)soap_instantiate_ns5__SeriesIdentifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__SeriesIdentifier ** p = (ns5__SeriesIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__SeriesIdentifier, sizeof(ns5__SeriesIdentifier), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__SeriesIdentifier(struct soap *soap, ns5__SeriesIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__SeriesIdentifier);
	if (soap_out_PointerTons5__SeriesIdentifier(soap, tag?tag:"ns5:SeriesIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__SeriesIdentifier ** SOAP_FMAC4 soap_get_PointerTons5__SeriesIdentifier(struct soap *soap, ns5__SeriesIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__SeriesIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CloseViewerRequest(struct soap *soap, ns2__CloseViewerRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CloseViewerRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CloseViewerRequest(struct soap *soap, const char *tag, int id, ns2__CloseViewerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CloseViewerRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CloseViewerRequest ** SOAP_FMAC4 soap_in_PointerTons2__CloseViewerRequest(struct soap *soap, const char *tag, ns2__CloseViewerRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CloseViewerRequest **)soap_malloc(soap, sizeof(ns2__CloseViewerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CloseViewerRequest *)soap_instantiate_ns2__CloseViewerRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CloseViewerRequest ** p = (ns2__CloseViewerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CloseViewerRequest, sizeof(ns2__CloseViewerRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CloseViewerRequest(struct soap *soap, ns2__CloseViewerRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CloseViewerRequest);
	if (soap_out_PointerTons2__CloseViewerRequest(soap, tag?tag:"ns2:CloseViewerRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CloseViewerRequest ** SOAP_FMAC4 soap_get_PointerTons2__CloseViewerRequest(struct soap *soap, ns2__CloseViewerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CloseViewerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ActivateViewerRequest(struct soap *soap, ns2__ActivateViewerRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ActivateViewerRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ActivateViewerRequest(struct soap *soap, const char *tag, int id, ns2__ActivateViewerRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ActivateViewerRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ActivateViewerRequest ** SOAP_FMAC4 soap_in_PointerTons2__ActivateViewerRequest(struct soap *soap, const char *tag, ns2__ActivateViewerRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ActivateViewerRequest **)soap_malloc(soap, sizeof(ns2__ActivateViewerRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ActivateViewerRequest *)soap_instantiate_ns2__ActivateViewerRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ActivateViewerRequest ** p = (ns2__ActivateViewerRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ActivateViewerRequest, sizeof(ns2__ActivateViewerRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ActivateViewerRequest(struct soap *soap, ns2__ActivateViewerRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ActivateViewerRequest);
	if (soap_out_PointerTons2__ActivateViewerRequest(soap, tag?tag:"ns2:ActivateViewerRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ActivateViewerRequest ** SOAP_FMAC4 soap_get_PointerTons2__ActivateViewerRequest(struct soap *soap, ns2__ActivateViewerRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ActivateViewerRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OpenStudiesResult(struct soap *soap, ns2__OpenStudiesResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OpenStudiesResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OpenStudiesResult(struct soap *soap, const char *tag, int id, ns2__OpenStudiesResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OpenStudiesResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OpenStudiesResult ** SOAP_FMAC4 soap_in_PointerTons2__OpenStudiesResult(struct soap *soap, const char *tag, ns2__OpenStudiesResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OpenStudiesResult **)soap_malloc(soap, sizeof(ns2__OpenStudiesResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OpenStudiesResult *)soap_instantiate_ns2__OpenStudiesResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OpenStudiesResult ** p = (ns2__OpenStudiesResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OpenStudiesResult, sizeof(ns2__OpenStudiesResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OpenStudiesResult(struct soap *soap, ns2__OpenStudiesResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OpenStudiesResult);
	if (soap_out_PointerTons2__OpenStudiesResult(soap, tag?tag:"ns2:OpenStudiesResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OpenStudiesResult ** SOAP_FMAC4 soap_get_PointerTons2__OpenStudiesResult(struct soap *soap, ns2__OpenStudiesResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OpenStudiesResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OpenStudiesRequest(struct soap *soap, ns2__OpenStudiesRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OpenStudiesRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OpenStudiesRequest(struct soap *soap, const char *tag, int id, ns2__OpenStudiesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OpenStudiesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OpenStudiesRequest ** SOAP_FMAC4 soap_in_PointerTons2__OpenStudiesRequest(struct soap *soap, const char *tag, ns2__OpenStudiesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OpenStudiesRequest **)soap_malloc(soap, sizeof(ns2__OpenStudiesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OpenStudiesRequest *)soap_instantiate_ns2__OpenStudiesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OpenStudiesRequest ** p = (ns2__OpenStudiesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OpenStudiesRequest, sizeof(ns2__OpenStudiesRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OpenStudiesRequest(struct soap *soap, ns2__OpenStudiesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OpenStudiesRequest);
	if (soap_out_PointerTons2__OpenStudiesRequest(soap, tag?tag:"ns2:OpenStudiesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OpenStudiesRequest ** SOAP_FMAC4 soap_get_PointerTons2__OpenStudiesRequest(struct soap *soap, ns2__OpenStudiesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OpenStudiesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GetViewerInfoResult(struct soap *soap, ns2__GetViewerInfoResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GetViewerInfoResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GetViewerInfoResult(struct soap *soap, const char *tag, int id, ns2__GetViewerInfoResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GetViewerInfoResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GetViewerInfoResult ** SOAP_FMAC4 soap_in_PointerTons2__GetViewerInfoResult(struct soap *soap, const char *tag, ns2__GetViewerInfoResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GetViewerInfoResult **)soap_malloc(soap, sizeof(ns2__GetViewerInfoResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GetViewerInfoResult *)soap_instantiate_ns2__GetViewerInfoResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__GetViewerInfoResult ** p = (ns2__GetViewerInfoResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GetViewerInfoResult, sizeof(ns2__GetViewerInfoResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GetViewerInfoResult(struct soap *soap, ns2__GetViewerInfoResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GetViewerInfoResult);
	if (soap_out_PointerTons2__GetViewerInfoResult(soap, tag?tag:"ns2:GetViewerInfoResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GetViewerInfoResult ** SOAP_FMAC4 soap_get_PointerTons2__GetViewerInfoResult(struct soap *soap, ns2__GetViewerInfoResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GetViewerInfoResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GetViewerInfoRequest(struct soap *soap, ns2__GetViewerInfoRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GetViewerInfoRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GetViewerInfoRequest(struct soap *soap, const char *tag, int id, ns2__GetViewerInfoRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GetViewerInfoRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GetViewerInfoRequest ** SOAP_FMAC4 soap_in_PointerTons2__GetViewerInfoRequest(struct soap *soap, const char *tag, ns2__GetViewerInfoRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GetViewerInfoRequest **)soap_malloc(soap, sizeof(ns2__GetViewerInfoRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GetViewerInfoRequest *)soap_instantiate_ns2__GetViewerInfoRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__GetViewerInfoRequest ** p = (ns2__GetViewerInfoRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GetViewerInfoRequest, sizeof(ns2__GetViewerInfoRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GetViewerInfoRequest(struct soap *soap, ns2__GetViewerInfoRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GetViewerInfoRequest);
	if (soap_out_PointerTons2__GetViewerInfoRequest(soap, tag?tag:"ns2:GetViewerInfoRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GetViewerInfoRequest ** SOAP_FMAC4 soap_get_PointerTons2__GetViewerInfoRequest(struct soap *soap, ns2__GetViewerInfoRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GetViewerInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GetActiveViewersResult(struct soap *soap, ns2__GetActiveViewersResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GetActiveViewersResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GetActiveViewersResult(struct soap *soap, const char *tag, int id, ns2__GetActiveViewersResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GetActiveViewersResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GetActiveViewersResult ** SOAP_FMAC4 soap_in_PointerTons2__GetActiveViewersResult(struct soap *soap, const char *tag, ns2__GetActiveViewersResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GetActiveViewersResult **)soap_malloc(soap, sizeof(ns2__GetActiveViewersResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GetActiveViewersResult *)soap_instantiate_ns2__GetActiveViewersResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__GetActiveViewersResult ** p = (ns2__GetActiveViewersResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GetActiveViewersResult, sizeof(ns2__GetActiveViewersResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GetActiveViewersResult(struct soap *soap, ns2__GetActiveViewersResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GetActiveViewersResult);
	if (soap_out_PointerTons2__GetActiveViewersResult(soap, tag?tag:"ns2:GetActiveViewersResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GetActiveViewersResult ** SOAP_FMAC4 soap_get_PointerTons2__GetActiveViewersResult(struct soap *soap, ns2__GetActiveViewersResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GetActiveViewersResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GetViewersResult(struct soap *soap, ns2__GetViewersResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GetViewersResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GetViewersResult(struct soap *soap, const char *tag, int id, ns2__GetViewersResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GetViewersResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GetViewersResult ** SOAP_FMAC4 soap_in_PointerTons2__GetViewersResult(struct soap *soap, const char *tag, ns2__GetViewersResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GetViewersResult **)soap_malloc(soap, sizeof(ns2__GetViewersResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GetViewersResult *)soap_instantiate_ns2__GetViewersResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__GetViewersResult ** p = (ns2__GetViewersResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GetViewersResult, sizeof(ns2__GetViewersResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GetViewersResult(struct soap *soap, ns2__GetViewersResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GetViewersResult);
	if (soap_out_PointerTons2__GetViewersResult(soap, tag?tag:"ns2:GetViewersResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GetViewersResult ** SOAP_FMAC4 soap_get_PointerTons2__GetViewersResult(struct soap *soap, ns2__GetViewersResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GetViewersResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__GetViewersRequest(struct soap *soap, ns2__GetViewersRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__GetViewersRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__GetViewersRequest(struct soap *soap, const char *tag, int id, ns2__GetViewersRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__GetViewersRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__GetViewersRequest ** SOAP_FMAC4 soap_in_PointerTons2__GetViewersRequest(struct soap *soap, const char *tag, ns2__GetViewersRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__GetViewersRequest **)soap_malloc(soap, sizeof(ns2__GetViewersRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__GetViewersRequest *)soap_instantiate_ns2__GetViewersRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__GetViewersRequest ** p = (ns2__GetViewersRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__GetViewersRequest, sizeof(ns2__GetViewersRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__GetViewersRequest(struct soap *soap, ns2__GetViewersRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__GetViewersRequest);
	if (soap_out_PointerTons2__GetViewersRequest(soap, tag?tag:"ns2:GetViewersRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__GetViewersRequest ** SOAP_FMAC4 soap_get_PointerTons2__GetViewersRequest(struct soap *soap, ns2__GetViewersRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__GetViewersRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OpenFilesResult(struct soap *soap, ns2__OpenFilesResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OpenFilesResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OpenFilesResult(struct soap *soap, const char *tag, int id, ns2__OpenFilesResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OpenFilesResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OpenFilesResult ** SOAP_FMAC4 soap_in_PointerTons2__OpenFilesResult(struct soap *soap, const char *tag, ns2__OpenFilesResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OpenFilesResult **)soap_malloc(soap, sizeof(ns2__OpenFilesResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OpenFilesResult *)soap_instantiate_ns2__OpenFilesResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OpenFilesResult ** p = (ns2__OpenFilesResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OpenFilesResult, sizeof(ns2__OpenFilesResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OpenFilesResult(struct soap *soap, ns2__OpenFilesResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OpenFilesResult);
	if (soap_out_PointerTons2__OpenFilesResult(soap, tag?tag:"ns2:OpenFilesResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OpenFilesResult ** SOAP_FMAC4 soap_get_PointerTons2__OpenFilesResult(struct soap *soap, ns2__OpenFilesResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OpenFilesResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OpenFilesRequest(struct soap *soap, ns2__OpenFilesRequest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OpenFilesRequest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OpenFilesRequest(struct soap *soap, const char *tag, int id, ns2__OpenFilesRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OpenFilesRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OpenFilesRequest ** SOAP_FMAC4 soap_in_PointerTons2__OpenFilesRequest(struct soap *soap, const char *tag, ns2__OpenFilesRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OpenFilesRequest **)soap_malloc(soap, sizeof(ns2__OpenFilesRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OpenFilesRequest *)soap_instantiate_ns2__OpenFilesRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OpenFilesRequest ** p = (ns2__OpenFilesRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OpenFilesRequest, sizeof(ns2__OpenFilesRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OpenFilesRequest(struct soap *soap, ns2__OpenFilesRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OpenFilesRequest);
	if (soap_out_PointerTons2__OpenFilesRequest(soap, tag?tag:"ns2:OpenFilesRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OpenFilesRequest ** SOAP_FMAC4 soap_get_PointerTons2__OpenFilesRequest(struct soap *soap, ns2__OpenFilesRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OpenFilesRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__OpenStudyInfo(struct soap *soap, ns2__OpenStudyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__OpenStudyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__OpenStudyInfo(struct soap *soap, const char *tag, int id, ns2__OpenStudyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__OpenStudyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__OpenStudyInfo ** SOAP_FMAC4 soap_in_PointerTons2__OpenStudyInfo(struct soap *soap, const char *tag, ns2__OpenStudyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__OpenStudyInfo **)soap_malloc(soap, sizeof(ns2__OpenStudyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__OpenStudyInfo *)soap_instantiate_ns2__OpenStudyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__OpenStudyInfo ** p = (ns2__OpenStudyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__OpenStudyInfo, sizeof(ns2__OpenStudyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__OpenStudyInfo(struct soap *soap, ns2__OpenStudyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__OpenStudyInfo);
	if (soap_out_PointerTons2__OpenStudyInfo(soap, tag?tag:"ns2:OpenStudyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__OpenStudyInfo ** SOAP_FMAC4 soap_get_PointerTons2__OpenStudyInfo(struct soap *soap, ns2__OpenStudyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__OpenStudyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ArrayOfOpenStudyInfo(struct soap *soap, ns2__ArrayOfOpenStudyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ArrayOfOpenStudyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ArrayOfOpenStudyInfo(struct soap *soap, const char *tag, int id, ns2__ArrayOfOpenStudyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ArrayOfOpenStudyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ArrayOfOpenStudyInfo ** SOAP_FMAC4 soap_in_PointerTons2__ArrayOfOpenStudyInfo(struct soap *soap, const char *tag, ns2__ArrayOfOpenStudyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ArrayOfOpenStudyInfo **)soap_malloc(soap, sizeof(ns2__ArrayOfOpenStudyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ArrayOfOpenStudyInfo *)soap_instantiate_ns2__ArrayOfOpenStudyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ArrayOfOpenStudyInfo ** p = (ns2__ArrayOfOpenStudyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ArrayOfOpenStudyInfo, sizeof(ns2__ArrayOfOpenStudyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ArrayOfOpenStudyInfo(struct soap *soap, ns2__ArrayOfOpenStudyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ArrayOfOpenStudyInfo);
	if (soap_out_PointerTons2__ArrayOfOpenStudyInfo(soap, tag?tag:"ns2:ArrayOfOpenStudyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ArrayOfOpenStudyInfo ** SOAP_FMAC4 soap_get_PointerTons2__ArrayOfOpenStudyInfo(struct soap *soap, ns2__ArrayOfOpenStudyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ArrayOfOpenStudyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ArrayOfViewer(struct soap *soap, ns2__ArrayOfViewer *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ArrayOfViewer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ArrayOfViewer(struct soap *soap, const char *tag, int id, ns2__ArrayOfViewer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ArrayOfViewer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ArrayOfViewer ** SOAP_FMAC4 soap_in_PointerTons2__ArrayOfViewer(struct soap *soap, const char *tag, ns2__ArrayOfViewer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ArrayOfViewer **)soap_malloc(soap, sizeof(ns2__ArrayOfViewer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ArrayOfViewer *)soap_instantiate_ns2__ArrayOfViewer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ArrayOfViewer ** p = (ns2__ArrayOfViewer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ArrayOfViewer, sizeof(ns2__ArrayOfViewer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ArrayOfViewer(struct soap *soap, ns2__ArrayOfViewer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ArrayOfViewer);
	if (soap_out_PointerTons2__ArrayOfViewer(soap, tag?tag:"ns2:ArrayOfViewer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ArrayOfViewer ** SOAP_FMAC4 soap_get_PointerTons2__ArrayOfViewer(struct soap *soap, ns2__ArrayOfViewer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ArrayOfViewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__StudyRootStudyIdentifier(struct soap *soap, ns5__StudyRootStudyIdentifier *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__StudyRootStudyIdentifier))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__StudyRootStudyIdentifier(struct soap *soap, const char *tag, int id, ns5__StudyRootStudyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__StudyRootStudyIdentifier);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__StudyRootStudyIdentifier ** SOAP_FMAC4 soap_in_PointerTons5__StudyRootStudyIdentifier(struct soap *soap, const char *tag, ns5__StudyRootStudyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__StudyRootStudyIdentifier **)soap_malloc(soap, sizeof(ns5__StudyRootStudyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__StudyRootStudyIdentifier *)soap_instantiate_ns5__StudyRootStudyIdentifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__StudyRootStudyIdentifier ** p = (ns5__StudyRootStudyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__StudyRootStudyIdentifier, sizeof(ns5__StudyRootStudyIdentifier), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__StudyRootStudyIdentifier(struct soap *soap, ns5__StudyRootStudyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__StudyRootStudyIdentifier);
	if (soap_out_PointerTons5__StudyRootStudyIdentifier(soap, tag?tag:"ns5:StudyRootStudyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__StudyRootStudyIdentifier ** SOAP_FMAC4 soap_get_PointerTons5__StudyRootStudyIdentifier(struct soap *soap, ns5__StudyRootStudyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__StudyRootStudyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Viewer(struct soap *soap, ns2__Viewer *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Viewer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Viewer(struct soap *soap, const char *tag, int id, ns2__Viewer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Viewer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Viewer ** SOAP_FMAC4 soap_in_PointerTons2__Viewer(struct soap *soap, const char *tag, ns2__Viewer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Viewer **)soap_malloc(soap, sizeof(ns2__Viewer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Viewer *)soap_instantiate_ns2__Viewer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Viewer ** p = (ns2__Viewer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Viewer, sizeof(ns2__Viewer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Viewer(struct soap *soap, ns2__Viewer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Viewer);
	if (soap_out_PointerTons2__Viewer(soap, tag?tag:"ns2:Viewer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Viewer ** SOAP_FMAC4 soap_get_PointerTons2__Viewer(struct soap *soap, ns2__Viewer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Viewer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ArrayOfstring(struct soap *soap, ns4__ArrayOfstring *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ArrayOfstring))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ArrayOfstring(struct soap *soap, const char *tag, int id, ns4__ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ArrayOfstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ArrayOfstring ** SOAP_FMAC4 soap_in_PointerTons4__ArrayOfstring(struct soap *soap, const char *tag, ns4__ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ArrayOfstring **)soap_malloc(soap, sizeof(ns4__ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ArrayOfstring *)soap_instantiate_ns4__ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ArrayOfstring ** p = (ns4__ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ArrayOfstring, sizeof(ns4__ArrayOfstring), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ArrayOfstring(struct soap *soap, ns4__ArrayOfstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ArrayOfstring);
	if (soap_out_PointerTons4__ArrayOfstring(soap, tag?tag:"ns4:ArrayOfstring", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns4__ArrayOfstring ** SOAP_FMAC4 soap_get_PointerTons4__ArrayOfstring(struct soap *soap, ns4__ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ImageIdentifier(struct soap *soap, std::vector<ns5__ImageIdentifier * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ImageIdentifier(struct soap *soap, const std::vector<ns5__ImageIdentifier * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__ImageIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ImageIdentifier(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ImageIdentifier(struct soap *soap, const char *tag, int id, const std::vector<ns5__ImageIdentifier * >*a, const char *type)
{
	for (std::vector<ns5__ImageIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ImageIdentifier(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ImageIdentifier * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ImageIdentifier(struct soap *soap, const char *tag, std::vector<ns5__ImageIdentifier * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__ImageIdentifier *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__ImageIdentifier, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ImageIdentifier, sizeof(ns5__ImageIdentifier), 1))
				break;
			if (!soap_in_PointerTons5__ImageIdentifier(soap, tag, NULL, "ns5:ImageIdentifier"))
				break;
		}
		else if (!soap_in_PointerTons5__ImageIdentifier(soap, tag, &n, "ns5:ImageIdentifier"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ImageIdentifier(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ImageIdentifier * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__ImageIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__ImageIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ImageIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__ImageIdentifier * >);
		if (size)
			*size = sizeof(std::vector<ns5__ImageIdentifier * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__ImageIdentifier * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__ImageIdentifier * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__ImageIdentifier * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__ImageIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__ImageIdentifier * > %p -> %p\n", q, p));
	*(std::vector<ns5__ImageIdentifier * >*)p = *(std::vector<ns5__ImageIdentifier * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__SeriesIdentifier(struct soap *soap, std::vector<ns5__SeriesIdentifier * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__SeriesIdentifier(struct soap *soap, const std::vector<ns5__SeriesIdentifier * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__SeriesIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__SeriesIdentifier(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__SeriesIdentifier(struct soap *soap, const char *tag, int id, const std::vector<ns5__SeriesIdentifier * >*a, const char *type)
{
	for (std::vector<ns5__SeriesIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__SeriesIdentifier(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__SeriesIdentifier * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__SeriesIdentifier(struct soap *soap, const char *tag, std::vector<ns5__SeriesIdentifier * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__SeriesIdentifier *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__SeriesIdentifier, SOAP_TYPE_std__vectorTemplateOfPointerTons5__SeriesIdentifier, sizeof(ns5__SeriesIdentifier), 1))
				break;
			if (!soap_in_PointerTons5__SeriesIdentifier(soap, tag, NULL, "ns5:SeriesIdentifier"))
				break;
		}
		else if (!soap_in_PointerTons5__SeriesIdentifier(soap, tag, &n, "ns5:SeriesIdentifier"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__SeriesIdentifier(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__SeriesIdentifier * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__SeriesIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__SeriesIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__SeriesIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__SeriesIdentifier * >);
		if (size)
			*size = sizeof(std::vector<ns5__SeriesIdentifier * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__SeriesIdentifier * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__SeriesIdentifier * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__SeriesIdentifier * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__SeriesIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__SeriesIdentifier * > %p -> %p\n", q, p));
	*(std::vector<ns5__SeriesIdentifier * >*)p = *(std::vector<ns5__SeriesIdentifier * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(struct soap *soap, std::vector<ns5__StudyRootStudyIdentifier * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(struct soap *soap, const std::vector<ns5__StudyRootStudyIdentifier * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns5__StudyRootStudyIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__StudyRootStudyIdentifier(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(struct soap *soap, const char *tag, int id, const std::vector<ns5__StudyRootStudyIdentifier * >*a, const char *type)
{
	for (std::vector<ns5__StudyRootStudyIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__StudyRootStudyIdentifier(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__StudyRootStudyIdentifier * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(struct soap *soap, const char *tag, std::vector<ns5__StudyRootStudyIdentifier * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns5__StudyRootStudyIdentifier *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__StudyRootStudyIdentifier, SOAP_TYPE_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier, sizeof(ns5__StudyRootStudyIdentifier), 1))
				break;
			if (!soap_in_PointerTons5__StudyRootStudyIdentifier(soap, tag, NULL, "ns5:StudyRootStudyIdentifier"))
				break;
		}
		else if (!soap_in_PointerTons5__StudyRootStudyIdentifier(soap, tag, &n, "ns5:StudyRootStudyIdentifier"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__StudyRootStudyIdentifier * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__StudyRootStudyIdentifier * >);
		if (size)
			*size = sizeof(std::vector<ns5__StudyRootStudyIdentifier * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns5__StudyRootStudyIdentifier * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns5__StudyRootStudyIdentifier * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns5__StudyRootStudyIdentifier * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__StudyRootStudyIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__StudyRootStudyIdentifier * > %p -> %p\n", q, p));
	*(std::vector<ns5__StudyRootStudyIdentifier * >*)p = *(std::vector<ns5__StudyRootStudyIdentifier * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	std::string n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		soap_default_std__string(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
			return NULL;
		soap_update_pointers(soap, (char*)&n, (char*)&n + sizeof(n), (char*)&(*a->insert(a->end(), n)), (char*)&n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<std::string >, n);
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__OpenStudyInfo(struct soap *soap, std::vector<ns2__OpenStudyInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__OpenStudyInfo(struct soap *soap, const std::vector<ns2__OpenStudyInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__OpenStudyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__OpenStudyInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__OpenStudyInfo(struct soap *soap, const char *tag, int id, const std::vector<ns2__OpenStudyInfo * >*a, const char *type)
{
	for (std::vector<ns2__OpenStudyInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__OpenStudyInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__OpenStudyInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__OpenStudyInfo(struct soap *soap, const char *tag, std::vector<ns2__OpenStudyInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__OpenStudyInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__OpenStudyInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OpenStudyInfo, sizeof(ns2__OpenStudyInfo), 1))
				break;
			if (!soap_in_PointerTons2__OpenStudyInfo(soap, tag, NULL, "ns2:OpenStudyInfo"))
				break;
		}
		else if (!soap_in_PointerTons2__OpenStudyInfo(soap, tag, &n, "ns2:OpenStudyInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__OpenStudyInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__OpenStudyInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__OpenStudyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__OpenStudyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__OpenStudyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__OpenStudyInfo * >);
		if (size)
			*size = sizeof(std::vector<ns2__OpenStudyInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__OpenStudyInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__OpenStudyInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__OpenStudyInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__OpenStudyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__OpenStudyInfo * > %p -> %p\n", q, p));
	*(std::vector<ns2__OpenStudyInfo * >*)p = *(std::vector<ns2__OpenStudyInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__Viewer(struct soap *soap, std::vector<ns2__Viewer * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__Viewer(struct soap *soap, const std::vector<ns2__Viewer * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns2__Viewer * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__Viewer(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__Viewer(struct soap *soap, const char *tag, int id, const std::vector<ns2__Viewer * >*a, const char *type)
{
	for (std::vector<ns2__Viewer * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__Viewer(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__Viewer * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__Viewer(struct soap *soap, const char *tag, std::vector<ns2__Viewer * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns2__Viewer *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__Viewer, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Viewer, sizeof(ns2__Viewer), 1))
				break;
			if (!soap_in_PointerTons2__Viewer(soap, tag, NULL, "ns2:Viewer"))
				break;
		}
		else if (!soap_in_PointerTons2__Viewer(soap, tag, &n, "ns2:Viewer"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__Viewer(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__Viewer * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__Viewer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__Viewer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__Viewer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__Viewer * >);
		if (size)
			*size = sizeof(std::vector<ns2__Viewer * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns2__Viewer * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns2__Viewer * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns2__Viewer * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__Viewer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__Viewer * > %p -> %p\n", q, p));
	*(std::vector<ns2__Viewer * >*)p = *(std::vector<ns2__Viewer * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
